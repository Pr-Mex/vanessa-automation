#Область ОписаниеПеременных 

// ОкноКлиентскогоПриложения - форма Vanessa-Automation, см. УстановитьСлужебныеПеременные
&НаКлиенте
Перем Ванесса;

// ВнешняяОбработка.ИнициаторДанных - кэшированный объект, см. ТекущийОбъект
&НаСервере
Перем мТекущийОбъектНаСервере;

// Структура - кэш клиента, см. КэшКлиент
&НаКлиенте
Перем КэшКлиент;

// Структура - кэш сервера, см. КэшСервер
&НаСервере
Перем КэшСервер;

#КонецОбласти 

#Область ПрограммныйИнтерфейс

#Область ЗначенияПеременных
 
// Для получения параметра сеанса с клиента
// 
// Параметры:
// 	ИмяПараметра - Строка
// 	
// Возвращаемое значение:
// 	Произвольный - значение параметра сеанса
// 
&НаКлиенте
Функция ПараметрСеанса(ИмяПараметра) Экспорт
	Возврат ПараметрСеансаНаСервере(ИмяПараметра);	
КонецФункции

// При необходимости сослаться на ссылку перечисления, или предопределеного элемента
// необходимо создать имя переменной посредством этого метода.
// 
// Параметры:
// 	ИмяПеременной - Строка
// 	Значение - Произвольный
//
&НаКлиенте
Процедура ЗапомнитьЗначение(ИмяПеременной, Значение, ПомещатьВанессу = Истина) Экспорт
	Попытка
		ЗначенияПеременных().Вставить(ИмяПеременной, Значение);	
		СоответствиеЗначенийПеременных().Вставить(нРег(ИмяПеременной), Значение);
		ПеременныеСсылок().Вставить(Значение, ИмяПеременной);
		ЗапомнитьПеременнуюСценария(ИмяПеременной);
	Исключение
	КонецПопытки;
	
	Если ПомещатьВанессу Тогда
		Ванесса.СохранитьЗначениеПеременнойВКонтекст(ИмяПеременной, Значение, Ложь);		
	КонецЕсли; 
	
КонецПроцедуры

// Кэш значений переменных, в виде структуры. Сделан экспортным для удобства работы в отладке
// 
// Возвращаемое значение:
// 	Структура
//
&НаКлиенте
Функция ЗначенияПеременных() Экспорт
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("ЗначенияПеременных") Тогда
		КэшКлиент.Вставить("ЗначенияПеременных", Новый Структура);	
	КонецЕсли; 	
	Возврат КэшКлиент.ЗначенияПеременных;	
КонецФункции

// Значение переменной, описанной ранее методами "ЗапомнитьЗначение" или "НовоеОписаниеОбъекта"
// Если переменная была инициализирована методом "НовоеОписаниеОбъекта", то при отсутствии значения 
// в кэше происходит создание \ обновление объекта. 
// 
// Параметры:
// 	ИмяПеременной - Строка
// 	
// Возвращаемое значение:
//  Произвольный
// 	
&НаКлиенте
Функция ЗначениеПеременной(ИмяПеременной) Экспорт
	Перем Результат;
	
	Если НЕ ЗначенияПеременных().Свойство(ИмяПеременной, Результат) Тогда
		ОписаниеОбъекта = Неопределено;
		Если НЕ ОписанияОбъектов().Свойство(ИмяПеременной, ОписаниеОбъекта) Тогда
			ВызватьИсключение "Переменная """ + ИмяПеременной + """ не описана";			
		КонецЕсли; 
		Результат = ЗначениеБДПоОписанию(ОписаниеОбъекта);		
		ЗапомнитьЗначение(ИмяПеременной, Результат);
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции 

// Клиентская обертка для метода "ПолучитьСсылку" менеджера используемого класса
// 
// Параметры:
// 	Класс - Строка - список поддерживаемых классов см. в "КлассыОбъектовКлиентСервер"
// 	Вид - Строка - вид класса
// 	
// Возвращаемое значение:
// 	Ссылка
// 	
&НаКлиенте
Функция ПолучитьСсылкуВида(Класс, Вид) Экспорт
	Возврат ПолучитьСсылкуВидаНаСервере(Класс, Вид);	
КонецФункции
 
#КонецОбласти 

#Область ОперацииНадОбъектами

// Запись документа, с клиента
//
// Параметры:
//  СсылкаИлиИмяПеременной - Ссылка, Строка - ссылка проверку заполнения объекта которой нужно вызвать,
//	либо переменная ссылки
//  Режим - РежимЗаписиДокумента, Строка - Режим записи, либо его идентификатор
//	ВызыватьИсключение - Булево - при ошибке записи документа вызывать исключение
//	
// Возвращаемое значение
//	Структура - см. НовыйРезультатМетода
//
&НаКлиенте
Функция РезультатЗаписиДокумента(СсылкаИлиИмяПеременной, Режим, ВызыватьИсключение = Ложь) Экспорт
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	
	Если ТипЗнч(Режим) = Тип("Строка") Тогда
		РежимЗначение = РежимЗаписиДокумента[Режим];
	Иначе
		РежимЗначение = Режим;
	КонецЕсли; 
	
	Результат = РезультатЗаписиДокументаНаСервере(ОписаниеСсылки.Ссылка, РежимЗначение, ВызыватьИсключение);	
	
	Возврат Результат;
КонецФункции

// Установка значения константы, с клиента
// 
// Параметры:
// 	ИмяКонстанты - Строка
// 	ЗначениеКонстанты - Произвольный
// 	ПомешатьВХранилище - Булево - для констант типа "ХранилищеЗначения"
// 	УстанавливатьПараметрСеанса - Булево - устанавливать исходное значение переменной в одноименный 
// 	параметр сеанса
//
&НаКлиенте
Процедура УстановитьКонстанту(ИмяКонстанты, ЗначениеКонстанты,
	ПомешатьВХранилище = Ложь, УстанавливатьПараметрСеанса = Ложь) Экспорт
	
	СохранитьЗначениеКонстанты(ИмяКонстанты, ПомешатьВХранилище, УстанавливатьПараметрСеанса);	
	УстановитьКонстантуНаСервере(ИмяКонстанты, ЗначениеКонстанты, ПомешатьВХранилище, УстанавливатьПараметрСеанса);
	
КонецПроцедуры 

// Вызов метода "ПроверитьЗаполнение" с клиента
// 
// Параметры:
//	СсылкаИлиИмяПеременной - Ссылка, Строка - ссылка проверку заполнения объекта которой нужно вызвать,
//	либо переменная ссылки 
//	
// Возвращаемое значение:
//	Булево
// 	
&НаКлиенте
Функция ПроверкаЗаполненияПройдена(СсылкаИлиИмяПеременной, ВызыватьИсключение = Ложь) Экспорт
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	Результат = ПроверкаЗаполненияПройденаНаСервере(ОписаниеСсылки);
	
	Если ВызыватьИсключение И Результат.Ошибка Тогда
		ВызватьИсключение Результат.Сообщение;		
	КонецЕсли; 
	
	Возврат Результат;
КонецФункции

// Добавление движений по одному регистру в документ из таблицы геркина
// 
// Параметры:
// 	ДокИлиИмяПеременной - ДокументСсылка, Строка - при передачи строки ссылка документа получается 
// 	методом "ЗначениеПеременной" 
// 	ВидРегистра - Строка
// 	ТаблицаДвижений - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина
//
&НаКлиенте
Процедура ДобавитьДвиженияВДокумент(СсылкаИлиИмяПеременной, ВидРегистра, ТаблицаДвижений) Экспорт
	
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	ОписаниеОбъекта = ОписаниеОбъектаСсылки(ОписаниеСсылки);	
	Приемник = ОписаниеОбъекта.ПротоОбъект.Движения[ВидРегистра].Строки;	
	ПривестиТаблицуГеркина(ТаблицаДвижений, , Приемник);
	ОбновитьСсылкуОбъекта(ОписаниеСсылки.Ссылка, ОписаниеОбъекта);
	
КонецПроцедуры

// Заполнение табличной части объекта, по таблице геркина
// 
// Параметры:
// 	ИмяТЧ - Строка - имя табличной части
// 	СсылкаИлиИмяПеременной - Ссылка, Строка - приемник
// 	ТаблицаТЧ - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина
//
&НаКлиенте
Процедура ЗагрузитьТабличнуюЧастьОбъекта(ИмяТЧ, СсылкаИлиИмяПеременной, ТаблицаТЧ) Экспорт
	
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	ОписаниеОбъекта = ОписаниеОбъектаСсылки(ОписаниеСсылки);	
	Приемник = ОписаниеОбъекта.ПротоОбъект.ТабличныеЧасти[ИмяТЧ].Строки;	
	ПривестиТаблицуГеркина(ТаблицаТЧ, , Приемник);
	ОбновитьСсылкуОбъекта(ОписаниеСсылки.Ссылка, ОписаниеОбъекта);
	
КонецПроцедуры

// Заполнение реквизитов объекта, по таблице геркина
// 
// Параметры:
// 	СсылкаИлиИмяПеременной - Ссылка, Строка - Приемник
// 	Источник - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина. Здесь 
// 	ожидается таблица с обязательными колонками "Имя", "Значение". Отсутствие этих колонок приведет к
// 	выбросу исключения.
//
&НаКлиенте
Процедура ЗагрузитьТаблицуРеквизитовОбъекта(СсылкаИлиИмяПеременной, ТаблицаРеквизитов) Экспорт
	                       
	ПроверитьКолонкиТаблицыГеркина(ТаблицаРеквизитов, "Имя,Значение");
	СписокРеквизитов = ПривестиТаблицуГеркина(ТаблицаРеквизитов, "Имя");
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	ОписаниеОбъекта = ОписаниеОбъектаСсылки(ОписаниеСсылки);	
	
	Для каждого ОписаниеРеквизита Из СписокРеквизитов Цикл
		ОписаниеОбъекта.ПротоОбъект.Вставить(ОписаниеРеквизита.Имя, ОписаниеРеквизита.Значение);		
	КонецЦикла; 
	
	ОбновитьСсылкуОбъекта(ОписаниеСсылки.Ссылка, ОписаниеОбъекта);
	
КонецПроцедуры 

// Вызов метода объекта задачи "ВыполнитьЗадачу" с клиента
// 
// Параметры:
// 	СсылкаИлиИмяПеременной - ЗадачаСсылка, Строка
//
&НаКлиенте
Процедура ВыполнитьЗадачуПроцесса(СсылкаИлиИмяПеременной) Экспорт
	ОписаниеПеременной = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	ВыполнитьЗадачуПроцессаНаСервере(ОписаниеПеременной.Ссылка);	
КонецПроцедуры

// Вызов метода "Старт" бизнес процесса, с клиента
// 
// Параметры:
// 	СсылкаИлиИмяПеременной - БизнесПроцессСсылка, Строка
//
&НаКлиенте  
Процедура СтартоватьБизнесПроцесс(СсылкаИлиИмяПеременной) Экспорт
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	СтартоватьПроцессНаСервере(ОписаниеСсылки.Ссылка);
	
КонецПроцедуры 

#КонецОбласти 

#Область Очистка

// Откат изменений, порожденных плагином:
// - Ссылки удаляются
// - Наборы записей регистров сведений очищаются
// - Значения констант приводятся к значениям, которые были установлены до изменения
// 
&НаКлиенте
Процедура ОткатитьИзменения() Экспорт
	ИменаПеременных = Новый Массив;
	Для каждого КлючИЗначение Из ОписанияОбъектов() Цикл
		ИмяПеременной = КлючИЗначение.Ключ;
		ИменаПеременных.Добавить(ИмяПеременной);
	КонецЦикла; 
	
	ОчиститьПеременные(ИменаПеременных, КэшКонстант());
	
КонецПроцедуры 

// Пометка объектов определенного вида на удаление
// 
// Параметры:
// 	ИмяМенеджера - Строка - <Класс>.<ВидОбъекта>, например "Справочники.Контрагенты"
// 	Отбор - Структура - описание секции "Где" запроса (см. ОбъектыПоОтбору)
// 
&НаКлиенте
Процедура ПометитьОбъектыНаУдаление(ИмяМенеджера, Отбор = Неопределено) Экспорт
	ПометитьОбъектыНаУдалениеНаСервере(ИмяМенеджера, Отбор);	
КонецПроцедуры

// Непосредственное удаление объектов определенного вида
// 
// Параметры:
// 	ИмяМенеджера - Строка - <Класс>.<ВидОбъекта>, например "Справочники.Контрагенты"
// 	Отбор - Структура - описание секции "Где" запроса (см. ОбъектыПоОтбору)
// 
&НаКлиенте
Процедура УдалитьОбъектыБезКонтроляСсылок(ИмяМенеджера, Отбор = Неопределено) Экспорт
	УдалитьОбъектыБезКонтроляСсылокНаСервере(ИмяМенеджера, Отбор);	
КонецПроцедуры

// Удаление значения переменной из базы, и самой переменной из кэша
// 
// Параметры:
// 	ИмяПеременной - Строка
//
&НаКлиенте
Процедура УдалитьПеременную(ИмяПеременной) Экспорт
	ИменаПеременных = ЗначениеВМассиве(ИмяПеременной);
	ОчиститьПеременные(ИменаПеременных);
КонецПроцедуры 

// Удаление значений переменных, созданных в текущем сценарии
// 
&НаКлиенте
Процедура ОчиститьПеременныеТекущегоСценария() Экспорт
	ИмяСценария = ИмяТекущегоСценария();	
	ИменаПеременных = ПеременныеСценариев().Получить(ИмяСценария);
	
	КэшКонстантСценария = Новый Структура;
	Для каждого КлючИЗначение Из КэшКонстант() Цикл
		ИмяКонстанты = КлючИЗначение.Ключ;
		ОписаниеКонстанты = КлючИЗначение.Значение;		
		Если ОписаниеКонстанты.ИмяСценария = ИмяСценария Тогда
			КэшКонстантСценария.Вставить(ИмяКонстанты, ОписаниеКонстанты);
			
		КонецЕсли; 		
	КонецЦикла; 
	
	ОчиститьПеременные(ИменаПеременных, КэшКонстантСценария);
КонецПроцедуры

#КонецОбласти 

#Область СозданиеОбъектов

// Создание ссылки 
// 
// Параметры:
// 	ИмяМенеджера - Строка - <Класс>.<ВидОбъекта>, например "Справочники.Контрагенты"
// 	ИмяПеременой - Строка - имя переменной для помещения, см. ЗапомнитьЗначение. Для справочных объектов
// 	используется в качестве наименования
// 	УИД - Строка - уникальный идентификатор ссылки
// 	ДатаИлиЭтоГруппа - Дата, Булево - обязательный реквизит для классов с осью времени (Документы, 
// 		БизнесПроцессы, Задачи). Для справочных иерархических классов предоставляет возможность указания 
// 		признака группы. При заполненном параметре:
// 		- Для справочных классов будет вызвано исключение, если тип параметра отличается от "Булево". 
// 		Указание "Булево" для неиерархических классов будет проигнорировано.
// 		- Для классов с осью времени будет вызвано исключение, если тип параметра отличается от "Дата", и 
// 		если он не задан.
//	ВызовЗаполнения - Булево - вызов метода "Заполнить", с передачей Неопределено
// 	
// 	BSLLS:CognitiveComplexity-выкл
//
&НаКлиенте
Процедура СоздатьСсылкуСИменем(ИмяМенеджера, ИмяПеременой, УИД = "", ДатаИлиЭтоГруппа = Неопределено, ВызовЗаполнения = Ложь) Экспорт
	ЧастиИмени = РазложитьСтрокуВМассивПодстрок(ИмяМенеджера, ".");
	Класс = ЧастиИмени[0];
	Вид = ЧастиИмени[1];
	
	Если НЕ ЗначениеЗаполнено(УИД) Тогда
		УИД = УИДПеременной(ИмяМенеджера, ИмяПеременой, ДатаИлиЭтоГруппа);		
	КонецЕсли; 
	
	ОписаниеОбъекта = НовоеОписаниеОбъекта(ИмяПеременой, Класс, Вид);
	ОписаниеОбъекта.ВызовЗаполнения = ВызовЗаполнения;
	ПротоОбъект = ОписаниеОбъекта.ПротоОбъект;
	ПротоОбъект.Ссылка = УИД;
	
	ВидКласса = ВидКласса(Класс);
	ВидыКлассов = ВидыКлассов();

	УказанДатаИлиЭтоГруппа = ДатаИлиЭтоГруппа <> Неопределено;	
	ТипДатаИлиЭтоГруппа = ТипЗнч(ДатаИлиЭтоГруппа);
	
	Если ВидКласса = ВидыКлассов.Справочный Тогда
		Если УказанДатаИлиЭтоГруппа Тогда
			Если ТипДатаИлиЭтоГруппа <> Тип("Булево") Тогда
				ВызватьИсключение "Неверный тип параметра установки реквизита ЭтоГруппа для " + ИмяМенеджера;
			КонецЕсли;
			Если ДатаИлиЭтоГруппа = Истина И ЕстьИерархия(ПротоОбъект) Тогда
				ПротоОбъект.ЭтоГруппа = Истина;
			КонецЕсли;			
		КонецЕсли;		
		Если ПротоОбъект.Свойство("Наименование") Тогда
			ПротоОбъект.Наименование = ИдентификаторВПредставление(ИмяПеременой);				
		КонецЕсли;
		
	ИначеЕсли ВидКласса = ВидыКлассов.СОсьюВремени Тогда
		Если НЕ УказанДатаИлиЭтоГруппа Тогда
			ВызватьИсключение "Для классов с осью времени обязателен параметр установки даты (" + 
			ИмяМенеджера + """, переменная """ + ИмяПеременой + """)";
		КонецЕсли;		
		Если ТипДатаИлиЭтоГруппа <> Тип("Дата") Тогда
			ВызватьИсключение "Неверный тип параметра установки даты для " + ИмяМенеджера;
		КонецЕсли;

		ПротоОбъект.Дата = ДатаИлиЭтоГруппа;
		Если ПротоОбъект.Свойство("Комментарий") Тогда
			ПротоОбъект.Комментарий = ИдентификаторВПредставление(ИмяПеременой);				
		КонецЕсли;
	Иначе
		ВызватьИсключение "Неподдерживаемый класс при создании ссылки: " + ИмяМенеджера;					
	КонецЕсли;			

	ЗначениеПеременной(ИмяПеременой);	
КонецПроцедуры

// Создает записи регистра сведений для каждой строки преданной таблицы геркина. Каждая запись создается
// как НаборЗаписей, с отбором по преданным измерениям, с установкой свойства "ОбменДанными".
// 
// Параметры:
// 	ИмяРегистра - Строка
// 	Источник - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина
//
&НаКлиенте
Процедура СоздатьЗаписиРегистраСведенийПоТаблицеГеркина(ИмяРегистра, Источник) Экспорт
	ИмяПеременной = НовоеУникальноеИмяПеременной(ИмяРегистра);	
	ОписаниеОбъекта = НовоеОписаниеОбъекта(ИмяПеременной, "РегистрыСведений", ИмяРегистра);	
	ПривестиТаблицуГеркина(Источник, , ОписаниеОбъекта.ЗаписиНабора);
	Значение = ЗначениеБДПоОписанию(ОписаниеОбъекта);
	ЗапомнитьЗначение(ИмяПеременной, Значение);
КонецПроцедуры

// Кэшированный список поддерживаемых классов, сделан экспортным для удобства отладки
// 
// Возвращаемое значение:
// 	Структура - см. КлассыОбъектовКлиентСервер
//
&НаКлиенте
Функция КлассыОбъектовКлиент() Экспорт
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("КлассыОбъектов") Тогда
		Результат = КлассыОбъектовКлиентСервер();		
		КэшКлиент.Вставить("КлассыОбъектов", Результат);		
	КонецЕсли; 
	
	Возврат КэшКлиент.КлассыОбъектов;
		
КонецФункции

// Создание строки (записи) субколлекции объекта - движения, или строки табличной части
// 
// Параметры:
// 	ОписаниеОбъекта - Структура - см. НовоеОписаниеОбъекта
// 	ИмяСК - Строка - имя субколлекции: табличной части, или имя регистра движения 
// 	КлассСК - Строка - класс субколлекции: "ТабличныеЧасти" или "Движения"
// 	
// Возвращаемое значение:
// 	Структура - для вставки значений полей по имена колонок
//
&НаКлиенте
Функция ДобавитьЗапись(ОписаниеОбъекта, ИмяСК, КлассСК = Неопределено) Экспорт
	
	Если КлассСК = Неопределено Тогда
		КлассСК = КлассыРеквизитовКлиент().ТабличныеЧасти;	
	КонецЕсли; 
	
	Субколлекция = ОписаниеОбъекта.ПротоОбъект[КлассСК][ИмяСК];	
	Запись = Новый Структура();	
	Субколлекция.Строки.Добавить(Запись);
	
	Возврат Запись;
	
КонецФункции

// Кэш описаний объектов, сделан экспортным для удобства отладки
// 
// Возвращаемое значение:
// 	Структура - см. НовоеОписаниеОбъекта
//
&НаКлиенте
Функция ОписанияОбъектов() Экспорт
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("ОписанияОбъектов") Тогда
		КэшКлиент.Вставить("ОписанияОбъектов", Новый Структура);		
	КонецЕсли; 
	
	Возврат КэшКлиент.ОписанияОбъектов;
	
КонецФункции

// Структура, описывающая произвольный объект выбранного класса
// 
// Параметры:
// 	ИмяПеременной - Строка - имя переменной, ключ кэша для описания и ссылки на объект
// 	Класс - Строка - класс объекта конфигурации, список поддерживаемых классов
// 	см. в КлассыОбъектовКлиентСервер
// 	Вид - Строка - вид объекта класса
// 	
// Возвращаемое значение:
// 	Структура - Описание:
// *ОписаниеРеквизитов - Структура - см. "ОписаниеРеквизитов"
// *Класс - Строка - переданный класс
// *Вид - Строка - переданный вид
// *ИмяПеременной - Строка - переданное имя переменной
// *ПротоОбъект - Структура - объект для последующего наполнения данными, см. ПротоОбъект
// 
&НаКлиенте
Функция НовоеОписаниеОбъекта(ИмяПеременной, Класс, Вид) Экспорт
	ОписанияОбъектов = ОписанияОбъектов();
	
	ПроверитьИдентификатор(ИмяПеременной, "Некорректное имя переменной %1");
	
	Если ОписанияОбъектов.Свойство(ИмяПеременной) Тогда
		ВызватьИсключение "Переменная """ + ИмяПеременной + """ была описана ранее";		
	КонецЕсли; 	

	ОписаниеРеквизитов = ОписаниеРеквизитов(Класс, Вид);
	
	Результат = НоваяСтруктураОписанияОбъекта();
	Результат.ОписаниеРеквизитов = ОписаниеРеквизитов;
	Результат.Класс = Класс;
	Результат.Вид = Вид;
	Результат.ИмяПеременной = ИмяПеременной;
	Результат.ПротоОбъект = ПротоОбъект(ОписаниеРеквизитов);
	
	ОписанияОбъектов.Вставить(ИмяПеременной, Результат);	
	
	Возврат Результат;	
КонецФункции

#КонецОбласти 

#Область СборСведений

// Метод для облегчения набора кода, предназначен только для использования в отладке.
// 
// Параметры:
// 	ОписаниеОбъекта - Структура - см. НовоеОписаниеОбъекта
// 	ИмяПеременнойвКоде - Строка - имя переменной прототипа объекта в сгенерированном коде. Если не указан,
// 	используется имя переменной из описания объекта
// 	 
// Возвращаемое значение:
// 	Структура
// 	*Запись - Содержит сгенерированный код для заполнения свойств элемента, документа, или 
// 	записи регистра сведений. Код генерируется с учетом свойств использования реквизитов (ДляЭлемента,
// 	ДляГруппыИЭлемента)
// 	*Группа - в зависимости от класса и свойств вида объекта, содержит код сгенерированный с учетом 
// 	свойств использования реквизитов (ДляГруппы, ДляГруппыИЭлемента)
//
&НаКлиенте
Функция КодСоздания(ОписаниеОбъекта, ИмяПеременнойвКоде = Неопределено) Экспорт
	
	Если ИмяПеременнойвКоде = Неопределено Тогда
		ИмяПеременнойвКоде = ОписаниеОбъекта.ИмяПеременной;		
	КонецЕсли; 
	
	Результат = КодСозданияЗаписи(ОписаниеОбъекта, ИмяПеременнойвКоде);
	
	Возврат Результат;
	
КонецФункции 

// Создает таблицу значений по описанию таблицы геркина, помещает в временное хранилище, 
// и возвращает адрес этой таблицы в временном хранилище. Используется например для получения описанного
// в скрипте геркина эталона таблицы, с которым необходимо выполнить сверку по результату теста.
// 
// Параметры:
// 	Источник - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина
// 	КолонкиИсключаемыеИзЗаменыСсылок - Строка
// Возвращаемое значение:
// 	Строка - адрес в временном хранилище
//
&НаКлиенте
Функция АдресТаблицыПоОписаниюГеркина(Источник, КолонкиИсключаемыеИзЗаменыСсылок) Экспорт
	Записи = ПривестиТаблицуГеркина(Источник, КолонкиИсключаемыеИзЗаменыСсылок);
	АдресПараметров = АдресПараметровСозданияТаблицыПоОписаниюГеркина(Записи);
	Возврат ТаблицаПоОписаниюГеркина(АдресПараметров, Истина, УникальныйИдентификатор);	
	
КонецФункции

// Возвращает существующую задачу бизнес процесса по имени точки маршрута
// 
// Параметры:
// 	СсылкаИлиИмяПеременной - БизнесПроцессСсылка, Строка
// 	ИмяТочкиМаршрута - Строка
// Возвращаемое значение:
// 	ЗадачаСсылка
//
&НаКлиенте
Функция ЗадачаБизнесПроцесса(СсылкаИлиИмяПеременной, ИмяТочкиМаршрута) Экспорт
	
	ОписаниеПеременной = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	Возврат ЗадачаБизнесПроцессаНаСервере(ОписаниеПеременной.Ссылка, ИмяТочкиМаршрута);

КонецФункции 

// Перечень объектов определенного вида
// 
// Параметры:
// 	ИмяМенеджера - <Класс>.<Вид>, например "Справочники.Контрагенты"
// 	Отбор - Структура - необязательно описание секции "Где". Может быть задан как:
// 	Имя\Значение
// 		*ключ - Строка - имя переменной запроса
// 		*значение - Произвольный - значение переменой
// 	Выражение - Структура
// 		*Ключ - Строка - произвольное описание, не используется
// 		*Значение - Структура, с ключами:
// 			**Текст - Строка - текст запроса. В тексте запроса можно использовать алиас менеджера "Объект"
// 			**Параметры - Структура Имя\Значение, см. выше
// 	
// Возвращаемое значение:
// 	Массив
// 	
// 	Примеры вызова:
// 	
// 	Все элементы справочника:
// 	СписокКонтрагентов = Инициатор().ОбъектыПоОтбору("Справочники.Контрагенты"); 
//
// 	Все элементы справочника, кроме групп: 	
// 	Отбор = Новый Структура("ЭтоГруппа", Ложь); 
// 	СписокКонтрагентов = Инициатор().ОбъектыПоОтбору("Справочники.Контрагенты", Отбор);
// 	
// 	Проведенные документы за день:
// 	Отбор = Новый Структура("Проведен", Истина);
// 	Выражение = Новый Структура("Текст, Параметры");
// 	Выражение.Текст = "НачалоПериода(Объект.Дата, ДЕНЬ) = &НачалоПериода";
// 	Выражение.Параметры = Новый Структура;
// 	Выражение.Параметры.Вставить("НачалоПериода", НачалоДня(ДатаПериода));
// 	
// 	СписокЗаказов = Инициатор().ОбъектыПоОтбору("Документы.ЗаказКлиента", Отбор);
//
&НаКлиенте
Функция ОбъектыПоОтбору(ИмяМенеджера, Отбор = Неопределено) Экспорт
	Возврат ОбъектыПоОтборуНаСервере(ИмяМенеджера, Отбор);		
КонецФункции
 
#КонецОбласти 

#Область СверкаТаблиц

// Сверка переданной таблицы с движениями указанного документа, см. ПроверитьСубколлекцию
// 
// Параметры:
// 	СсылкаИлиИмяПеременной - ДокументСсылка, Строка
// 	ВидРегистра - Строка - имя регистра движений
// 	ТаблицаЭталон - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина
//
&НаКлиенте
Процедура ПроверитьДвиженияПоРегистру(СсылкаИлиИмяПеременной, ВидРегистра, ТаблицаЭталон) Экспорт
	КлассДвижения = КлассыРеквизитовКлиент().Движения; 	
	ПроверитьСубколлекцию(СсылкаИлиИмяПеременной
		, ВидРегистра
		, КлассДвижения
		, ТаблицаЭталон);
КонецПроцедуры 

// Сверка переданной таблицы с табличной частью указанного объекта, см. ПроверитьСубколлекцию
// 
// Параметры:
// 	СсылкаИлиИмяПеременной - Ссылка, Строка
// 	ИмяТЧ - Строка - имя табличной части
// 	ТаблицаЭталон - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина
//
&НаКлиенте
Процедура ПроверитьТабличнуюЧасть(СсылкаИлиИмяПеременной, ИмяТЧ, ТаблицаЭталон) Экспорт	
	КлассТабЧасти = КлассыРеквизитовКлиент().ТабличныеЧасти; 
	ПроверитьСубколлекцию(СсылкаИлиИмяПеременной
		, ИмяТЧ
		, КлассТабЧасти
		, ТаблицаЭталон);		
КонецПроцедуры 
 
 // Сверка переданной таблицы с реквизитами указанного объекта
// 
// Параметры:
// 	СсылкаИлиИмяПеременной - Ссылка, Строка
// 	ТаблицаРеквизитовЭталон - Массив Из Структура - таблица в описании геркина, см. ПривестиТаблицуГеркина
// 	Здесь ожидается таблица с обязательными колонками "Имя", "Значение". Отсутствие этих колонок приведет
// 	к выбросу исключения.
//
&НаКлиенте
Процедура ПроверитьРеквизитыОбъекта(СсылкаИлиИмяПеременной, ТаблицаРеквизитовЭталон) Экспорт
	ПроверитьКолонкиТаблицыГеркина(ТаблицаРеквизитовЭталон, "Имя,Значение");
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	
	ОписаниеЭталона = ОписаниеОбъектаСсылки(ОписаниеСсылки);	
	СписокРеквизитов = ПривестиТаблицуГеркина(ТаблицаРеквизитовЭталон, "Имя");	
	Для каждого ОписаниеРеквизита Из СписокРеквизитов Цикл
		ОписаниеЭталона.ПротоОбъект.Вставить(ОписаниеРеквизита.Имя, ОписаниеРеквизита.Значение);		
	КонецЦикла; 
		
	РезультатПроверки = РезультатПроверкиРеквизитовНаСервере(ОписаниеСсылки.Ссылка, ОписаниеЭталона);
	ВызватьИсключениеПоРезультатуПроверки(РезультатПроверки);
КонецПроцедуры 

#КонецОбласти 

#Область ОтключениеМодуля

// Делает отключение модуля
&НаКлиенте
Функция ОтключениеМодуля() Экспорт

	Ванесса = Неопределено;
	
КонецФункции	

#КонецОбласти

#КонецОбласти 

#Область СлужебныйПрограммныйИнтерфейс

// Инициализация глобальной переменной "Ванесса"
// 
// Параметры:
// 	ВладелецФормы - ФормаКлиентскогоПриложения - управляемая форма фреймворка "vanessa..."
//
&НаКлиенте
Функция ИнициализацияФормы(ВладелецФормы) Экспорт
	Ванесса = ВладелецФормы;
КонецФункции

#КонецОбласти 

#Область ОбработчикиСобытийФормы

&НаКлиенте
Процедура ОбработкаОповещения(ИмяСобытия, Параметр, Источник)
	Если ИмяСобытия = "ЗапускСценариевVB" Тогда
		КэшКлиент = Новый Структура;	
	КонецЕсли; 	
КонецПроцедуры

#КонецОбласти 

#Область СлужебныеПроцедурыИФункции

#Область Сервис

&НаКлиенте
Функция НовоеУникальноеИмяПеременной(Префикс)
	
	ИдентификаторПоУид = "_" + СтрЗаменить(Новый УникальныйИдентификатор, "-", "_");
	Результат = Префикс + ИдентификаторПоУид;	
	Возврат Результат;
	
КонецФункции 

&НаКлиенте
Функция ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной)
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяПеременной");
	Результат.Вставить("Ссылка");
	
	Если ТипЗнч(СсылкаИлиИмяПеременной) = Тип("Строка") Тогда
		Результат.ИмяПеременной = СсылкаИлиИмяПеременной;
		Результат.Ссылка = ЗначениеПеременной(СсылкаИлиИмяПеременной);		
	Иначе
		Результат.ИмяПеременной = ПеременныеСсылок().Получить(СсылкаИлиИмяПеременной);
		Результат.Ссылка = СсылкаИлиИмяПеременной;
	КонецЕсли; 
	
	Если НЕ ЗначениеЗаполнено(Результат.ИмяПеременной) Тогда
		ВызватьИсключение "Не удалось определить имя переменной " + СсылкаИлиИмяПеременной;		
	КонецЕсли; 
	
	Если НЕ ЗначениеЗаполнено(Результат.Ссылка) Тогда
		ВызватьИсключение "Не удалось ссылку " + СсылкаИлиИмяПеременной;		
	КонецЕсли; 	
	
	Результат.Вставить("УИДСтрокой", "" + Результат.Ссылка.УникальныйИдентификатор());
	
	Возврат Результат;	
КонецФункции 

&НаКлиентеНаСервереБезКонтекста
Функция ЕстьИерархия(Источник)
	Возврат ЕстьРеквизитИлиСвойствоОбъекта(Источник, "ЭтоГруппа");	
КонецФункции 

&НаКлиентеНаСервереБезКонтекста
Функция СкопироватьСтруктуру(Источник)
	
	Результат = Новый Структура;
	Для каждого КлючИЗначение Из Источник Цикл
		Если ТипЗнч(КлючИЗначение.Значение) = Тип("Структура") Тогда
			ЗначениеВрезультат = СкопироватьСтруктуру(КлючИЗначение.Значение);
		Иначе
			ЗначениеВрезультат = КлючИЗначение.Значение;			
		КонецЕсли; 
		Результат.Вставить(КлючИЗначение.Ключ, ЗначениеВрезультат);		
	КонецЦикла; 
	Возврат Результат;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СвойствоСтруктуры(Источник, Ключ, ЗначениеПоУмолчанию = Неопределено)
	
	Результат = Неопределено;
	ЕстьСвойство = Ложь;
	Если ТипЗнч(Источник) = Тип("Структура") Тогда
		ЕстьСвойство = Источник.Свойство(Ключ, Результат);		
	КонецЕсли; 
	
	Если НЕ ЕстьСвойство Тогда
		Результат = ЗначениеПоУмолчанию;
		
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции
 
// Проверяет наличие реквизита или свойства у произвольного объекта без обращения к метаданным.
//
// Параметры:
//  Объект       - Произвольный - объект, у которого нужно проверить наличие реквизита или свойства;
//  ИмяРеквизита - Строка       - имя реквизита или свойства.
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
//
&НаКлиентеНаСервереБезКонтекста
Функция ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита)
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

// Преобразование переданного идентификатора в представление
//
// Параметры:
//  Идентификатор - Строка - образованная по правилам формирования идентификаторов 1С
//
// Возвращаемое значение: 
//  Строка - преобразованный идентификатор. 
//   - Первая буква всегда заглавная
//   - Первое подчеркивание пропускается
//   - Прочие заглавные буквы преобразуются в нижний регистр, после вставляется пробел
//   - Между цифрой и буквой вставляется пробел, между подряд идущими цифрами пробелов нет
//   - Несколько сплошных подчеркиваний воспринимаются как один, превращаются в пробел
//   - В строке может присутствовать символ, отличный от допустимых в идентификаторе - не обрабатывается
//   - Учитывается капитель (аббревиатуры) и спецсимволы в капители
//
//    Примеры:
//   "ЭтоДата23_05_06" -> "Это дата 23 05 06"
//   "Это____ПримерС_Подчеркиваниями" -> "Это пример с подчеркиваниями"
//   "это_ПримерС_ПервойНеЗаглавной" -> "Это пример с первой не заглавной"
//   "Это_ПримерС_НевернымИден???тификатором*" -> "Это пример с неверным иден???тификатором*"
//   "_Это_ПримерС_первымПодчеркиванием" -> "Это пример с первым подчеркиванием"
//   "Это_КАПИ_ТЕЛЬ" -> "Это КАПИТЕЛЬ"
//   "Это_КАПИ99ТЕЛЬ" -> "Это КАПИ 99 ТЕЛЬ"
//   "Это_КАПИ??ТЕЛЬ" -> "Это КАПИ??ТЕЛЬ"
// 
// BSLLS:CyclomaticComplexity-выкл
// BSLLS:CognitiveComplexity-выкл
//
&НаКлиентеНаСервереБезКонтекста
Функция ИдентификаторВПредставление(Идентификатор)
	Цифры = "0123456789";
	Алфавит = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
	ИдентификаторКОбработке = СокрЛП(Идентификатор);
	Пока Найти(ИдентификаторКОбработке, "__") Цикл
	    ИдентификаторКОбработке = СтрЗаменить(ИдентификаторКОбработке, "__", "_");        
	КонецЦикла; 
	Пока Лев(ИдентификаторКОбработке, 1) = "_" Цикл
	    ИдентификаторКОбработке = Сред(ИдентификаторКОбработке, 2);
	КонецЦикла;     
	
	ПредыдущийЗнакЭтоПробел = Ложь;
	ПредыдущийЗнакЭтоЦифра = Ложь;
	ПредыдущийЗнакЭтоЗаглавная = Ложь;
	ПредыдущийЗнакЭтоСпецСимвол = Ложь;
	Слово = "";
	Для сч = 1 По СтрДлина(ИдентификаторКОбработке) Цикл
		ДобавитьПробел = Ложь;
		
		Сим = Сред(ИдентификаторКОбработке, сч, 1);        
		ВрегСим = Врег(Сим);
		НрегСим = Нрег(Сим);
		СимВСлово = Сим;
		        
		ЭтоНижнийСлэш = сим = "_";    
		ЭтоЦифра = Найти(Цифры, Сим) > 0;
		ЭтоБуква = Найти(Алфавит, ВрегСим) > 0;
		ЭтоПрочийЗнак = НЕ (ЭтоНижнийСлэш ИЛИ ЭтоЦифра);
		ЭтоЗаглавная = (Сим = ВрегСим) И (Сим <> НрегСим);
		
		Если сч = 1 Тогда            
		    СимВСлово = ВрегСим;
		    
		ИначеЕсли ЭтоЦифра И НЕ ПредыдущийЗнакЭтоЦифра Тогда
		    ДобавитьПробел = Истина;
		    
		ИначеЕсли ЭтоНижнийСлэш Тогда
			ДобавитьПробел = Истина;
			СимВСлово = "";
					    
		Иначе
			ЭтоПрочаяТекущаяЗаглавная = ЭтоПрочийЗнак И ЭтоЗаглавная 
				И НЕ ПредыдущийЗнакЭтоЗаглавная И НЕ ПредыдущийЗнакЭтоСпецСимвол;			
			Если ЭтоПрочаяТекущаяЗаглавная Тогда      	
			   ДобавитьПробел = Истина;                
			   СимВСлово = НрегСим;
			КонецЕсли;
		КонецЕсли;            
  
		ЭтоВторойСимволКапители = ЭтоЗаглавная И ПредыдущийЗнакЭтоЗаглавная;
		Если ЭтоВторойСимволКапители Тогда            
		    ПоследнийСимвол = Прав(Слово, 1);
		    Слово = Сред(Слово, 1, СтрДлина(Слово) - 1) + ВРЕГ(ПоследнийСимвол);            
		КонецЕсли; 
		
		ДобавитьПробел = ДобавитьПробел И НЕ ПредыдущийЗнакЭтоПробел;
		Если ДобавитьПробел Тогда
		    СимВСлово = " " + СимВСлово;            
		КонецЕсли; 
		
		Слово = Слово + СимВСлово;        
		
		ПредыдущийЗнакЭтоПробел = СимВСлово = " ";
		ПредыдущийЗнакЭтоЦифра = ЭтоЦифра;
		ПредыдущийЗнакЭтоЗаглавная = ЭтоЗаглавная;
		ПредыдущийЗнакЭтоСпецСимвол = НЕ (ЭтоБуква ИЛИ ЭтоНижнийСлэш ИЛИ ЭтоЦифра);
	КонецЦикла;    
	Возврат Слово;
    
КонецФункции 

&НаКлиентеНаСервереБезКонтекста
Процедура УдалитьЗначениеИзМассива(Массив, Значение)
	инд = Массив.Найти(Значение);
	Если Инд <> Неопределено Тогда
		Массив.Удалить(инд);
	КонецЕсли; 	
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция ЗначениеВМассиве(Значение)
	
	Результат = Новый Массив;
	Результат.Добавить(Значение);
	
	Возврат Результат;
	
КонецФункции 

&НаКлиентеНаСервереБезКонтекста
Процедура ПроверитьИдентификатор(ид, ШаблонССообщения = Неопределено)
	
	Если СтрокаМожетБытьИменемПеременной(ид) Тогда
		Возврат;
	КонецЕсли;
	
	Если ШаблонССообщения = Неопределено Тогда
		ШаблонССообщения = "Некорректный идентификатор %1";			
	КонецЕсли; 
	
	ИдВКавычках = Обрамить(ид);
	ТекстИсключения = ПодставитьПараметрыВСтроку(ШаблонССообщения, ИдВКавычках);			
	
	ВызватьИсключение ТекстИсключения;
		
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция СтрокаМожетБытьИменемПеременной(Строка)
	
	Результат = Истина;
	
	Попытка
		//@skip-warning
		Проверка = Новый Структура;
		Проверка.Вставить(Строка, Неопределено);
	Исключение
		Результат = Ложь;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Процедура ВызватьИсключениеПоРезультатуПроверки(РезультатПроверки)
	Если РезультатПроверки.Ошибка Тогда
		ВызватьИсключение РезультатПроверки.Описание;		
	КонецЕсли; 	
КонецПроцедуры

&НаСервере
Функция КэшСервер()
	
	Если КэшСервер = Неопределено Тогда
		КэшСервер = Новый Структура;
		
	КонецЕсли; 
	
	Возврат КэшСервер;
	
КонецФункции

&НаКлиенте
Функция КэшКлиент()	
	Если КэшКлиент = Неопределено Тогда
		КэшКлиент = Новый Структура;
	КонецЕсли; 	
	Возврат КэшКлиент;	
КонецФункции
 
&НаКлиенте
Процедура ПроверитьСубколлекцию(СсылкаИлиИмяПеременной, ИмяСК, ВидСК, ТаблицаЭталон)
	ОписаниеСсылки = ОписаниеСсылкиПеременной(СсылкаИлиИмяПеременной);
	ОписаниеОбъекта = ОписаниеОбъектаСсылки(ОписаниеСсылки);	
	Приемник = ОписаниеОбъекта.ПротоОбъект[ВидСК][ИмяСК].Строки;
	ПривестиТаблицуГеркина(ТаблицаЭталон, , Приемник);	

	РезультатПроверки = РезультатПроверкиСубколлекции(ОписаниеСсылки.Ссылка
		, ИмяСК
		, ВидСК
		, ОписаниеОбъекта);
		
	ВызватьИсключениеПоРезультатуПроверки(РезультатПроверки);	
КонецПроцедуры

&НаКлиенте
Функция ВидКласса(Класс)
	
	Классы = КлассыОбъектовКлиент();
	ВидыКлассов = ВидыКлассов();
	
	ЭтоСправочныйКласс = Класс = Классы.ПланыОбмена
		ИЛИ Класс = Классы.Справочники 
		ИЛИ Класс = Классы.ПланыВидовХарактеристик
		ИЛИ Класс = Классы.ПланыСчетов;
		
	ЭтоКлассСОсьюВремени = Класс = Классы.Документы
		ИЛИ Класс = Классы.БизнесПроцессы
		ИЛИ Класс = Классы.Задачи;	

	ЭтоРегистровый = Класс = Классы.РегистрыСведений;

	Если ЭтоСправочныйКласс Тогда
		Результат = ВидыКлассов.Справочный; 
	ИначеЕсли ЭтоКлассСОсьюВремени Тогда 	
		Результат = ВидыКлассов.СОсьюВремени;
	ИначеЕсли ЭтоРегистровый Тогда 	
		Результат = ВидыКлассов.Регистровый;
	Иначе
		ВызватьИсключение "Неподдерживаемый класс " + Класс;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция VAЗначениеКонстанты(ИмяКонстанты, ИзвлекатьИзХранилища, КакАдресВХ)
	
	ЗначениеКонстанты = Константы[ИмяКонстанты].Получить();
	Если ИзвлекатьИзХранилища И ТипЗнч(ЗначениеКонстанты) = Тип("ХранилищеЗначения") Тогда
		ЗначениеКонстанты = ЗначениеКонстанты.Получить();				
	КонецЕсли; 
	
	Если КакАдресВХ Тогда
		Результат = ПоместитьВоВременноеХранилище(ЗначениеКонстанты, УникальныйИдентификатор);
	Иначе
		Результат = ЗначениеКонстанты;
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции 

&НаКлиенте
Функция СостояниеВанессы()
	Результат = Ванесса.ПолучитьСостояниеVanessaBehavior();	
	Возврат Результат;
КонецФункции 

&НаКлиенте
Функция ИмяТекущегоСценария()
	СостояниеВанессы = СостояниеВанессы();  
	Результат = СостояниеВанессы.ТекущаяФича.ПолныйПуть + ": " + СостояниеВанессы.ТекущийСценарий.Имя; 	
	Возврат Результат;
КонецФункции

&НаСервере
Процедура ДобавитьСообщенияПользователюВРезультатМетода(РезультатМетода)
	СписокСообщений = ПолучитьСообщенияПользователю(Истина);
	Если ЗначениеЗаполнено(СписокСообщений) Тогда
		Для каждого СообщениеПроверки Из СписокСообщений Цикл
			РезультатМетода.Описание = РезультатМетода.Описание +
			Символы.ПС + Символы.Таб + "- " + СообщениеПроверки.Текст;
		КонецЦикла;	
	Иначе
		РезультатМетода.Описание = РезультатМетода.Описание + "нет сообщений.";	
	КонецЕсли; 		
КонецПроцедуры

// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров начинается с единицы.
//
// Параметры:
//  ШаблонСтроки  - Строка - шаблон строки с параметрами (вхождениями вида "%<номер параметра>", 
//                           например "%1 пошел в %2");
//  Параметр<n>   - Строка - значение подставляемого параметра.
//
// Возвращаемое значение:
//  Строка   - текстовая строка с подставленными параметрами.
//
// Пример:
//  СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк") = "Вася пошел
//  в Зоопарк".
//
&НаКлиентеНаСервереБезКонтекста
Функция ПодставитьПараметрыВСтроку(Знач Стр, Парам1 = Неопределено,
                                             Парам2 = Неопределено,
                                             Парам3 = Неопределено,
                                             Парам4 = Неопределено,
                                             Парам5 = Неопределено,
                                             Парам6 = Неопределено,
                                             Парам7 = Неопределено) Экспорт
											 
											 
	Если Парам1 <> Неопределено Тогда
		Стр = СтрЗаменить(Стр,"%1",Парам1);
	КонецЕсли;	 											 
	Если Парам2 <> Неопределено Тогда
		Стр = СтрЗаменить(Стр,"%2",Парам2);
	КонецЕсли;	 											 
	Если Парам3 <> Неопределено Тогда
		Стр = СтрЗаменить(Стр,"%3",Парам3);
	КонецЕсли;	 											 
	Если Парам4 <> Неопределено Тогда
		Стр = СтрЗаменить(Стр,"%4",Парам4);
	КонецЕсли;	 											 
	Если Парам5 <> Неопределено Тогда
		Стр = СтрЗаменить(Стр,"%5",Парам5);
	КонецЕсли;	 											 
	Если Парам6 <> Неопределено Тогда
		Стр = СтрЗаменить(Стр,"%6",Парам6);
	КонецЕсли;	 											 
	Если Парам7 <> Неопределено Тогда
		Стр = СтрЗаменить(Стр,"%7",Парам7);
	КонецЕсли;	 											 
	
	Возврат Стр;
КонецФункции

// Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
// В случаях, когда разделителем является строка из одного символа, и не используется параметр СокращатьНепечатаемыеСимволы,
// рекомендуется использовать функцию платформы РазложитьСтрокуВМассивПодстрок.
//
// Параметры:
//  Значение               - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат.
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//  СокращатьНепечатаемыеСимволы - Булево - сокращать непечатаемые символы по краям каждой из найденных подстрок.
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",")
//  - возвратит массив из 5 элементов, три из которых  - пустые: "", "один", "", "два", "";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина)
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(" один   два  ", " ")
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("")
//  - возвратит пустой массив;
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("",,Ложь)
//  - возвратит массив с одним элементом: ""(пустая строка);
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("", " ")
//  - возвратит массив с одним элементом: "" (пустая строка).
//
&НаКлиенте
Функция РазложитьСтрокуВМассивПодстрок(Знач Значение, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено)
	Возврат Ванесса.РазложитьСтрокуВМассивПодстрокКлиент(Значение, Разделитель, ПропускатьПустыеСтроки);
	
КонецФункции 

#КонецОбласти 

#Область ПрограммныеПеречисления

&НаКлиенте
Функция ВидыКлассов()
	
	Результат = Новый Структура();
	Результат.Вставить("Справочный", "Справочный");
	Результат.Вставить("СОсьюВремени", "СОсьюВремени");
	Результат.Вставить("Регистровый", "Регистровый");
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПеременныеСсылок()
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("ПеременныеСсылок") Тогда
		КэшКлиент.Вставить("ПеременныеСсылок", Новый Соответствие);		
	КонецЕсли; 
	
	Возврат КэшКлиент.ПеременныеСсылок;
	
КонецФункции 

// Клиентский кэш переменных, в виде соответствия. Предназначен для последующего получения значения
// переменной по имени - используется только для метода "ТаблицаПоОписаниюГеркина", для установки ссылок
// по значению переданных ключей. 
// 
// Возвращаемое значение:
// 	Соответствие
//
&НаКлиенте
Функция СоответствиеЗначенийПеременных() 
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("СоответствиеЗначенийПеременных") Тогда
		КэшКлиент.Вставить("СоответствиеЗначенийПеременных", Новый Соответствие);	
	КонецЕсли; 
	
	Возврат КэшКлиент.СоответствиеЗначенийПеременных;
	
КонецФункции

//	Поддерживаемые классы объектов конфигурации
// 
// Возвращаемое значение:
// 	Структура
//
&НаКлиентеНаСервереБезКонтекста
Функция КлассыОбъектовКлиентСервер()
	Результат = Новый Структура;
	Результат.Вставить("ПланыОбмена", "ПланыОбмена");
	Результат.Вставить("Справочники", "Справочники");
	Результат.Вставить("Документы", "Документы");
	Результат.Вставить("ПланыВидовХарактеристик", "ПланыВидовХарактеристик");
	Результат.Вставить("ПланыСчетов", "ПланыСчетов");
	Результат.Вставить("РегистрыСведений", "РегистрыСведений");
	Результат.Вставить("БизнесПроцессы", "БизнесПроцессы");
	Результат.Вставить("Задачи", "Задачи");
	
	Возврат Результат;
КонецФункции 

//	Поддерживаемые классы реквизитов объектов конфигурации
// 
// Возвращаемое значение:
// 	Структура
//
&НаКлиентеНаСервереБезКонтекста
Функция КлассыРеквизитовКлиентСервер()
	
	КлассыРеквизитов = Новый Массив;
	КлассыРеквизитов.Добавить("СтандартныеРеквизиты");
	КлассыРеквизитов.Добавить("Реквизиты");
	КлассыРеквизитов.Добавить("ТабличныеЧасти");
	КлассыРеквизитов.Добавить("Измерения");
	КлассыРеквизитов.Добавить("Ресурсы");
	КлассыРеквизитов.Добавить("Движения");	
	
	Результат = Новый Структура;
	Для каждого ИмяКласса Из КлассыРеквизитов Цикл
		Результат.Вставить(ИмяКласса, ИмяКласса);		
	КонецЦикла; 
	Результат.Вставить("Список", КлассыРеквизитов);
	
	Возврат Результат;
	
КонецФункции 

&НаКлиенте
Функция КлассыРеквизитовКлиент()
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("КлассыРеквизитов") Тогда
		КэшКлиент.Вставить("КлассыРеквизитов", КлассыРеквизитовКлиентСервер());
		
	КонецЕсли;
	
	Возврат КэшКлиент.КлассыРеквизитов;
	
КонецФункции

&НаСервере
Функция КлассыРеквизитовСервер()
	
	Кэш = КэшСервер();
	Если НЕ Кэш.Свойство("КлассыРеквизитов") Тогда
		Кэш.Вставить("КлассыРеквизитов", КлассыРеквизитовКлиентСервер());
		
	КонецЕсли;
	
	Возврат Кэш.КлассыРеквизитов;
	
КонецФункции

&НаСервере
Функция ВидыЗаполнения()
	Результат = Новый Структура;
	Результат.Вставить("Запись", "Запись");
	Результат.Вставить("Группа", "Группа");
	
	Возврат Результат;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ИспользованиеРеквизитов()
	
	Результат = Новый Структура;
	Результат.Вставить("ДляГруппы", "ДляГруппы");
	Результат.Вставить("ДляЭлемента", "ДляЭлемента");
	Результат.Вставить("ДляГруппыИЭлемента", "ДляГруппыИЭлемента");
	
	Возврат Результат;
КонецФункции 

#КонецОбласти 

#Область ВызовСервера

&НаСервере
Функция РезультатЗаписиДокументаНаСервере(Знач Ссылка, Знач Режим, Знач ВызыватьИсключение)
	
	Результат = НовыйРезультатМетода();
	ВсеСообщения = ПолучитьСообщенияПользователю(Истина);
	
	Попытка
		ДокОбъект = Ссылка.ПолучитьОбъект();
		ДокОбъект.Записать(Режим);
		
		Результат.Ошибка = Ложь;
	Исключение
		Инфо = ИнформацияОбОшибке();
		
		Результат.Описание = "Не удалось провести документ, текст исключения: " + 
		Символы.ПС + Символы.Таб + "- " + Инфо.Описание + 
		Символы.ПС + "Сообщения при проведении:";
		ДобавитьСообщенияПользователюВРезультатМетода(Результат);
		
		Если ВызыватьИсключение Тогда
			ВызватьИсключение Результат.Описание;			
		КонецЕсли; 		
	КонецПопытки;
	
	Для каждого Сообщение Из ВсеСообщения Цикл
		Сообщение.Сообщить();		
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Процедура ДействияПередПроверкой(ОписаниеОбъекта)
	ПривестиЗначенияРеквизитов(ОписаниеОбъекта);	
КонецПроцедуры
 
&НаСервере
Функция РезультатПроверкиСубколлекции(Знач Ссылка, Знач ИмяСК, Знач КлассСК, Знач ОписаниеЭталона)
	
	ДействияПередПроверкой(ОписаниеЭталона);
	
	РезультатПроверки = НовыйРезультатМетода();	
	ОбъектПроверки = Ссылка.ПолучитьОбъект();
	
	КлассыРеквизитов = КлассыРеквизитовСервер();
	
	Если КлассСК = КлассыРеквизитов.ТабличныеЧасти Тогда
		ТаблицаПроверки = ОбъектПроверки[ИмяСК].Выгрузить();
	Иначе
		Набор = ОбъектПроверки.Движения[ИмяСК];
		Набор.Прочитать();
		ТаблицаПроверки = Набор.Выгрузить();		
	КонецЕсли; 
	
	ОписаниеСК = ОписаниеЭталона.ПротоОбъект[КлассСК][ИмяСК];	
	ТаблицаЭталон = ОписаниеСК.Строки;	

	КолСтрок1 = ТаблицаПроверки.Количество();
	КолСтрок2 = ТаблицаЭталон.Количество(); 

	Если КолСтрок1 = КолСтрок2 Тогда			
		КолонкиЭталона = ОписаниеСК.Колонки;
		Описание = "";
		Для НомСтр = 1 По ТаблицаЭталон.Количество() Цикл
			инд = НомСтр - 1;
			СтрокаЭталон = ТаблицаЭталон[инд];
			СтрокаПроверки = ТаблицаПроверки[инд];
			
			Для каждого ОписаниеКолонки Из КолонкиЭталона Цикл
				ИмяКолонки = ОписаниеКолонки.Ключ;
				Если НЕ СтрокаЭталон.Свойство(ИмяКолонки) Тогда
					Продолжить;
				КонецЕсли; 
				
				ЗначениеЭталон = СтрокаЭталон[ИмяКолонки];
				ЗначениеПроверки = СтрокаПроверки[ИмяКолонки];
				Если ЗначениеЭталон <> ЗначениеПроверки Тогда
					ОписаниеПоСтроке = "В стр. № " + НомСтр + ": ошибка проверки поля " + ИмяКолонки + " (" + 
					ЗначениеЭталон + " <> " + ЗначениеПроверки + ")";
					Разделитель = ?(ЗначениеЗаполнено(Описание), Символы.ПС, "");
					Описание = Описание + Разделитель + ОписаниеПоСтроке;			
				КонецЕсли; 		
			КонецЦикла; 			
		КонецЦикла; 
		РезультатПроверки.Описание = Описание;
	Иначе
		РезультатПроверки.Описание = ПодставитьПараметрыВСтроку("Количество строк набора %1 не равно эталону (%2 <> %3)"
		, ИмяСК
		, КолСтрок1
		, КолСтрок2);		
	КонецЕсли;
	
	РезультатПроверки.Ошибка = ЗначениеЗаполнено(РезультатПроверки.Описание);
	Возврат РезультатПроверки;
	
КонецФункции 

&НаСервере
Функция РезультатПроверкиРеквизитовНаСервере(Знач СсылкаПроверки, Знач ОписаниеЭталона)
	РезультатПроверки = НовыйРезультатМетода();	
	ОбъектПроверки = СсылкаПроверки.ПолучитьОбъект();

	ДействияПередПроверкой(ОписаниеЭталона);
	
	КлассыРеквизитов = КлассыРеквизитовСервер();
	
	Для каждого КлючИЗначение Из ОписаниеЭталона.ПротоОбъект Цикл
		ИмяРеквизита = КлючИЗначение.Ключ;
		ЭтоСубколлекция = ИмяРеквизита = КлассыРеквизитов.ТабличныеЧасти
			ИЛИ ИмяРеквизита = КлассыРеквизитов.Движения;
			
		Если ЭтоСубколлекция Тогда
			Продолжить;			
		КонецЕсли;
		Если ИмяРеквизита = "ОбменДанными" Тогда
			Продолжить;			
		КонецЕсли; 
			
		Описание = "";
		ЗначениеКПроверке = ОбъектПроверки[ИмяРеквизита];
		ЗначениеПоЭталону = КлючИЗначение.Значение;
		
		Если ЗначениеКПроверке <> ЗначениеПоЭталону Тогда
			Описание = ПодставитьПараметрыВСтроку("Реквизит %1 не равен эталону: %2 <> %3"
			, ИмяРеквизита
			, ЗначениеКПроверке
			, ЗначениеПоЭталону);				
		КонецЕсли; 
		Если НЕ ЗначениеЗаполнено(Описание) Тогда
			Продолжить;			
		КонецЕсли; 
		
		Разделитель = ?(ЗначениеЗаполнено(РезультатПроверки.Описание), Символы.ПС, "");
		РезультатПроверки.Описание = РезультатПроверки.Описание + Разделитель + Описание;				
	КонецЦикла; 
	РезультатПроверки.Ошибка = ЗначениеЗаполнено(РезультатПроверки.Описание);

	Возврат РезультатПроверки;
	
КонецФункции

&НаСервере
Функция ЗадачаБизнесПроцессаНаСервере(Знач БПСсылка, Знач ИмяТочкиМаршрута)
	
	МетаБП = БПСсылка.Метаданные();
	
	ИмяЗадачи = МетаБП.Задача.Имя;
	ИмяПредТМ = ПодставитьПараметрыВСтроку("БизнесПроцесс.%1.ТочкаМаршрута.%2", МетаБП.Имя, ИмяТочкиМаршрута);
	ТочкаМаршрута = ПредопределенноеЗначение(ИмяПредТМ);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Задача.Ссылка КАК Ссылка
		|ИЗ
		|	Задача." + ИмяЗадачи + " КАК Задача
		|ГДЕ
		|	Задача.БизнесПроцесс = &БизнесПроцесс
		|	И Задача.ТочкаМаршрута = &ТочкаМаршрута";
	
	Запрос.УстановитьПараметр("БизнесПроцесс", БПСсылка);
	Запрос.УстановитьПараметр("ТочкаМаршрута", ТочкаМаршрута);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Результат = Задачи[ИмяЗадачи].ПустаяСсылка();
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Результат = Выборка.Ссылка;
	КонецЕсли; 
	
	Возврат Результат;	
КонецФункции

&НаСервере
Процедура УстановитьКонстантуНаСервере(Знач ИмяКонстанты, Знач ЗначениеКонстанты, 
	ПомешатьВХранилище, УстанавливатьПараметрСеанса)

	УстановитьПривилегированныйРежим(Истина);
	
	ЗначениеКУстановке = ЗначениеКонстанты;
	Если ЭтоАдресВременногоХранилища(ЗначениеКУстановке) Тогда
		ЗначениеКУстановке = ПолучитьИзВременногоХранилища(ЗначениеКУстановке);
	КонецЕсли; 
	
	Если ПомешатьВХранилище Тогда
		ЗначениеКУстановке = Новый ХранилищеЗначения(ЗначениеКУстановке);
	КонецЕсли; 
	
	Константы[ИмяКонстанты].Установить(ЗначениеКУстановке);	
	
	Если УстанавливатьПараметрСеанса Тогда
		ПараметрыСеанса[ИмяКонстанты] = ЗначениеКУстановке;		
	КонецЕсли; 
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры 

&НаСервере
Функция ПроверкаЗаполненияПройденаНаСервере(Знач ОписаниеСсылки)
	Результат = НовыйРезультатМетода();
	
	ОбъектПриемника = ОписаниеСсылки.Ссылка.ПолучитьОбъект();	
	ВсеСообщения = ПолучитьСообщенияПользователю(Истина);
	Результат.Ошибка = НЕ ОбъектПриемника.ПроверитьЗаполнение();
	Если Результат.Ошибка Тогда
		Результат.Описание = "Сообщения при проверке заполнения: ";		
	    ДобавитьСообщенияПользователюВРезультатМетода(Результат);
	КонецЕсли; 
	
	Для каждого ПредСообщение Из ВсеСообщения Цикл
		ПредСообщение.Сообщить();		
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции
 
&НаСервере
Процедура СтартоватьПроцессНаСервере(Знач БПСсылка)
	БПОбъект = БПСсылка.ПолучитьОбъект();
	БПОбъект.Старт();	
КонецПроцедуры

&НаСервере
Процедура ВыполнитьЗадачуПроцессаНаСервере(Знач ЗадачаСсылка)

	ЗадачаОбъект = ЗадачаСсылка.ПолучитьОбъект();
	ЗадачаОбъект.ВыполнитьЗадачу();
		
КонецПроцедуры 

&НаСервере
Функция ПолучитьСсылкуВидаНаСервере(Знач Класс, Знач Вид)
	ОписаниеОбъекта = Новый Структура;
	ОписаниеОбъекта.Вставить("Класс", Класс);
	ОписаниеОбъекта.Вставить("Вид", Вид);
	
	Возврат МенеджерКласса(ОписаниеОбъекта).ПолучитьСсылку();
	
КонецФункции
 
&НаСервере
Функция ПараметрСеансаНаСервере(Знач Имя)
	УстановитьПривилегированныйРежим(Истина);
	Возврат ПараметрыСеанса[Имя];	
КонецФункции

#КонецОбласти 

#Область ОбъектыПоОтбору

&НаСервере
Функция ОбъектыПоОтборуНаСервере(Знач ИмяМенеджера, Знач Отбор = Неопределено)
	Запрос = Новый Запрос;

	МетаОбъект = Вычислить("Метаданные." + ИмяМенеджера);
	ПолноеИмя = МетаОбъект.ПолноеИмя();

	ШаблонЗапроса = "ВЫБРАТЬ
		|	Объект.Ссылка КАК Ссылка
		|ИЗ
		|	%1 КАК Объект
		|ГДЕ
		|	Истина";
	
	ТекстЗапроса = ПодставитьПараметрыВСтроку(ШаблонЗапроса, ПолноеИмя);
	УстановитьОтборыВЗапрос(Запрос, ТекстЗапроса, МетаОбъект, Отбор);
	
	Запрос.Текст = ТекстЗапроса;
	РезультатЗапроса = Запрос.Выполнить();	
	Результат = РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("Ссылка");
	
	Возврат Результат;
КонецФункции

&НаСервере
Процедура УстановитьОтборыВЗапрос(Запрос, ТекстЗапроса, МетаОбъект, Отбор)
	
	Если НЕ ЗначениеЗаполнено(Отбор) Тогда
		Возврат;
	КонецЕсли;
	
	ТекстСекцииГде = "";
	Для каждого КИЗ_Отбор Из Отбор Цикл
		ИмяПараметра = КИЗ_Отбор.Ключ;
		ЗначениеПараметра = КИЗ_Отбор.Значение;
		
		ТекстСекцииГде = ТекстСекцииГде + Символы.ПС + "И ";		
		ЭтоВыражение = ТипЗнч(ЗначениеПараметра) = Тип("Структура");
		
		Если ЭтоВыражение Тогда
			ТекстСекцииГде = ТекстСекцииГде + ЗначениеПараметра.Текст;
			Для каждого КиЗ_Параметры Из ЗначениеПараметра.Параметры Цикл
				Запрос.УстановитьПараметр(КиЗ_Параметры.Ключ, КиЗ_Параметры.Значение);
			КонецЦикла; 				
		Иначе			
			УстановитьОтборВЗапрос(Запрос, ТекстСекцииГде, МетаОбъект, ИмяПараметра, ЗначениеПараметра);
		КонецЕсли; 
		
	КонецЦикла; 

	ТекстЗапроса = ТекстЗапроса + Символы.ПС + ТекстСекцииГде;
	
КонецПроцедуры

&НаСервере
Процедура УстановитьОтборВЗапрос(Запрос, ТекстСекцииГде, МетаОбъект, ИмяПараметра, ЗначениеПараметра)
		
	ЭтоСтрокаНеограниченнойДлины = Ложь;	
	Если ТипЗнч(ЗначениеПараметра) = Тип("Строка") Тогда
		МетаРеквизит = МетаОбъект.Реквизиты.Найти(ИмяПараметра);
		Если МетаРеквизит <> Неопределено Тогда
			ДлинаСтрокиТипа = МетаРеквизит.Тип.КвалификаторыСтроки.Длина;
			ЭтоСтрокаНеограниченнойДлины = ДлинаСтрокиТипа  = 0;
			ДлинаСтрокиЗначения = СтрДлина(ЗначениеПараметра);
			
			Если НЕ ЭтоСтрокаНеограниченнойДлины Тогда				
				Если ДлинаСтрокиЗначения > ДлинаСтрокиТипа Тогда
					ПолноеИмя = МетаРеквизит.ПолноеИмя(); 
					ТекстИсключения = ПодставитьПараметрыВСтроку("Попытка установить отбор по строке " +
					"длинной %1, при длине строки в типе реквизита %2 равной %3"
					, ДлинаСтрокиЗначения
					, ПолноеИмя
					, ДлинаСтрокиТипа);
					ВызватьИсключение ТекстИсключения;
				КонецЕсли; 				
			КонецЕсли; 			
			
		КонецЕсли; 				
	КонецЕсли; 
	
	Если ЭтоСтрокаНеограниченнойДлины Тогда
		ДлинаСтрокиЗначенияФормат = Формат(ДлинаСтрокиЗначения, "ЧГ="); 
		ТекстУсловия = ПодставитьПараметрыВСтроку("ВЫРАЗИТЬ(Объект.%1 КАК Строка(%2)) = &%1"
			, ИмяПараметра
			, ДлинаСтрокиЗначенияФормат);		
	Иначе
		ТекстУсловия = ИмяПараметра + " = &" + ИмяПараметра;	
	КонецЕсли; 
	
	ТекстСекцииГде = ТекстСекцииГде + ТекстУсловия;
	Запрос.УстановитьПараметр(ИмяПараметра, ЗначениеПараметра);

КонецПроцедуры

#КонецОбласти 

#Область ОткатИзменений

&НаКлиенте
Процедура ОчиститьПеременные(ИменаПеременных, КэшКонстант = Неопределено)
	
	СписокСсылок = Новый Массив;
	ЗаполненыИменаПеременных = ЗначениеЗаполнено(ИменаПеременных);
	Если ЗаполненыИменаПеременных Тогда
		Для каждого ИмяПеременной Из ИменаПеременных Цикл
			ЗначениеПеременной = ЗначениеПеременной(ИмяПеременной);
			Если ЭтоПростойТип(ТипЗнч(ЗначениеПеременной)) Тогда
				Продолжить;			
			КонецЕсли; 		
			СписокСсылок.Добавить(ЗначениеПеременной);		
		КонецЦикла;		
	КонецЕсли; 
	
	ЗаполненКэшКонстант = ЗначениеЗаполнено(КэшКонстант);
	ЗаполненСписокСсылок = ЗначениеЗаполнено(СписокСсылок);
	ОткатыватьИзменения = ЗаполненКэшКонстант ИЛИ ЗаполненСписокСсылок;
	Если ОткатыватьИзменения Тогда
		ПараметрыОткатаИзменений = Новый Структура;
		ПараметрыОткатаИзменений.Вставить("Ссылки", СписокСсылок);
		ПараметрыОткатаИзменений.Вставить("КэшКонстант", КэшКонстант);
			
		АдресПараметров = ПоместитьВоВременноеХранилище(ПараметрыОткатаИзменений, УникальныйИдентификатор);	
		ОткатитьИзмененияБазыНаСервере(АдресПараметров);
	КонецЕсли; 
	
	Если ЗаполненКэшКонстант Тогда
		ИменаКонстант = Новый Массив;
		Для каждого КлючИЗначение Из КэшКонстант Цикл
			ИменаКонстант.Добавить(КлючИЗначение.Ключ);		
		КонецЦикла; 
		
		Для каждого ИмяКонстанты Из ИменаКонстант Цикл
			КэшКонстант().Удалить(ИмяКонстанты);		
		КонецЦикла; 		
	КонецЕсли; 
	
	Если ЗаполненыИменаПеременных Тогда
		Для каждого ИмяПеременной Из ИменаПеременных Цикл
			УдалитьПеременнуюИзКэша(ИмяПеременной);		
		КонецЦикла; 				
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура УдалитьПеременнуюИзКэша(ИмяПеременной)	
	СсылкаПеременной = ЗначениеПеременной(ИмяПеременной);
	Если ПеременныеСсылок().Получить(СсылкаПеременной) <> Неопределено Тогда
		ПеременныеСсылок().Удалить(СсылкаПеременной);		
	КонецЕсли; 
	Если ЗначенияПеременных().Свойство(ИмяПеременной) Тогда
		ЗначенияПеременных().Удалить(ИмяПеременной);
	КонецЕсли; 	
	ИмяПеременнойНРег = нРег(ИмяПеременной);
	Если СоответствиеЗначенийПеременных().Получить(ИмяПеременнойНРег) <> Неопределено Тогда
		СоответствиеЗначенийПеременных().Удалить(ИмяПеременнойНРег);
	КонецЕсли; 		
	Если ОписанияОбъектов().Свойство(ИмяПеременной) Тогда
		ОписанияОбъектов().Удалить(ИмяПеременной);
	КонецЕсли; 	
КонецПроцедуры 

&НаКлиенте
Процедура ЗапомнитьПеременнуюСценария(ИмяПеременной)	
	ИмяСценария = ИмяТекущегоСценария();	
	ИменаПеременныхСценария = ПеременныеСценариев().Получить(ИмяСценария);
	Если ИменаПеременныхСценария = Неопределено Тогда
		ИменаПеременныхСценария = Новый Массив;		
	КонецЕсли; 
	Если ИменаПеременныхСценария.Найти(ИмяПеременной) <> Неопределено Тогда
		Возврат;		        
	КонецЕсли;	
	ИменаПеременныхСценария.Добавить(ИмяПеременной);
	ПеременныеСценариев().Вставить(ИмяСценария, ИменаПеременныхСценария);	
КонецПроцедуры 

&НаКлиенте
Функция ПеременныеСценариев()
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("ПеременныеСценариев") Тогда
		КэшКлиент.Вставить("ПеременныеСценариев", Новый Соответствие);		
	КонецЕсли; 
	
	Возврат КэшКлиент.ПеременныеСценариев;
	
КонецФункции

&НаСервере
Процедура УдалитьОбъектыБезКонтроляСсылокНаСервере(Знач ИмяМенеджера, Знач Отбор)
	УстановитьПривилегированныйРежим(Истина);
	СписокОбъектов = ОбъектыПоОтборуНаСервере(ИмяМенеджера, Отбор);	
	Для каждого УдаляемаяСсылка Из СписокОбъектов Цикл
		УдалитьОбъект(УдаляемаяСсылка);
	КонецЦикла;	
КонецПроцедуры 

&НаСервере
Процедура УдалитьОбъект(ЗначениеПеременной)
	Если ЭтоПростойТип(ТипЗнч(ЗначениеПеременной)) Тогда
		Возврат;		
	КонецЕсли; 		
		
	МетаОбъект = ЗначениеПеременной.Метаданные();
	ЭтоПеречисление = Метаданные.Перечисления.Содержит(МетаОбъект);
	Если ЭтоПеречисление Тогда
		Возврат;
	КонецЕсли; 		
	
	ОбъектСсылки = ЗначениеПеременной.ПолучитьОбъект();
	ЭтоБитаяСсылка = ОбъектСсылки = Неопределено;
	Если ЭтоБитаяСсылка Тогда
		Возврат;			
	КонецЕсли; 
	
	Если ЕстьРеквизитИлиСвойствоОбъекта(ОбъектСсылки, "Предопределенный") Тогда
		Если ОбъектСсылки.Предопределенный Тогда
			Возврат;				
		КонецЕсли; 
	КонецЕсли; 
	
	ОчиститьЗависимостиОбъектаПередУдалением(ОбъектСсылки, МетаОбъект);
	
	ОбъектСсылки.ОбменДанными.Загрузка = Истина;
	ОбъектСсылки.Удалить();			
		
КонецПроцедуры 

&НаСервере
Процедура ОчиститьЗависимостиОбъектаПередУдалением(ОбъектСсылки, МетаОбъект)
	
	ЭтоДокумент = Метаданные.Документы.Содержит(МетаОбъект);
	Если ЭтоДокумент Тогда		
		Для каждого Набор Из ОбъектСсылки.Движения Цикл
			Набор.Очистить();
			Набор.Записывать = Истина;			
		КонецЦикла; 
		ОбъектСсылки.Движения.Записать();		
	КонецЕсли; 
	
КонецПроцедуры
 
&НаСервере
Процедура ПометитьОбъектыНаУдалениеНаСервере(Знач ИмяМенеджера, Знач Отбор)
	УстановитьПривилегированныйРежим(Истина);
	
	Если Отбор = Неопределено Тогда
		Отбор = Новый Структура;
	КонецЕсли; 	
	Отбор.Вставить("ПометкаУдаления", Ложь);
	
	СписокОбъектов = ОбъектыПоОтборуНаСервере(ИмяМенеджера, Отбор);	
	Для каждого ПомечаемаяСсылка Из СписокОбъектов Цикл
		об = ПомечаемаяСсылка.ПолучитьОбъект();
		об.УстановитьПометкуУдаления(Истина);		
	КонецЦикла;	
	
КонецПроцедуры 

&НаСервере
Процедура ОткатитьИзмененияБазыНаСервере(АдресПараметров)	
	УстановитьПривилегированныйРежим(Истина);
	
	ПараметрыОтката = ПолучитьИзВременногоХранилища(АдресПараметров);	
	ОткатитьКонстанты(ПараметрыОтката.КэшКонстант);
	ОткатитьСсылки(ПараметрыОтката.Ссылки)
		
КонецПроцедуры

&НаСервере
Процедура ОткатитьКонстанты(КэшКонстант)
	Если НЕ ЗначениеЗаполнено(КэшКонстант) Тогда
		Возврат;		
	КонецЕсли; 
	
	Для каждого КлючИЗначение Из КэшКонстант Цикл
		ИмяКонстанты = КлючИЗначение.Ключ;
		ОписаниеЗначения = КлючИЗначение.Значение;
		
		УстановитьКонстантуНаСервере(ИмяКонстанты
			, ОписаниеЗначения.Адрес
			, ОписаниеЗначения.ПомешатьВХранилище
			, ОписаниеЗначения.УстанавливатьПараметрСеанса);		
	КонецЦикла; 	
	
КонецПроцедуры

&НаСервере
Процедура ОткатитьСсылки(Ссылки)
	Если НЕ ЗначениеЗаполнено(Ссылки) Тогда
		Возврат;
	КонецЕсли;
	
	Для каждого УдаляемаяСсылка Из Ссылки Цикл
		ЭтоЗаписиНабора = ТипЗнч(УдаляемаяСсылка) = Тип("Структура");
		Если ЭтоЗаписиНабора Тогда
			МенеджерКласса = МенеджерКласса(УдаляемаяСсылка);
			Для каждого Запись Из УдаляемаяСсылка.Записи Цикл
				МенеджерЗаписи = МенеджерКласса.СоздатьМенеджерЗаписи();
				ЗаполнитьЗначенияСвойств(МенеджерЗаписи, Запись);
				МенеджерЗаписи.Удалить();
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла; 
	
	Для каждого УдаляемаяСсылка Из Ссылки Цикл
		ЭтоЗаписиНабора = ТипЗнч(УдаляемаяСсылка) = Тип("Структура");
		Если ЭтоЗаписиНабора Тогда
			Продолжить;
		КонецЕсли; 
		
		УдалитьОбъект(УдаляемаяСсылка);	
	КонецЦикла; 		
		
КонецПроцедуры

&НаКлиенте
Процедура СохранитьЗначениеКонстанты(ИмяКонстанты, ПомешатьВХранилище, УстанавливатьПараметрСеанса)
	
	КонстантаСохранена = КэшКонстант().Свойство(ИмяКонстанты);	
	Если КонстантаСохранена Тогда
		Возврат;		
	КонецЕсли; 
	
	ОписаниеЗначения = НовоеОписаниеЗначенияКонстанты();	
	ОписаниеЗначения.Адрес = VAЗначениеКонстанты(ИмяКонстанты, ПомешатьВХранилище, Истина);
	ОписаниеЗначения.ПомешатьВХранилище = ПомешатьВХранилище;
	ОписаниеЗначения.УстанавливатьПараметрСеанса = УстанавливатьПараметрСеанса;
	ОписаниеЗначения.ИмяСценария = ИмяТекущегоСценария();
	
	КэшКонстант().Вставить(ИмяКонстанты, ОписаниеЗначения);
КонецПроцедуры
 
&НаКлиенте
Функция КэшКонстант()
	
	Кэш = КэшКлиент();
	Если НЕ Кэш.Свойство("КэшКонстант") Тогда
		Кэш.Вставить("КэшКонстант", Новый Структура);
		
	КонецЕсли; 
	
	Возврат Кэш.КэшКонстант;
	
КонецФункции

#КонецОбласти 

#Область СозданиеОбъектов

#Область СозданиеОбъектовСервис

&НаСервере
Функция ЗначениеБДПоОписанию(Знач ОписаниеОбъекта)

	Классы = КлассыОбъектовКлиентСервер();
	ПривестиЗначенияРеквизитов(ОписаниеОбъекта);
	Если ОписаниеОбъекта.Класс = Классы.РегистрыСведений Тогда
		Результат = КлючиЗаписейРегистраСведений(ОписаниеОбъекта);
	Иначе
		Результат = СсылкаОбъекта(ОписаниеОбъекта);		
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Процедура ЗаполнитьСвойстваОбъекта(Приемник, ОписаниеОбъекта, ЕстьДвижения = Ложь)
	ЕстьСвойствоОбменДанными = ЕстьРеквизитИлиСвойствоОбъекта(Приемник, "ОбменДанными");
	ИсключаемыеРеквизиты = "";
	Если ЕстьСвойствоОбменДанными Тогда
		ИсключаемыеРеквизиты = "ОбменДанными";		
	КонецЕсли; 
	
	ПротоОбъект = ОписаниеОбъекта.ПротоОбъект;
	ЗаполнитьЗначенияСвойств(Приемник, ПротоОбъект, , ИсключаемыеРеквизиты);
	Если ЕстьСвойствоОбменДанными И ПротоОбъект.ОбменДанными Тогда
		Приемник.ОбменДанными.Загрузка = Истина;
	КонецЕсли; 
	
	ЗаполнитьСубколлекцииОбъекта(Приемник, ОписаниеОбъекта, ЕстьДвижения);
	
КонецПроцедуры 

&НаСервере
Процедура ЗаполнитьСубколлекцииОбъекта(Приемник, ОписаниеОбъекта, ЕстьДвижения)

	ЕстьДвижения = Ложь;
	КлассыРеквизитов = КлассыРеквизитовСервер();
	ПротоОбъект = ОписаниеОбъекта.ПротоОбъект;
	Для каждого ОписаниеРеквизита Из ОписаниеОбъекта.ОписаниеРеквизитов Цикл		
		ИмяРеквизита = ОписаниеРеквизита.Ключ;
		СвойстваРеквизита = ОписаниеРеквизита.Значение;
		
		Если ИмяРеквизита = КлассыРеквизитов.ТабличныеЧасти Тогда
			ЗаполнитьСубколлекциюОбъекта(Приемник, ПротоОбъект, СвойстваРеквизита);
			
		ИначеЕсли ИмяРеквизита = КлассыРеквизитов.Движения Тогда
			ЕстьДвижения = Истина;
			ЗаполнитьСубколлекциюОбъекта(Приемник, ПротоОбъект, СвойстваРеквизита);
		Иначе
			Продолжить;
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры 

&НаСервере
Процедура ЗаполнитьСубколлекциюОбъекта(Приемник, ПротоОбъект, СвойстваРеквизита)
	
	КлассыРеквизитов = КлассыРеквизитовСервер();

	Для каждого ОписаниеСК Из СвойстваРеквизита Цикл
		ИмяСК = ОписаниеСК.Ключ;
		СвойстваСК = ОписаниеСК.Значение;
			
		ИсточникСК = Неопределено;
		Если НЕ ПротоОбъект.Свойство(СвойстваСК.Класс, ИсточникСК) Тогда
			Продолжить;
		КонецЕсли; 
		
		ЗначениеРеквизита = Неопределено;
		Если НЕ ИсточникСК.Свойство(ИмяСК, ЗначениеРеквизита) Тогда
			Продолжить;	
		КонецЕсли; 
		
		Если НЕ ЗначениеЗаполнено(ЗначениеРеквизита.Строки) Тогда
			Продолжить;			
		КонецЕсли; 
		
		ЭтоДвижения = Ложь;
		
		Если СвойстваСК.Класс = КлассыРеквизитов.ТабличныеЧасти Тогда
			ПриемникСК = Приемник[ИмяСК];
			
		ИначеЕсли СвойстваСК.Класс = КлассыРеквизитов.Движения Тогда 
			ПриемникСК = Приемник.Движения[ИмяСК];			
			ПриемникСК.Записывать = Истина;
			ПриемникСК.ОбменДанными.Загрузка = ПротоОбъект.ОбменДанными;
			
			ЭтоДвижения = Истина;
			СсылкаРегистратора = ?(Приемник.ЭтоНовый()
				, Приемник.ПолучитьСсылкуНового()
				, Приемник.Ссылка);
				
			ПриемникСК.Отбор.Регистратор.Установить(СсылкаРегистратора);	
		Иначе
			ВызватьИсключение "Неизвестный класс субколлекции: " + СвойстваСК.Класс;
		КонецЕсли; 
		
		Для каждого СтрокаСК Из ЗначениеРеквизита.Строки Цикл
			СтрокаПриемник = ПриемникСК.Добавить();			
			Для каждого ОписаниеКолонки Из ЗначениеРеквизита.Колонки Цикл
				ИмяКолонки = ОписаниеКолонки.Ключ;
				ЗначениеПоля = Неопределено;
				Если СтрокаСК.Свойство(ИмяКолонки, ЗначениеПоля) Тогда
					СтрокаПриемник[ИмяКолонки] = ЗначениеПоля;					
				КонецЕсли; 
			КонецЦикла; 			
			Если ЭтоДвижения Тогда
				СтрокаПриемник.Регистратор = СсылкаРегистратора;
				Если НЕ ЗначениеЗаполнено(СтрокаПриемник.Период) Тогда
					СтрокаПриемник.Период = Приемник.Дата;
				КонецЕсли; 				
			КонецЕсли; 			
		КонецЦикла; 				
	КонецЦикла; 	
	
КонецПроцедуры

&НаСервере
Функция МенеджерКласса(ОписаниеОбъекта)
	Возврат Вычислить(ОписаниеОбъекта.Класс + "." + ОписаниеОбъекта.Вид);
	
КонецФункции

&НаСервере
Функция МенеджерКлассаПоТипу(Тип)
	
	МетаОбъект = Метаданные.НайтиПоТипу(Тип);
	ПолноеИмяОбъекта = МетаОбъект.ПолноеИмя();
	ПолноеИмяМенеджера = СтрЗаменить(ПолноеИмяОбъекта, ".", "Менеджер.");
	МенеджерКласса = Новый (ПолноеИмяМенеджера);
	
	Возврат МенеджерКласса;
	
КонецФункции

&НаКлиенте
Функция ОписаниеОбъектаСсылки(ОписаниеСсылки) 	
	КлассВид = КлассВидТипаСсылки(ОписаниеСсылки.Ссылка);
	
	ОписаниеРеквизитов = ОписаниеРеквизитов(КлассВид.Класс, КлассВид.Вид);
	Результат = НоваяСтруктураОписанияОбъекта();	
	Результат.ОписаниеРеквизитов = ОписаниеРеквизитов;
	Результат.Класс = КлассВид.Класс;
	Результат.Вид = КлассВид.Вид;
	Результат.ИмяПеременной = ОписаниеСсылки.ИмяПеременной;
	Результат.ПротоОбъект = ПротоОбъект(ОписаниеРеквизитов, Ложь);
	
	Возврат Результат;
	
КонецФункции 

#КонецОбласти 

#Область УИДПеременной

&НаКлиенте
Функция УИДПеременной(ИмяМенеджера, ИмяПеременной, ДатаИлиЭтоГруппа)
	
	ИмяФичи = СостояниеВанессы().ТекущаяФича.Имя;
	Источник = ИмяФичи + "_" + ИмяМенеджера + "_" + ИмяПеременной + "_" + ДатаИлиЭтоГруппа;
	СуммаВ10СС = СуммаПоНомерамСимволовСтрокиСУчетомПорядкаСимволов(Источник);
	СуммаВ16СС = DecToHex(СуммаВ10СС);
	
	//8-4-4-4-12
	Результат = "";
	ДобавитьЧастьГУИД(Результат, СуммаВ16СС, 8);
	ДобавитьЧастьГУИД(Результат, СуммаВ16СС, 4);
	ДобавитьЧастьГУИД(Результат, СуммаВ16СС, 4);
	ДобавитьЧастьГУИД(Результат, СуммаВ16СС, 4);
	ДобавитьЧастьГУИД(Результат, СуммаВ16СС, 12, Истина);
	
	Возврат Результат;	
	
КонецФункции

&НаКлиенте
Процедура ДобавитьЧастьГУИД(Результат, СтрНачало, КолСимв, ЭтоПоследнийОктет = Ложь)

	ЧастьГуид = Лев(СтрНачало, КолСимв);
	ДлинаЧастьГуид = СтрДлина(ЧастьГуид);
	ДлинаСтрНачало = СтрДлина(СтрНачало);
	
	Если ДлинаЧастьГуид < КолСимв Тогда
		КолСимвДоКонцаБлока = КолСимв - ДлинаЧастьГуид;
		ФСтрока = "ЧЦ="+ КолСимвДоКонцаБлока +"; ЧН=; ЧВН=; ЧГ=";
		СимволыКонцаБлока = Формат(0, ФСтрока);
		БлокГуид = ЧастьГуид + СимволыКонцаБлока;
		СтрНачало = "";				
	Иначе
		БлокГуид = ЧастьГуид;
		СтрНачало = Сред(СтрНачало, ДлинаЧастьГуид + 1);
	КонецЕсли; 
	
	Разделитель = ?(ЭтоПоследнийОктет, "", "-");
	Результат = Результат + БлокГуид + Разделитель;

КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция СуммаПоНомерамСимволовСтрокиСУчетомПорядкаСимволов(стр)
	
	Рез = 0;
	Для сч=1 По СтрДлина(стр) Цикл
		Сим = Сред(стр, сч, 1); 
		Рез = Рез + КодСимвола(Сим)*сч;		
	КонецЦикла;
	
	Возврат Рез;
	
КонецФункции
 
Функция DecToHex(Знач ЧислоВ10СС)
	Результат = "";
	тЧисло = ЧислоВ10СС;
	тБаза = 16;	
	Пока тЧисло <> 0 Цикл
		тПоз = тЧисло % тБаза;
		Результат = Сред("0123456789abcdef", тПоз + 1, 1) + Результат;
		тЧисло = Цел(тЧисло / тБаза);
	КонецЦикла;	
	Если ЧислоВ10СС < тБаза Тогда 
		Результат = "0" + Результат; 
	КонецЕсли;
	Возврат Результат;
КонецФункции 

#КонецОбласти 

#Область ЗаписьРегистраСведений 
 
&НаСервере
Функция КлючиЗаписейРегистраСведений(ОписаниеОбъекта)
	
	Результат = Новый Структура;
	Результат.Вставить("Класс", ОписаниеОбъекта.Класс);
	Результат.Вставить("Вид", ОписаниеОбъекта.Вид);
	Результат.Вставить("Записи", Новый Массив);
	
	Если ЗначениеЗаполнено(ОписаниеОбъекта.ЗаписиНабора) Тогда
		Для каждого ОписаниеЗаписи Из ОписаниеОбъекта.ЗаписиНабора Цикл
			КлючЗаписи = КлючЗаписиРС(ОписаниеОбъекта, ОписаниеЗаписи);
			Результат.Записи.Добавить(КлючЗаписи);
		КонецЦикла; 
	Иначе
		КлючЗаписи = КлючЗаписиРС(ОписаниеОбъекта);
		Результат.Записи.Добавить(КлючЗаписи);		
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция КлючЗаписиРС(ОписаниеОбъекта, ОписаниеЗаписи = Неопределено)
	
	Если ОписаниеЗаписи = Неопределено Тогда
		ОписаниеЗаписи = ОписаниеОбъекта.ПротоОбъект;		
	КонецЕсли; 
	
	Отборы = ИменаОтбораРС(ОписаниеОбъекта.Вид);	
	МенеджерКласса = МенеджерКласса(ОписаниеОбъекта);
	
	Набор =  МенеджерКласса.СоздатьНаборЗаписей();		
	Для каждого ИмяОтбора Из Отборы Цикл
		ЗначениеОтбора = Неопределено;
		Если ОписаниеЗаписи.Свойство(ИмяОтбора, ЗначениеОтбора) Тогда
			Набор.Отбор[ИмяОтбора].Установить(ЗначениеОтбора);
		КонецЕсли; 		
	КонецЦикла; 
	
	Запись = Набор.Добавить();
	ЗаполнитьЗначенияСвойств(Запись, ОписаниеЗаписи);	
	Набор.ОбменДанными.Загрузка = СвойствоСтруктуры(ОписаниеОбъекта.ПротоОбъект, "ОбменДанными", Ложь);
	Набор.Записать();	
	
	Результат = МенеджерКласса.СоздатьКлючЗаписи(ОписаниеЗаписи);
	Возврат Результат;
КонецФункции

&НаСервере
Функция ИменаОтбораРС(ИмяРегистра)
	
	Кэш = КэшСервер();
	Если НЕ Кэш.Свойство("ИменаОтборовРС") Тогда
		Кэш.Вставить("ИменаОтборовРС", Новый Соответствие);		
	КонецЕсли; 
	
	Результат = Кэш.ИменаОтборовРС.Получить(ИмяРегистра);
	Если Результат = Неопределено Тогда
		Результат = Новый Массив;
		
		МетаРегистр = Метаданные.РегистрыСведений[ИмяРегистра];		
		Периодический = МетаРегистр.ПериодичностьРегистраСведений <>
			Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;		
		Если Периодический Тогда
			Результат.Добавить("Период");	
		КонецЕсли; 
		Для каждого МетаИзмерение Из МетаРегистр.Измерения Цикл
			ИмяИзмерения = МетаИзмерение.Имя;
			Результат.Добавить(ИмяИзмерения);
		КонецЦикла; 		
		Кэш.ИменаОтборовРС.Вставить(ИмяРегистра, Результат);
	КонецЕсли; 
		
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#Область Ссылочные

// Поиск и создание \ обновление ссылочного объекта по описанию. При успешном поиске, перед обновлением
// происходит обезличивание объекта - все реквизиты затираются (кроме стандартных), движения и 
// табличные части очищаются.
// Поиск (позиционирование) выполняется только по уникальному идентификатору ссылки, либо по имени  
// предопределенного элемента.
// 
// Параметры:
// 	ОписаниеОбъекта - Структура - см. НовоеОписаниеОбъекта
// 	
// Возвращаемое значение:
//  Ссылка
// 	
&НаСервере
Функция СсылкаОбъекта(ОписаниеОбъекта)
	Перем ОбъектБД;
	
	СсылкаБД = НайтиСсылку(ОписаниеОбъекта);
	
	Если ЗначениеЗаполнено(СсылкаБД) Тогда
		ОбъектБД = СсылкаБД.ПолучитьОбъект();
		Если ОбъектБД <> Неопределено Тогда
			ОбезличитьОбъект(ОбъектБД, ОписаниеОбъекта);
		КонецЕсли; 				
	КонецЕсли; 
	
	Если ОбъектБД = Неопределено Тогда
		ОбъектБД = НовыйОбъектБД(ОписаниеОбъекта);				
	КонецЕсли; 
	
	Если ОписаниеОбъекта.ВызовЗаполнения Тогда
		ОбъектБД.Заполнить(Неопределено);		
	КонецЕсли; 
	
	УстановитьСсылкуНовогоОбъекта(ОбъектБД, ОписаниеОбъекта);		
	УстановитьНовыйКодНомерОбъекта(ОбъектБД, ОписаниеОбъекта);
	ЗаполнитьСвойстваИЗаписатьОбъект(ОбъектБД, ОписаниеОбъекта);
	
	Возврат ОбъектБД.Ссылка;
	
КонецФункции

&НаСервере
Процедура ОбновитьСсылкуОбъекта(Знач СсылкаБД, Знач ОписаниеОбъекта)
	ПривестиЗначенияРеквизитов(ОписаниеОбъекта);
	ОбъектБД = СсылкаБД.ПолучитьОбъект();
	ЗаполнитьСвойстваИЗаписатьОбъект(ОбъектБД, ОписаниеОбъекта);
КонецПроцедуры 

&НаСервере
Процедура ЗаполнитьСвойстваИЗаписатьОбъект(ОбъектБД, ОписаниеОбъекта)
	ЕстьДвижения = Ложь;	
	ЗаполнитьСвойстваОбъекта(ОбъектБД, ОписаниеОбъекта, ЕстьДвижения);		
	ОбъектБД.Записать();
	
	Если ЕстьДвижения Тогда
		ОбъектБД.Движения.Записать();				
	КонецЕсли; 
КонецПроцедуры 

&НаСервере
Процедура ПривестиЗначенияРеквизитов(ОписаниеОбъекта)

	КлассыРеквизитов = КлассыРеквизитовСервер();
	ПротоОбъект = ОписаниеОбъекта.ПротоОбъект;
	ИмяПеременной = ОписаниеОбъекта.ИмяПеременной;
	
	Для каждого КлючИЗначение Из ПротоОбъект Цикл
		ИмяРеквизита = КлючИЗначение.Ключ;
		ЗначениеРеквизита = КлючИЗначение.Значение;
		
		ЭтоСубколлекция = ИмяРеквизита = КлассыРеквизитов.ТабличныеЧасти
			ИЛИ ИмяРеквизита = КлассыРеквизитов.Движения;
			
		Если ЭтоСубколлекция Тогда
			ПривестиЗначенияСубколлекции(ЗначениеРеквизита, ИмяПеременной);
		Иначе
			ОписаниеРеквизита = СвойствоСтруктуры(ОписаниеОбъекта.ОписаниеРеквизитов
				, ИмяРеквизита);
			ПривестиЗначениеРеквизита(ОписаниеРеквизита
				, ПротоОбъект[ИмяРеквизита]
				, ИмяПеременной);
		КонецЕсли; 		
	КонецЦикла; 
	
	Если ЗначениеЗаполнено(ОписаниеОбъекта.ЗаписиНабора) Тогда
		Для каждого ОписаниеЗаписи Из ОписаниеОбъекта.ЗаписиНабора Цикл			
			Для каждого КлючИЗначение Из ОписаниеЗаписи Цикл
				ИмяРеквизита = КлючИЗначение.Ключ;
				ОписаниеРеквизита = СвойствоСтруктуры(ОписаниеОбъекта.ОписаниеРеквизитов
					, ИмяРеквизита);
				
				ПривестиЗначениеРеквизита(ОписаниеРеквизита
					, ОписаниеЗаписи[ИмяРеквизита]
					, ИмяПеременной);
				
			КонецЦикла; 			
		КонецЦикла;			
	КонецЕсли; 
	
КонецПроцедуры 

&НаСервере
Процедура ПривестиЗначенияСубколлекции(ЗначениеРеквизита, ИмяПеременной)
	Для каждого ОписаниеКоллекций Из ЗначениеРеквизита Цикл
		ОписаниеКоллекции = ОписаниеКоллекций.Значение;
		Если НЕ ЗначениеЗаполнено(ОписаниеКоллекции.Строки) Тогда
			Продолжить;
		КонецЕсли;
		
		Для каждого ОписаниеСтроки Из ОписаниеКоллекции.Строки Цикл
			Для каждого ОписаниеКолонок Из ОписаниеКоллекции.Колонки Цикл
				ИмяКолонки = ОписаниеКолонок.Ключ;
				
				Если ОписаниеСтроки.Свойство(ИмяКолонки) Тогда
					ОписаниеКолонки = ОписаниеКолонок.Значение;
					ПривестиЗначениеРеквизита(ОписаниеКолонки
						, ОписаниеСтроки[ИмяКолонки]
						, ИмяПеременной);								
				КонецЕсли; 
			КонецЦикла; 						
		КонецЦикла; 					

	КонецЦикла; 	
КонецПроцедуры

&НаСервере
Процедура ПривестиЗначениеРеквизита(ОписаниеРеквизита, ЗначениеРеквизита, ИмяПеременной)
	Если ОписаниеРеквизита = Неопределено Тогда
		Возврат;			
	КонецЕсли; 

	Если ОписаниеРеквизита.Имя = "Ссылка" Тогда
		Возврат;		
	КонецЕсли; 
	
	ШаблонИсключения = ПодставитьПараметрыВСтроку("Неверный идентификатор %1 в реквизите %2.%3"
	, "%1"
	, ИмяПеременной
	, ОписаниеРеквизита.Имя);
	ПроверитьУстановитьСсылкуПД(ОписаниеРеквизита.Тип, ЗначениеРеквизита, ШаблонИсключения);

	ТипЗнРеквизита = ТипЗнч(ЗначениеРеквизита);
	Если НЕ ОписаниеРеквизита.Тип.СодержитТип(ТипЗнРеквизита) Тогда
		ЗначениеРеквизита = ОписаниеРеквизита.Тип.ПривестиЗначение(ЗначениеРеквизита);		
	КонецЕсли; 
	
КонецПроцедуры 

&НаСервере
Процедура ПроверитьУстановитьСсылкуПД(ТипИлиОписаниеТипов, ЗначениеРеквизита, ШаблонИсключения)
	
	Если НЕ ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
		Возврат;		
	КонецЕсли; 
	
	Если ТипЗнч(ЗначениеРеквизита) <> Тип("Строка") Тогда
		Возврат;
	КонецЕсли; 
	
	Если ТипЗнч(ТипИлиОписаниеТипов) = Тип("ОписаниеТипов") Тогда
		Типы = ТипИлиОписаниеТипов.Типы();
		УдалитьЗначениеИзМассива(Типы, Тип("Строка"));
		УдалитьЗначениеИзМассива(Типы, Тип("Число"));
		УдалитьЗначениеИзМассива(Типы, Тип("Дата"));
		УдалитьЗначениеИзМассива(Типы, Тип("Булево"));
		
		Если НЕ ЗначениеЗаполнено(Типы) Тогда
			Возврат;			
		КонецЕсли; 
		
		Если Типы.Количество() > 1 Тогда
			ВызватьИсключение ПодставитьПараметрыВСтроку(ШаблонИсключения, ЗначениеРеквизита) + 
			": невозможно определить ссылку по идентификатору предопределенного в реквизите составного типа.";	
		КонецЕсли; 
		
		Тип = Типы[0];
	Иначе
		Тип = ТипИлиОписаниеТипов;	
		Если ЭтоПростойТип(Тип) Тогда
			Возврат;				
		КонецЕсли; 		
	КонецЕсли; 

	Если СтрокаМожетБытьИменемПеременной(ЗначениеРеквизита) Тогда	
		СсылкаПредопределенного = СсылкаПредопределенного(Тип, ЗначениеРеквизита);
		Если ЗначениеЗаполнено(СсылкаПредопределенного) Тогда
			ЗначениеРеквизита = СсылкаПредопределенного;
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ЗначениеПоПредставлению = ЗначениеПоСтрокеПоиска(Тип, ЗначениеРеквизита);
	Если ЗначениеЗаполнено(ЗначениеПоПредставлению) Тогда
		ЗначениеРеквизита = ЗначениеПоПредставлению;
		Возврат;
	КонецЕсли;
	
	ВызватьИсключение ПодставитьПараметрыВСтроку(ШаблонИсключения, ЗначениеРеквизита) + 
	": невозможно определить ссылку.";	
	
КонецПроцедуры 

&НаКлиентеНаСервереБезКонтекста
Функция ЭтоПростойТип(Тип)
	
	Возврат Тип = Тип("Строка")
		ИЛИ Тип = Тип("Число")
		ИЛИ Тип = Тип("Дата")
		ИЛИ Тип = Тип("Булево");
	
КонецФункции 

&НаСервере
Функция СсылкаПредопределенного(Тип, Имя)
	МетаОбъект = Метаданные.НайтиПоТипу(Тип);
	Если МетаОбъект = Неопределено Тогда
		Если Тип = Тип("ВидДвиженияНакопления") Тогда
			Результат = ВидДвиженияНакопления[Имя];
			
		ИначеЕсли Тип = Тип("ВидДвиженияБухгалтерии") Тогда
			Результат = ВидДвиженияБухгалтерии[Имя];			
		Иначе
			ВызватьИсключение "Неизвестный тип предопределенного " + Тип + " (" + Имя + ")";
		КонецЕсли; 		
	Иначе
		ИмяПредопределенного = МетаОбъект.ПолноеИмя() + "." + Имя;
		Попытка
			Результат = ПредопределенноеЗначение(ИмяПредопределенного);			
		Исключение
			Результат = Неопределено;
		КонецПопытки;		
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция ЗначениеПоСтрокеПоиска(Тип, СтрокаПоиска)
	
	Кэш = КэшСервер();
	Если НЕ Кэш.Свойство("ЗначенияПоСтрокеПоиска") Тогда
		Кэш.Вставить("ЗначенияПоСтрокеПоиска", Новый Соответствие);
	КонецЕсли;
	
	Ключ = Строка(Тип) + СтрокаПоиска;
	Результат = Кэш.ЗначенияПоСтрокеПоиска.Получить(Ключ);
	
	Если Результат = Неопределено Тогда
		МенеджерКласса = МенеджерКлассаПоТипу(Тип);
		ПараметрыВыбора = Новый Структура("СтрокаПоиска", СтрокаПоиска);
		СписокЗначений = МенеджерКласса.ПолучитьДанныеВыбора(ПараметрыВыбора);
		Если ЗначениеЗаполнено(СписокЗначений) Тогда
			Результат = СписокЗначений[0].Значение;
		КонецЕсли;
		
		Кэш.ЗначенияПоСтрокеПоиска.Вставить(Ключ, Результат);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция НовыйОбъектБД(ОписаниеОбъекта)
	Перем Результат;
	
	Классы = КлассыОбъектовКлиентСервер();	
	МенеджерКласса = МенеджерКласса(ОписаниеОбъекта);
	ПротоОбъект = ОписаниеОбъекта.ПротоОбъект;
	ЭтоГруппа = СвойствоСтруктуры(ПротоОбъект, "ЭтоГруппа", Ложь);

	Если ЭтоГруппа Тогда
		Результат = МенеджерКласса.СоздатьГруппу();
	Иначе
		Если ОписаниеОбъекта.Класс = Классы.ПланыОбмена Тогда
			Результат = МенеджерКласса.СоздатьУзел();
			
		ИначеЕсли ОписаниеОбъекта.Класс = Классы.Справочники
			ИЛИ ОписаниеОбъекта.Класс = Классы.ПланыВидовХарактеристик
			ИЛИ ОписаниеОбъекта.Класс = Классы.ПланыСчетов Тогда			
			Результат = МенеджерКласса.СоздатьЭлемент();
			
		ИначеЕсли ОписаниеОбъекта.Класс = Классы.Документы Тогда
			Результат = МенеджерКласса.СоздатьДокумент();	
			
		ИначеЕсли ОписаниеОбъекта.Класс = Классы.БизнесПроцессы Тогда
			Результат = МенеджерКласса.СоздатьБизнесПроцесс();	
			
		ИначеЕсли ОписаниеОбъекта.Класс = Классы.Задачи Тогда
			Результат = МенеджерКласса.СоздатьЗадачу();	
			
		Иначе
			ВызватьИсключение "Неизвестный класс, при создании ссылочного объекта: " + ОписаниеОбъекта.Класс;
		КонецЕсли; 		
		
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции
 
&НаСервере
Процедура ОбезличитьОбъект(ОбъектБД, ОписаниеОбъекта, КлассыРеквизитовОтбор = Неопределено)

	КлассыРеквизитов = КлассыРеквизитовСервер();
	ЭтоГруппа = СвойствоСтруктуры(ОписаниеОбъекта.ПротоОбъект, "ЭтоГруппа", Ложь);
	
	ЕстьДвижения = Ложь;
	ИспользоватьОтбор = ЗначениеЗаполнено(КлассыРеквизитовОтбор);
	
	Для каждого КлючИЗначение Из ОписаниеОбъекта.ОписаниеРеквизитов Цикл
		ИмяРеквизита = КлючИЗначение.Ключ;
		ОписаниеРеквизита = КлючИЗначение.Значение;
		
		Если НЕ ЕстьДвижения Тогда
			ЕстьДвижения = ИмяРеквизита = КлассыРеквизитов.Движения;
			
		КонецЕсли; 
		
		ЭтоСубколлекция = ИмяРеквизита = КлассыРеквизитов.ТабличныеЧасти
			ИЛИ ИмяРеквизита = КлассыРеквизитов.Движения;
			
		Если ИспользоватьОтбор Тогда
			Если ЭтоСубколлекция Тогда
				ТекущийКласс = ИмяРеквизита;
			Иначе
				ТекущийКласс = ОписаниеРеквизита.Класс;				
			КонецЕсли;	 
			
			Если НЕ КлассыРеквизитовОтбор.Свойство(ТекущийКласс) Тогда
				Продолжить;				
			КонецЕсли; 			
		КонецЕсли; 			
			
		Если ЭтоСубколлекция Тогда
			Для каждого ОписаниеСубколлекций Из ОписаниеРеквизита Цикл
				ОписаниеСК = ОписаниеСубколлекций.Значение;				
				ОчиститьРеквизит(ОбъектБД, ОписаниеСК, ЭтоГруппа, Истина);								
			КонецЦикла; 
		Иначе
			ОчиститьРеквизит(ОбъектБД, ОписаниеРеквизита, ЭтоГруппа, Ложь);
		КонецЕсли; 			
	КонецЦикла; 
	
	Если ЕстьДвижения Тогда		
		ОбъектБД.Движения.Записать();		
	КонецЕсли; 
	
КонецПроцедуры 

&НаСервере
Процедура ОчиститьРеквизит(ОбъектБД, ОписаниеРеквизита, ЭтоГруппа, ЭтоСК)
	КлассыРеквизитов = КлассыРеквизитовСервер();
	Если ОписаниеРеквизита.Класс = КлассыРеквизитов.СтандартныеРеквизиты Тогда
		Возврат;			
	КонецЕсли; 
	
	Если ЭтоГруппа Тогда
		Если ОписаниеРеквизита.Использование = ИспользованиеРеквизитов().ДляЭлемента Тогда
			Возврат;				
		КонецЕсли; 			
	КонецЕсли; 
	
	Если ЭтоСК Тогда
		Если ОписаниеРеквизита.Класс = КлассыРеквизитов.ТабличныеЧасти Тогда
			ОбъектБД[ОписаниеРеквизита.Имя].Очистить();
			
		ИначеЕсли ОписаниеРеквизита.Класс = КлассыРеквизитов.Движения Тогда	
			Набор = ОбъектБД.Движения[ОписаниеРеквизита.Имя];
			Набор.Очистить();  
			Набор.Записывать = Истина;
		Иначе
			ВызватьИсключение "Неизвестный класс субколлекции:" + ОписаниеРеквизита.Класс;
		КонецЕсли; 
				
	Иначе
		ОбъектБД[ОписаниеРеквизита.Имя] = Неопределено;
	КонецЕсли; 	
КонецПроцедуры 

&НаСервере
Функция ОписаниеИдОбъекта(ОписаниеОбъекта)
	Результат = Новый Структура;
	Результат.Вставить("УИД");
	Результат.Вставить("Заполнен", Ложь);
	
	УИДСтрокой = СвойствоСтруктуры(ОписаниеОбъекта.ПротоОбъект, "Ссылка");
	Если ЗначениеЗаполнено(УИДСтрокой) Тогда
		Результат.УИД = Новый УникальныйИдентификатор(УИДСтрокой);
		Результат.Заполнен = Истина;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции 

&НаСервере
Функция НайтиСсылку(ОписаниеОбъекта)
	Перем Результат;
	
	МенеджерКласса = МенеджерКласса(ОписаниеОбъекта);	
	ОписаниеИд = ОписаниеИдОбъекта(ОписаниеОбъекта);
	Если ОписаниеИд.Заполнен Тогда
		Результат = МенеджерКласса.ПолучитьСсылку(ОписаниеИд.УИД);		
	КонецЕсли; 
	
	Если НЕ ЗначениеЗаполнено(Результат) Тогда
		ИмяПД = СвойствоСтруктуры(ОписаниеОбъекта.ПротоОбъект, "ИмяПредопределенныхДанных");
		Если ЗначениеЗаполнено(ИмяПД) Тогда
			Результат = МенеджерКласса[ИмяПД];
		КонецЕсли; 		
	КонецЕсли; 	
	
	Возврат Результат;
КонецФункции

&НаСервере
Процедура УстановитьСсылкуНовогоОбъекта(ОбъектБД, ОписаниеОбъекта)	
	Если ОбъектБД.ЭтоНовый() Тогда
		МенеджерКласса = МенеджерКласса(ОписаниеОбъекта);
		ОписаниеИдОбъекта = ОписаниеИдОбъекта(ОписаниеОбъекта);
		Если ОписаниеИдОбъекта.Заполнен Тогда
			СсылкаНового = МенеджерКласса.ПолучитьСсылку(ОписаниеИдОбъекта.УИД); 			
		Иначе
			СсылкаНового = МенеджерКласса.ПолучитьСсылку(); 			
		КонецЕсли; 		
		ОбъектБД.УстановитьСсылкуНового(СсылкаНового);
	КонецЕсли;	
КонецПроцедуры 

&НаСервере
Процедура УстановитьНовыйКодНомерОбъекта(ОбъектБД, ОписаниеОбъекта)

	ЕстьНомер = Ложь;
	ЕстьКод = Ложь;
	МетаОбъектБД = ОбъектБД.Метаданные();
	Для каждого МетаРеквизит Из МетаОбъектБД.СтандартныеРеквизиты Цикл
		Если МетаРеквизит.Имя = "Номер" Тогда
			ЕстьНомер = ЗначениеЗаполнено(МетаОбъектБД.ДлинаНомера);
			Прервать;
			
		ИначеЕсли МетаРеквизит.Имя = "Код" Тогда
			ЕстьКод = ЗначениеЗаполнено(МетаОбъектБД.ДлинаКода);
			Прервать;
		Иначе
			Продолжить;
		КонецЕсли; 		
	КонецЦикла; 
	
	Если ЕстьНомер Тогда
		Если НЕ ЗначениеЗаполнено(ОбъектБД.Номер) Тогда
			ОбъектБД.УстановитьНовыйНомер();			
		КонецЕсли; 		
	КонецЕсли; 
	
	Если ЕстьКод Тогда
		Если НЕ ЗначениеЗаполнено(ОбъектБД.Код) Тогда
			ОбъектБД.УстановитьНовыйКод();			
		КонецЕсли; 		
	КонецЕсли; 
	
КонецПроцедуры        

#КонецОбласти 

#КонецОбласти 

#Область ТаблицаПоОписаниюГеркина

&НаКлиенте
Процедура ПроверитьКолонкиТаблицыГеркина(ТаблицаГеркина, КолонкиСтрокой)
	
	Колонки = ТаблицаГеркина[0];
	
	КолонкиМассив = РазложитьСтрокуВМассивПодстрок(нРег(КолонкиСтрокой), ",");
	Для каждого КлючИЗначение Из Колонки Цикл
		УдалитьЗначениеИзМассива(КолонкиМассив, нРег(КлючИЗначение.Значение));
	КонецЦикла; 
	
	Если ЗначениеЗаполнено(КолонкиМассив) Тогда
		ТекстИсключения = "Ожидались колонки:" + КолонкиСтрокой + ". " + 
		ТекстРекомендацииПриОшибкеКолонокГеркина();
		ВызватьИсключение ТекстИсключения;		
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция ТекстРекомендацииПриОшибкеКолонокГеркина()
	Возврат "Рекомендации:" + Символы.ПС + 
	" - уберите пробельные символы" + Символы.ПС + 
	" - попробуйте сделать отступ от начала колонки" + Символы.ПС + 
	" - попробуйте убрать лишние отступы" + Символы.ПС + 
	" - попробуйте заключить значения колонки в апострофы";	
КонецФункции 

// Конвертация таблицы геркина в массив структур, где у каждой записи ключ это имя поля, а значения
// сопоставляются с ранее описанными переменными. 
// 
// Параметры:
// 	Источник - Массив из Структура - таблица геркина, где первая
//	запись массива содержит имена колонок, все последующие записи - значения полей строк. Например:
//	Для описания таблицы с колонками "Период, Контрагент, Сумма":
//	1-я запись (ключ=значение): Кол1="Период";Кол2="Контрагент";Кол3="Сумма"
//	2-я (и последующие записи): Кол1=01.01.1980;Кол2="Иванов";Кол3=1000 
// 	КолонкиИсключаемыеИзЗаменыСсылок - Неопределено, Строка - в некоторых случаях необходимо отключить 
// 	замену идентификаторов на значения переменных, этот параметр указывает для каких колонок это нужно 
// 	сделать. Например, если есть таблица, описывающая перечень реквизитов, вида:
// 	|Имя			|Значение		|
// 	|Организация	|Организация	|
// 	, где "Организация" в поле "Имя" нужна как строковый идентификатор, а в поле "Значение" 
// 	подразумевается ранее описанная ссылка - то таблицу по описанию следует приводить так:
// 	Записи = ПривестиТаблицуГеркина(Источник, "Имя"); 	    
// 	Приемник - Неопределено, Массив - переменная для помещения результата работы функции
// 	
// Возвращаемое значение:
// 	Массив Из Структура - для примера из описания вернется коллекция из одной записи:
// 	Если "Иванов" - это переменная описанная в скрипте как ссылка на контрагента:
// 	Период=01.01.1980;Контрагент=Иванов(<СправочникСсылка.Контрагенты>);Кол3=1000 
//
&НаКлиенте
Функция ПривестиТаблицуГеркина(Источник, КолонкиИсключаемыеИзЗаменыСсылок = Неопределено, Приемник = Неопределено)
	
	Если Приемник = Неопределено Тогда
		Приемник = Новый Массив;				
	КонецЕсли; 
	
	КолонкиИЗС = Новый Соответствие;
	Если ЗначениеЗаполнено(КолонкиИсключаемыеИзЗаменыСсылок) Тогда
		СписокКолонок = РазложитьСтрокуВМассивПодстрок(КолонкиИсключаемыеИзЗаменыСсылок, ",");				
		Для каждого ИмяКолонки Из СписокКолонок Цикл
			КолонкиИЗС.Вставить(ИмяКолонки, Истина);			
		КонецЦикла; 
	КонецЕсли; 	
	
	ТипБулево = Новый ОписаниеТипов("Булево");
	КолонкиИсточника = Источник[0];
	СоответствиеЗначенийПеременных = СоответствиеЗначенийПеременных();
	Для Индекс = 1 По Источник.ВГраница() Цикл
		ЗаписьИсточника = Источник[Индекс];
		
		Запись = Новый Структура;		
		Для каждого ОписаниеКолонки Из КолонкиИсточника Цикл
			ИмяКолонкиИсточника = ОписаниеКолонки.Ключ;
			ИмяКолонкиПриемника = ОписаниеКолонки.Значение;
			
			Попытка
				ЗначениеИсточника = ЗаписьИсточника[ИмяКолонкиИсточника];
			Исключение
			    ТекстИсключения = "Ошибка форматирования таблицы геркина: " +
				"колонка " + ИмяКолонкиПриемника + " (" + ИмяКолонкиИсточника +
				") не обнаружена. " + ТекстРекомендацииПриОшибкеКолонокГеркина();
				
				ВызватьИсключение ТекстИсключения;
			КонецПопытки;			
			
			ЗначениеВРезультат = Неопределено;
			Если ТипЗнч(ЗначениеИсточника) = Тип("Строка") Тогда
				ЗначениеИсточника = СокрЛП(ЗначениеИсточника);
				ЗначениеИсточникаНРег = нРег(ЗначениеИсточника); 
				
				Если ЗначениеИсточникаНРег = "истина" ИЛИ ЗначениеИсточникаНРег = "ложь" Тогда
					ЗначениеВРезультат = ТипБулево.ПривестиЗначение(ЗначениеИсточника);	
				КонецЕсли;						
				Если ЗначениеВРезультат = Неопределено Тогда
					ИсключитьКолонкуИзЗаменыСсылок = КолонкиИЗС.Получить(ИмяКолонкиПриемника) = Истина;
					Если НЕ ИсключитьКолонкуИзЗаменыСсылок И ТипЗнч(ЗначениеИсточника) = Тип("Строка") Тогда
						ЗначениеВРезультат = СоответствиеЗначенийПеременных.Получить(ЗначениеИсточникаНРег);
						
					КонецЕсли;					
				КонецЕсли;				
			КонецЕсли; 
			
			Если ЗначениеВРезультат = Неопределено Тогда
				ЗначениеВРезультат = ЗначениеИсточника;				
			КонецЕсли;
			Запись.Вставить(ИмяКолонкиПриемника, ЗначениеВРезультат);			
		КонецЦикла; 
		
		Приемник.Добавить(Запись); 
	КонецЦикла; 	
	
	Возврат Приемник;
	
КонецФункции
 
// Создает структуру, для параметризации метода "ТаблицаПоОписаниюГеркина", и помещает ее в временное
// хранилище для дальнейшей отправки на сервер
// 
// Параметры:
// 	Источник - Массив из Структура - таблица в описании геркина
// 	
// Возвращаемое значение:
// 	Строка - адрес в временном хранилище структуры "ПараметрыСоздания", с ключами:
// 	*Источник - Массив Из Строка - таблица в описании геркина, см. описание метода 
// 	ТаблицаПоОписаниюГеркина
// 	*СоответствиеЗначенийПеременных - Соответствие - см. СоответствиеЗначенийПеременных 
//
&НаКлиенте
Функция АдресПараметровСозданияТаблицыПоОписаниюГеркина(Источник)
	
	ПараметрыСоздания = Новый Структура;
	ПараметрыСоздания.Вставить("Источник", Источник);
	
	Результат = ПоместитьВоВременноеХранилище(ПараметрыСоздания
		, УникальныйИдентификатор);
		
	Возврат Результат;		
		
КонецФункции 

// Создает таблицу значений по приведенной таблице геркина
// 
// Параметры:
// 	АдресПараметров - Строка - адрес в временном хранилище структуры, результата метода 
// 	"АдресПараметровСозданияТаблицыПоОписаниюГеркина"
// 	КакАдресВХ - Булево - поместить созданную таблицу в временное хранилище, и вернуть адрес
// 	УИДФормы - Неопределено, УникальныйИдентификатор - уникальный идентификатор формы инициатора, имеет
// 	смысл только при указании параметра "КакАдресВХ" в Истина.
// 	
// Возвращаемое значение:
// - ТаблицаЗначений - таблица по описанию геркина
// - Строка - адрес в временном хранилище созданной таблицы, для передачи на клиент
// 
&НаСервере
Функция ТаблицаПоОписаниюГеркина(Знач АдресПараметров, Знач КакАдресВХ, Знач УИДФормы = Неопределено)
	ПараметрыСоздания = ПолучитьИзВременногоХранилища(АдресПараметров);		
	
	Источник = ПараметрыСоздания.Источник;
	
	ТаблицаПоИсточнику = Новый ТаблицаЗначений;
	КолонкиЭталона = Источник[0];	
	
	Для Индекс = 0 По Источник.ВГраница() Цикл 
		СтрокаРезультат = ТаблицаПоИсточнику.Добавить();
		Для каждого КлючИЗначение Из КолонкиЭталона Цикл
			ИмяКолонкиИсточник = КлючИЗначение.Ключ;
			ИмяКолонкиПриемник = КлючИЗначение.Значение;

			ЗаписьИсточника = Источник[Индекс];
			ЗначениеИсточника = Неопределено;
			ЗаписьИсточника.Свойство(ИмяКолонкиИсточник, ЗначениеИсточника);
			
			Если Индекс = 0 Тогда
				ТаблицаПоИсточнику.Колонки.Добавить(ИмяКолонкиПриемник);
			КонецЕсли;				
			СтрокаРезультат[ИмяКолонкиПриемник] = ЗначениеИсточника;
		КонецЦикла; 		
	КонецЦикла; 
	
	Если КакАдресВХ Тогда
		Результат = ПоместитьВоВременноеХранилище(ТаблицаПоИсточнику, УИДФормы);
	Иначе
		Результат = ТаблицаПоИсточнику;		
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#Область ОписаниеРеквизитов

&НаКлиенте
Функция КлассВидТипаСсылки(Ссылка)
	ТипСсылки = ТипЗнч(Ссылка);
	КэшКлиент = КэшКлиент();	
	Если НЕ КэшКлиент.Свойство("КлассыВидыСсылокПоТипам") Тогда
		КэшКлиент.Вставить("КлассыВидыСсылокПоТипам", Новый Соответствие);		
	КонецЕсли; 
	
	Результат = КэшКлиент.КлассыВидыСсылокПоТипам.Получить(ТипСсылки);
	Если Результат = Неопределено Тогда
		Результат = КлассВидТипаСсылкиНаСервере(ТипСсылки);		
		КэшКлиент.КлассыВидыСсылокПоТипам.Вставить(ТипСсылки, Результат);
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция КлассВидТипаСсылкиНаСервере(Знач ТипСсылки)
	
	МетаОбъект = Метаданные.НайтиПоТипу(ТипСсылки);
	КлассыОбъектов = КлассыОбъектовКлиентСервер();
	
	КлассТипа = Неопределено;
	Для каждого КлючИЗначение Из КлассыОбъектов Цикл
		Класс = КлючИЗначение.Ключ;
		МетаКласс = Метаданные[Класс];		
		Если МетаКласс.Содержит(МетаОбъект) Тогда
			КлассТипа = Класс;
			Прервать;			
		КонецЕсли; 		
	КонецЦикла; 
	
	Если КлассТипа = Неопределено Тогда
		ВызватьИсключение "Не поддерживаемый класс " + МетаОбъект.ПолноеИмя();		
	КонецЕсли; 
	
	Результат = Новый Структура;
	Результат.Вставить("Класс", КлассТипа);
	Результат.Вставить("Вид", МетаОбъект.Имя);
	
	Возврат Результат;
	
КонецФункции

// Описание реквизитов объекта вида в виде структуры, предназанчена для унификации описания метаданного
// с последующим использованием на клиенте 
// 
// Параметры:
// 	Класс - Строка - класс объекта конфигурации
// 	Вид - Строка - вид объекта класса
// 	
// Возвращаемое значение:
// 	Структура - где ключи это имена реквизитов, значения - структура, см. НовоеОписаниеРеквизита.
// 	Субколлекции располагаются в ключах с именем класса субколлекции, на первом уровне. Субколлекция
// 	описывается как структура, с ключами - именами реквизитов субколлекций, значением такого ключа
// 	также будет структура, описывающая колонки. Ключ - имя колонки, значение - структура,
// 	см. НовоеОписаниеКолонкиРеквизита
// 	Например:
// 	Для документа "ЗаявкаКлиента" с реквизитами "Клиент, Сумма", табличной частью "Заказ" с реквизитами
// 	"Номенклатура,Сумма", и движением по регистру сведений "Заявки":
// 	Клиент=<ОписаниеРеквизита>
// 	Сумма=<ОписаниеРеквизита>
// 	ТабличныеЧасти=Структура
//  	Заказ=Структура
// 	 		Номенклатура=<ОписаниеКолонкиРеквизита>
// 	 		Сумма=<ОписаниеКолонкиРеквизита>
// 	Движения
// 		Заявки=Структура
//	 	 	Номенклатура=<ОписаниеКолонкиРеквизита>
//	 	 	Сумма=<ОписаниеКолонкиРеквизита>    
//
&НаКлиенте
Функция ОписаниеРеквизитов(Класс, Вид)
	КэшКлиент = КэшКлиент();
	Если НЕ КэшКлиент.Свойство("ОписанияРеквизитовВида") Тогда
		КэшКлиент.Вставить("ОписанияРеквизитовВида", Новый Соответствие);		
	КонецЕсли; 
	
	Ключ = Класс + "_" + Вид;
	Результат = КэшКлиент.ОписанияРеквизитовВида.Получить(Ключ);
	Если Результат = Неопределено Тогда
		Результат = ОписаниеРеквизитовВидаНаСервере(Класс, Вид);
		
		КэшКлиент.ОписанияРеквизитовВида.Вставить(Ключ, Результат);		
	КонецЕсли; 
	
	Возврат Результат;
		
КонецФункции
 
&НаСервере
Функция ОписаниеРеквизитовВидаНаСервере(Знач Класс, Знач Вид)
	
	КлассыОбъектов = КлассыОбъектовКлиентСервер();
	Если НЕ КлассыОбъектов.Свойство(Класс) Тогда
		ВызватьИсключение "Неподдерживаемый, либо ошибочный класс """ + Класс + """";		
	КонецЕсли; 
	МетаКласс = Метаданные[Класс];
		
	МетаВид = МетаКласс.Найти(Вид);
	Если МетаВид = Неопределено Тогда
		ВызватьИсключение "Неподдерживаемый, либо ошибочный вид """ + Класс + "." + Вид + """";		
	КонецЕсли; 
	
	Если Класс = КлассыОбъектов.РегистрыСведений Тогда
		ЭтоПодчиненныйРС = МетаВид.ПериодичностьРегистраСведений =
			Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.ПозицияРегистратора;
		Если ЭтоПодчиненныйРС Тогда
			ВызватьИсключение "Нельзя использовать регистр сведений, подчиненный регистратору: """ + Вид + """";			
		КонецЕсли; 			
	КонецЕсли; 	
	
	Результат = ОписаниеРеквизитовМетаданного(МетаВид);		
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция ОписаниеРеквизитовМетаданного(МетаВид)
		
	Результат = Новый Структура;
	
	ЕстьИерархия = ЕстьИерархия(МетаВид.СтандартныеРеквизиты);
	ИспользованиеРеквизитов = ИспользованиеРеквизитов();
	   
	ИсключаемыеРеквизиты = "ПометкаУдаления,Код,Номер,Предопределенный,Активность";	
	КлассыРеквизитов = КлассыРеквизитовСервер();	
	Для каждого КлассРеквизитов Из КлассыРеквизитов.Список Цикл
		Если НЕ ЕстьРеквизитИлиСвойствоОбъекта(МетаВид, КлассРеквизитов) Тогда
			Продолжить;			
		КонецЕсли; 	
		
		ЭтоКлассРеквизиты = КлассРеквизитов = КлассыРеквизитов.Реквизиты;
		ЭтоКлассТабЧасти = КлассРеквизитов = КлассыРеквизитов.ТабличныеЧасти;
		ПолучатьИспользование = ЕстьИерархия 
			И (ЭтоКлассРеквизиты ИЛИ ЭтоКлассТабЧасти);
			
		ЭтоДвижения = КлассРеквизитов = КлассыРеквизитов.Движения;
		
		МетаРеквизиты = МетаВид[КлассРеквизитов];
		Для каждого МетаРеквизит Из МетаРеквизиты Цикл
			Если Найти(ИсключаемыеРеквизиты, МетаРеквизит.Имя) Тогда
				Продолжить;				
			КонецЕсли; 
			
			ОписаниеРеквизита = НовоеОписаниеРеквизита();
			ОписаниеРеквизита.Имя = МетаРеквизит.Имя;			
			ОписаниеРеквизита.Класс = КлассРеквизитов;			
			Если ПолучатьИспользование Тогда
				ОписаниеРеквизита.Использование = "" + МетаРеквизит.Использование;
			Иначе
				ОписаниеРеквизита.Использование = ИспользованиеРеквизитов.ДляГруппыИЭлемента;
			КонецЕсли; 				
			ОписаниеРеквизита.Синоним = МетаРеквизит.Синоним;
			
			Если ЭтоКлассТабЧасти ИЛИ ЭтоДвижения Тогда				
				СубКоллекция = Неопределено;
				Если НЕ Результат.Свойство(КлассРеквизитов, СубКоллекция) Тогда
					СубКоллекция = Новый Структура;
					Результат.Вставить(КлассРеквизитов, СубКоллекция);
					
				КонецЕсли; 
				
				ВставитьОписаниеКолонокСубколлекции(ЭтоДвижения
					, КлассыРеквизитов
					, МетаРеквизит
					, ОписаниеРеквизита);
				
				СубКоллекция.Вставить(МетаРеквизит.Имя, ОписаниеРеквизита);
				
			Иначе
				ОписаниеРеквизита.Тип = МетаРеквизит.Тип;
				ОписаниеРеквизита.ПустоеЗначение = МетаРеквизит.Тип.ПривестиЗначение();								
				Результат.Вставить(ОписаниеРеквизита.Имя, ОписаниеРеквизита);
			КонецЕсли; 			
						
		КонецЦикла; 
 		
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Процедура ВставитьОписаниеКолонокСубколлекции(ЭтоДвижения, КлассыРеквизитов, МетаРеквизит, ОписаниеРеквизита)
				
	Если ОписаниеРеквизита.Колонки = Неопределено Тогда
		ОписаниеРеквизита.Колонки = Новый Структура;				
	КонецЕсли;
	
	КлассыСубколлекции = Новый Массив;
	Если ЭтоДвижения Тогда
		КлассыСубколлекции.Добавить(КлассыРеквизитов.Измерения);
		КлассыСубколлекции.Добавить(КлассыРеквизитов.Ресурсы);					
	КонецЕсли; 
	КлассыСубколлекции.Добавить(КлассыРеквизитов.СтандартныеРеквизиты);
	КлассыСубколлекции.Добавить(КлассыРеквизитов.Реквизиты);
	
	Для каждого ИмяСубКласса Из КлассыСубколлекции Цикл					
		Для каждого МетаРеквизитСК Из МетаРеквизит[ИмяСубКласса] Цикл						
			Колонка = НовоеОписаниеКолонкиРеквизита();						
			Колонка.Имя = МетаРеквизитСК.Имя;
			Колонка.Синоним = МетаРеквизит.Синоним;
			Колонка.Класс = ИмяСубКласса;
			Колонка.ПустоеЗначение = МетаРеквизитСК.Тип.ПривестиЗначение();
			Колонка.Тип = МетаРеквизитСК.Тип;
			
			ОписаниеРеквизита.Колонки.Вставить(МетаРеквизитСК.Имя, Колонка);
		КонецЦикла; 					
	КонецЦикла; 	
КонецПроцедуры

#КонецОбласти 

#Область ПротоОбъект

// Структура, для описания в коде заполнения реквизитов и субколлекций (движений, табличных частей) 
// объекта вида класса. Список поддерживаемых классов см. КлассыОбъектовКлиентСервер 
// 
// Параметры:
// 	ОписаниеРеквизитов - Структура - см. ОписаниеРеквизитов
// 	
// Возвращаемое значение:
// 	Структура - ключи повторяют результат метода "ОписаниеРеквизитов" только для класса реквизитов 
// 	"Стандартные", а также субколлекций. Предназначена для последующего заполнения коде, вызывающем метод 
// 	см. НовоеОписаниеОбъекта  
//
&НаКлиенте
Функция ПротоОбъект(ОписаниеРеквизитов, ДобавлятьСтандартныеРеквизиты = Истина)
	
	КлассыРеквизитов = КлассыРеквизитовСервер();

	Результат = Новый Структура;
	Результат.Вставить("ОбменДанными", Истина);
	
	Для каждого КлючИЗначение Из ОписаниеРеквизитов Цикл
		ИмяРеквизита = КлючИЗначение.Ключ;
		ОписаниеРеквизита = КлючИЗначение.Значение;
		
		Если ИмяРеквизита = КлассыРеквизитов.ТабличныеЧасти
				ИЛИ ИмяРеквизита = КлассыРеквизитов.Движения Тогда				
			Субколлекция = Новый Структура;
			Результат.Вставить(ИмяРеквизита, Субколлекция);				
				
			Для каждого КиЗ_СубКоллекция Из ОписаниеРеквизита Цикл
				ИмяСК = КиЗ_СубКоллекция.Ключ;
				ОписаниеСК = КиЗ_СубКоллекция.Значение;
				
				ОписаниеПротоСК = Новый Структура;
				ОписаниеПротоСК.Вставить("Колонки", СкопироватьСтруктуру(ОписаниеСК.Колонки));
				ОписаниеПротоСК.Вставить("Строки", Новый Массив);				
				ОписаниеПротоСК.Вставить("Класс", ИмяРеквизита);
				ОписаниеПротоСК.Вставить("Имя", ИмяСК);
				
				Субколлекция.Вставить(ИмяСК, ОписаниеПротоСК);
			КонецЦикла; 
		Иначе
			Если ДобавлятьСтандартныеРеквизиты Тогда
				Если ОписаниеРеквизита.Класс = КлассыРеквизитов.СтандартныеРеквизиты Тогда
					Результат.Вставить(ИмяРеквизита, ОписаниеРеквизита.ПустоеЗначение);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;	
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#Область КодСоздания
 
&НаКлиенте
Функция КодСозданияЗаписи(ОписаниеОбъекта, ИмяПеременнойвКоде)
	
	ВидыЗаполнения = ВидыЗаполнения();
		
	ПерваяСтрока = КодСоздания_ПерваяСтрока(ИмяПеременнойвКоде); 
	
	Результат = Новый Структура;
	Если ЕстьИерархия(ОписаниеОбъекта.ПротоОбъект) Тогда
		КодСозданияГруппы = ПерваяСтрока + Символы.ПС +
		КодСозданияРеквизитов(ОписаниеОбъекта, ИмяПеременнойвКоде, ВидыЗаполнения.Группа);
		
		Результат.Вставить(ВидыЗаполнения.Группа, КодСозданияГруппы);
	КонецЕсли; 
	
	КодСозданияЭлемента = ПерваяСтрока + Символы.ПС +
	КодСозданияРеквизитов(ОписаниеОбъекта, ИмяПеременнойвКоде, ВидыЗаполнения.Запись);
	
	Результат.Вставить(ВидыЗаполнения.Запись, КодСозданияЭлемента);	
	
	Возврат Результат;
	
КонецФункции 

&НаКлиенте
Функция КодСоздания_ПерваяСтрока(ИмяПеременнойвКоде)	
	Результат = ИмяПеременнойвКоде + " = ОписаниеОбъекта.ПротоОбъект;";		
	Возврат Результат;	
КонецФункции

&НаКлиенте
Функция КодСозданияРеквизитов(ОписаниеОбъекта, ИмяПеременнойвКоде, ВидЗаполнения)
	 
	ЭтоЗапись = ВидЗаполнения = ВидыЗаполнения().Запись;
	КлассыРеквизитов = КлассыРеквизитовКлиент();
	
	Результат = "";
	Для каждого ОписаниеРеквизитов Из ОписаниеОбъекта.ОписаниеРеквизитов Цикл
		Разделитель = ?(ЗначениеЗаполнено(Результат), Символы.ПС, "");
		ОписаниеРеквизита = ОписаниеРеквизитов.Значение; 
		ИмяРеквизита = ОписаниеРеквизита.Имя;
		
		ЭтоСубКоллекция = ИмяРеквизита = КлассыРеквизитов.ТабличныеЧасти
			ИЛИ ИмяРеквизита = КлассыРеквизитов.Движения;
		СтрокаКода = "";				
		Если ЭтоСубКоллекция Тогда
			СтрокаКода = КодУстановкиРеквизитовСубколлекции(ОписаниеРеквизита, ЭтоЗапись);
			
		Иначе
			Если НЕ ИспользоватьРеквизит(ОписаниеРеквизита, ЭтоЗапись) Тогда
				Продолжить;				
			КонецЕсли; 
			
			Если ИмяРеквизита = "ЭтоГруппа" И НЕ ЭтоЗапись Тогда
				СтрокаКода = ИмяПеременнойвКоде + ".ЭтоГруппа = Истина;";
			Иначе
				Если ОписаниеРеквизита.Класс = КлассыРеквизитов.СтандартныеРеквизиты Тогда
					СтрокаКода = КодУстановкиСтандартногоРеквизита(ОписаниеРеквизита, ОписаниеОбъекта, ИмяПеременнойвКоде);					
				Иначе
					СтрокаКода = КодВставки(ИмяПеременнойвКоде, ОписаниеРеквизита);
				КонецЕсли; 				
			КонецЕсли; 
			
			Если Найти("Ссылка, ИмяПредопределенныхДанных", ИмяРеквизита) Тогда
				СтрокаКода = " // " + СтрокаКода;
				
			КонецЕсли; 
			
		КонецЕсли; 
		
		Если НЕ ЗначениеЗаполнено(СтрокаКода) Тогда
			Продолжить;			
		КонецЕсли; 		
	
		Результат = Результат + Разделитель + СтрокаКода;
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция КодУстановкиРеквизитовСубколлекции(ОписаниеРеквизита, ЭтоЗапись)
	Результат = "";
	
	ЭтоДвижения = ОписаниеРеквизита.Имя = КлассыРеквизитовКлиент().Движения;	
	ИмяКлассаВКод = ?(ЭтоДвижения, ", " + Обрамить(ОписаниеРеквизита.Имя), "");
	
	Счетчик = 1; 
	Всего = ОписаниеРеквизита.Количество();
	Для каждого ОписаниеСубколлекций Из ОписаниеРеквизита Цикл
		Счетчик = Счетчик + 1;
		ИмяСК = ОписаниеСубколлекций.Ключ;
		ОписаниеКоллекции = ОписаниеСубколлекций.Значение;
		
		Если НЕ ИспользоватьРеквизит(ОписаниеКоллекции, ЭтоЗапись) Тогда
			Продолжить;				
		КонецЕсли; 				
		
		ИмяСКВКавычках = Обрамить(ИмяСК); 
		Результат = Результат + Символы.ПС +
		"// " + ОписаниеКоллекции.Класс + ": " + ОписаниеКоллекции.Синоним + 
		Символы.ПС + ПодставитьПараметрыВСтроку("Запись = Инициатор.ДобавитьЗапись(ОписаниеОбъекта, %1%2);"
			, ИмяСКВКавычках
			, ИмяКлассаВКод);
			
		Для каждого ОписаниеКолонок Из ОписаниеКоллекции.Колонки Цикл
			ОписаниеКолонки = ОписаниеКолонок.Значение;
			
			КодВставки = КодВставки("Запись", ОписаниеКолонки);
			Результат = Результат + Символы.ПС + КодВставки;
		КонецЦикла; 
		
		Если Счетчик < Всего Тогда
			Результат = Результат + Символы.ПС;
		КонецЕсли; 				
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Функция КодУстановкиСтандартногоРеквизита(ОписаниеРеквизита, ОписаниеОбъекта, ИмяПеременнойвКоде)
	ИмяРеквизита = ОписаниеРеквизита.Имя;
	Результат = "";
	Если ИмяРеквизита = "Ссылка" Тогда
		СсылкаВида = ПолучитьСсылкуВида(ОписаниеОбъекта.Класс, ОписаниеОбъекта.Вид);
		УИД = СсылкаВида.УникальныйИдентификатор();
		Результат = ИмяПеременнойвКоде +
		".Ссылка = " + Обрамить(УИД) + ";";
	ИначеЕсли ИмяРеквизита = "Наименование" Тогда
		Результат = ИмяПеременнойвКоде +
		".Наименование = """ + ИдентификаторВПредставление(ИмяПеременнойвКоде) + """;";
		
	Иначе
		Результат = КодПрисваивания(ИмяПеременнойвКоде, ОписаниеРеквизита);
	КонецЕсли; 
			
	Возврат Результат;	
	
КонецФункции

&НаКлиенте
Функция КодПрисваивания(ИмяПеременнойПриемника, ОписаниеРеквизита)
	ОписаниеКодаЗначения = КодЗначенияРеквизита(ОписаниеРеквизита);
	Результат = ПодставитьПараметрыВСтроку("%1.%2 = %3; %4"
	, ИмяПеременнойПриемника
	, ОписаниеРеквизита.Имя
	, ОписаниеКодаЗначения.Код
	, ОписаниеКодаЗначения.Комментарий);
	
	Возврат Результат;
		
КонецФункции 

&НаКлиенте
Функция КодВставки(ИмяПеременнойПриемника, ОписаниеРеквизита)
	
	ИмяРеквизитаВКавычках = Обрамить(ОписаниеРеквизита.Имя); 
	ОписаниеКодаЗначения = КодЗначенияРеквизита(ОписаниеРеквизита);
	Результат = ПодставитьПараметрыВСтроку("%1.Вставить(%2, %3); %4"
	, ИмяПеременнойПриемника
	, ИмяРеквизитаВКавычках
	, ОписаниеКодаЗначения.Код
	, ОписаниеКодаЗначения.Комментарий);

	Возврат Результат;
	
КонецФункции 

&НаКлиентеНаСервереБезКонтекста
Функция Обрамить(Стр, Начало = """", Конец = """")
	Возврат Начало + Стр + Конец; 	
КонецФункции
 
&НаКлиенте
Функция ИспользоватьРеквизит(ОписаниеРеквизита, ЭтоЗапись)
	ИспользованиеРеквизитов = ИспользованиеРеквизитов();

	Результат = Истина;
	Если ОписаниеРеквизита.Использование <> ИспользованиеРеквизитов.ДляГруппыИЭлемента Тогда
		ИспользоватьДляГруппы = ОписаниеРеквизита.Использование = ИспользованиеРеквизитов.ДляГруппы;
		ИспользоватьДляЭлемента = ОписаниеРеквизита.Использование = ИспользованиеРеквизитов.ДляЭлемента;
		Если ЭтоЗапись Тогда
			Результат = ИспользоватьДляЭлемента;
			
		Иначе 
			Результат = ИспользоватьДляГруппы;
			
		КонецЕсли; 			
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции
 
&НаКлиенте
Функция КодЗначенияРеквизита(ОписаниеРеквизита)
	
	КэшКлиент = КэшКлиент();
	Если ОписаниеРеквизита.ПустоеЗначение = Неопределено Тогда
		Результат = НовыйРезультатКодаЗначения("Неопределено");
		Возврат Результат;		
	КонецЕсли; 
	
	Если НЕ КэшКлиент.Свойство("КодЗначенийРеквизитов") Тогда
		КэшКлиент.Вставить("КодЗначенийРеквизитов", Новый Соответствие);
		
	КонецЕсли; 	
	
	Результат = КэшКлиент.КодЗначенийРеквизитов.Получить(ОписаниеРеквизита.ПустоеЗначение);
	Если Результат = Неопределено Тогда
		Тип = ОписаниеРеквизита.Тип.Типы()[0];
		ЭтоПростойТип = Истина;
		Комментарий = "";
		Если Тип = Тип("Число") Тогда
			Код = "0";
			
		ИначеЕсли Тип = Тип("Строка") Тогда 
			Код = """""";
			
		ИначеЕсли Тип = Тип("Дата") Тогда 
			Код = "Дата(1, 1, 1)";
			
		ИначеЕсли Тип = Тип("Булево") Тогда 
			Код = "Ложь";
		Иначе
			ЭтоПростойТип = Ложь; 
			Комментарий = СтроковоеПредставлениеТипа(Тип);			
			Код = "Неопределено";
		КонецЕсли; 
		
		Результат = НовыйРезультатКодаЗначения(Код, Комментарий, ЭтоПростойТип);
		КэшКлиент.КодЗначенийРеквизитов.Вставить(ОписаниеРеквизита.ПустоеЗначение, Результат);		
	КонецЕсли; 
	
	Если Результат.ЭтоПростойТип Тогда
		Результат.Комментарий = ОписаниеРеквизита.Синоним;		
	КонецЕсли; 
	Если ЗначениеЗаполнено(Результат.Комментарий) Тогда
		Если Лев(Результат.Комментарий, 2) <> "//" Тогда
			 Результат.Комментарий = "// " + Результат.Комментарий;
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция НовыйРезультатКодаЗначения(Код, Комментарий = "", ЭтоПростойТип = Ложь)
	Результат = Новый Структура;
	Результат.Вставить("Код", Код);
	Результат.Вставить("Комментарий", Комментарий);
	Результат.Вставить("ЭтоПростойТип", ЭтоПростойТип);
	
	Возврат Результат;
КонецФункции
 
&НаСервере
Функция СтроковоеПредставлениеТипа(Знач Тип)
	МетаТип = Метаданные.НайтиПоТипу(Тип);
	Если МетаТип = Неопределено Тогда
		Результат = "" + Тип;
	Иначе
		Результат = МетаТип.ПолноеИмя();
	КонецЕсли;
	
	Возврат Результат;	
КонецФункции

#КонецОбласти 

#Область Конструкторы

&НаСервереБезКонтекста
Функция НовоеОписаниеЗначенияКонстанты()
	Результат = Новый Структура;
	Результат.Вставить("Адрес", "");
	Результат.Вставить("ПомешатьВХранилище", Ложь);
	Результат.Вставить("УстанавливатьПараметрСеанса", Ложь);
	Результат.Вставить("ИмяСценария", "");
	
	Возврат Результат;
КонецФункции 

&НаСервере
Функция НовоеОписаниеКолонкиРеквизита()
	Результат = Новый Структура;
	Результат.Вставить("Имя");
	Результат.Вставить("Синоним");
	Результат.Вставить("Класс");
	Результат.Вставить("ПустоеЗначение");
	Результат.Вставить("Тип");
	Возврат Результат;
КонецФункции 

&НаСервере
Функция НовоеОписаниеРеквизита()
	Результат = Новый Структура;
	Результат.Вставить("Имя");
	Результат.Вставить("Синоним");
	Результат.Вставить("Класс");
	Результат.Вставить("Использование");
	Результат.Вставить("ПустоеЗначение");
	Результат.Вставить("Тип");
	Результат.Вставить("Колонки");
	
	Возврат Результат;
		
КонецФункции 

// Создает структуру с описанием результата метода проверки объекта, либо манипуляции с объектом
// 
// Возвращаемое значение:
//  Структура
//	 *Ошибка - Булево - либо флаг проверки, либо флаг того что при манипуляции с объектом возникло исключение
//   *Описание - Строка - описание результата неудачной проверки, либо ошибки при манипуляции с объектом
//
&НаКлиентеНаСервереБезКонтекста
Функция НовыйРезультатМетода()
	Результат = Новый Структура;
	Результат.Вставить("Ошибка", Истина);
	Результат.Вставить("Описание", "");
	
	Возврат Результат;
КонецФункции 

&НаКлиенте
Функция НоваяСтруктураОписанияОбъекта()
	
	Результат = Новый Структура;	
	Результат.Вставить("ОписаниеРеквизитов");
	Результат.Вставить("Класс");
	Результат.Вставить("Вид");
	Результат.Вставить("ИмяПеременной");
	Результат.Вставить("ПротоОбъект");	
	Результат.Вставить("ЗаписиНабора", Новый Массив);
	Результат.Вставить("ВызовЗаполнения", Ложь);		
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#КонецОбласти