#Область ОписаниеПеременных

Перем РезультатыСравненияТаблиц Экспорт;
Перем СтатусыРезультатаТестирования Экспорт;
Перем ПараметрыОтчетаУФ;
Перем ОтчетВРежимеУФ;
Перем ЭтоLinux;
Перем Регулярка;
Перем РазницаВМилисекундахМеждуЮниксИНачалЭпохи;
Перем КешСтрокаПробелов;

#КонецОбласти

// Служебная строка. Не удалять. #КонецОбласти ОписаниеПеременных

#Область ОбщиеПроцедурыИФункции

Функция СоздатьДанныеПоМакетам(ТестОбъект, ИменаМакетов) Экспорт
	Сериализатор = Плагин("СериализаторMXL");
	Возврат Сериализатор.СоздатьДанныеПоМакетам(ТестОбъект, ИменаМакетов);
КонецФункции

Функция СоздатьДанныеПоТабличномуДокументу(ТабличныйДокументИлиМассивТабличныхДокументов, 
		РежимыЗагрузкиИлиИмяКолонкиЗамещения = Неопределено, 
		ИмяКолонкиЗамещения = Неопределено) Экспорт

	Сериализатор = Плагин("СериализаторMXL");
	Возврат Сериализатор.СоздатьДанныеПоТабличномуДокументу(ТабличныйДокументИлиМассивТабличныхДокументов, 
		РежимыЗагрузкиИлиИмяКолонкиЗамещения, 
		ИмяКолонкиЗамещения);
КонецФункции

// Удаляет созданные элементы (Справочники, Документы, Пользователи ИБ), регистры сведений не чистит - есть тесты
Функция УдалитьСозданныеДанные(Данные) Экспорт
	Сериализатор = Плагин("СериализаторMXL");
	Возврат Сериализатор.УдалитьСозданныеДанные(Данные);
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункции

Функция ВстроенныеБиблиотеки() Экспорт
	Спс = Новый СписокЗначений;
	
	// Служебная строка. Не удалять. Тут надо добавить имена форм, которые являются встроенными библиотеками

	Возврат Спс;
КонецФункции	

Функция СтруктураОбщихНастроек(НастрокиВыгрузки = Ложь, НастройкиЗагрузки = Ложь) Экспорт 
	
	Настройки = Новый Структура;
	Настройки.Вставить("Version", "");	
	Настройки.Вставить("Lang", "");	
	Настройки.Вставить("DebugLog", "");
	Настройки.Вставить("ВерсияVA", "");
	Настройки.Вставить("КаталогФич", "");	
	Настройки.Вставить("ДобавлятьКИмениСценарияУсловияВыгрузки", Ложь);
	Настройки.Вставить("ЗаписыватьВидеоВыполненияТестов", Ложь);
	Настройки.Вставить("КоличествоКадровВидеоВыполненияТестов", 5);
	Настройки.Вставить("КомандаЗаписиВидеоВыполненияТестов", "ffmpeg");
	Настройки.Вставить("КаталогДляЗаписиВидеоВыполненияТестов", "");
	Настройки.Вставить("ИмяТекущейСборки", "");
	Настройки.Вставить("ЗагрузкаФичПриОткрытии", "Загружать");		
	Настройки.Вставить("ВерсияПлатформыДляГенерацииEPF", "");	
	Настройки.Вставить("ДополнительныеПараметры", "");
	Настройки.Вставить("КомандаОткрытияФичиВТекстовомРедакторе", "");
	Настройки.Вставить("ПоставщикПользовательскихНастроек", "NotUse");
	Настройки.Вставить("АдресПользовательскихНастроек", "");
	Настройки.Вставить("ИспользоватьРедакторVanessaEditor", Истина);
	Настройки.Вставить("ТемаРедактораVanessaEditor", "vs");
	Настройки.Вставить("ИспользоватьДанныеТекущейФормыПриПодбореШагов", Ложь);
	Настройки.Вставить("ПоказыватьСтрокиПодсценариевVanessaEdittor", Истина);
	Настройки.Вставить("ПоказыватьЗначенияПеременныхВСтрокахРедактора", Истина);
	Настройки.Вставить("ОткрыватьНачальнуюСтраницуПриЗапуске", Истина);
	Настройки.Вставить("ПоказыватьМиниатюруКода", Истина);
	Настройки.Вставить("ЗаменятьТабыНаПробелы", Ложь);
	Настройки.Вставить("ВычислятьВыраженияВФигурныхСкобках", Ложь);
	
	// Выполнение сценариев
	ВыполнениеСценариев = Новый Структура;
	ВыполнениеСценариев.Вставить("ВыполнятьШагиАссинхронно", Ложь);
	ВыполнениеСценариев.Вставить("ИнтервалВыполненияШагаЗаданныйПользователем", 0);
	ВыполнениеСценариев.Вставить("ОбновлятьСтатистикуВДереве", Истина);
	ВыполнениеСценариев.Вставить("ОбновлятьДеревоПриНачалеВыполненияСценария", Истина);
	ВыполнениеСценариев.Вставить("ОстановкаПриВозникновенииОшибки", Ложь);
	ВыполнениеСценариев.Вставить("ПоказыватьНомерСтрокиДереваПриВозникновенииОшибки", Ложь);
	ВыполнениеСценариев.Вставить("ПриравниватьPendingКFailed", Ложь);
	ВыполнениеСценариев.Вставить("РазличатьBrokenИFailedПоКлючевомуСловуТогда", Ложь);
	ВыполнениеСценариев.Вставить("ЗапрещатьПерезаписыватьПеременные", Ложь);
	ВыполнениеСценариев.Вставить("ОбновлятьТаблицыФормыПриПолученииЗначения", Ложь);
	ВыполнениеСценариев.Вставить("ПолучатьМакетыСПомощьюРасширенияVAExtension", Ложь);
	ВыполнениеСценариев.Вставить("ВыполнятьSleepЧерезPing", Ложь);
	ВыполнениеСценариев.Вставить("ТаймаутДляАсинхронныхШагов", 10);
	ВыполнениеСценариев.Вставить("КоличествоСекундПоискаОкна", 10);
	ВыполнениеСценариев.Вставить("КоличествоПопытокВыполненияДействия", 3);
	ВыполнениеСценариев.Вставить("БезопасноеВыполнениеШагов", Ложь);
	ВыполнениеСценариев.Вставить("ПаузаПриОткрытииОкна", 0);
	Настройки.Вставить("ВыполнениеСценариев", ВыполнениеСценариев);
	
	// Настройки клиентов тестирования
	КлиентТестирования = Новый Структура;
	КлиентТестирования.Вставить("ЗапускатьКлиентТестированияСМаксимизированнымОкном", Истина);
	КлиентТестирования.Вставить("ТаймаутЗапуска1С", 25);
	КлиентТестирования.Вставить("ДиапазонПортовTestclient", "");
	КлиентТестирования.Вставить("ЗакрыватьКлиентТестированияПринудительно", Истина);
	КлиентТестирования.Вставить("ОпределятьРеальныйПортНаКоторомЗапустилсяКлиентТестирования", Ложь);
	КлиентТестирования.Вставить("ПутьКadb", "");
	КлиентТестирования.Вставить("ПовторноЗапускатьСеансКлиентаТестированияПриПодключенииЕслиНеНайденЕгоПроцесс", Ложь);
	КлиентТестирования.Вставить("ИнтервалЗапускаПроцессаКлиентаТестирования", 100);
	КлиентТестирования.Вставить("ТаймаутПередПринудительнымЗакрытиемКлиентаТестирования", 10);
	КлиентТестирования.Вставить("МодальноеОкноПриЗапускеКлиентаТестированияЭтоОшибка", Истина);
	
	КлиентТестирования.Вставить("ЗапускатьТестКлиентВРежимеОтладки", Ложь);
	КлиентТестирования.Вставить("КлючиОтладки", "");
	КлиентТестирования.Вставить("АдресОтладчика", "");
	КлиентТестирования.Вставить("ДанныеКлиентовТестирования", Новый Массив);
	Настройки.Вставить("КлиентТестирования", КлиентТестирования);
	
	// Отчет Allure
	Настройки.Вставить("ДелатьОтчетВФорматеАллюр", Ложь);
	Allure = Новый Структура;
	Allure.Вставить("КаталогВыгрузкиAllure", "");
	Allure.Вставить("КаталогВыгрузкиAllureБазовый", "");
	Allure.Вставить("УровеньОтчета1", "");
	Allure.Вставить("УровеньОтчета2", "");
	Allure.Вставить("УровеньОтчета3", "");	
	Allure.Вставить("ГруппировкаTestSuites", "");	
	Allure.Вставить("ПрикладыватьКОтчетуAllureЖурналРегистрацииВыполненияСценария", Ложь);	
	Allure.Вставить("ПрикладыватьКОтчетуAllureДанныеОСостоянииАктивнойФормы", Ложь);	
	Allure.Вставить("ПрикладыватьКОтчетуAllureДанныеОЗначенияхПеременных", Ложь);	
	Allure.Вставить("ПрикладыватьФайлыMxlКОтчетуAllure", Истина);	
	Allure.Вставить("ПрикладыватьФайлыMxlСохраненныеВФорматеHTMLКОтчетуAllure", Истина);	
	Allure.Вставить("ПрикладыватьДополнительныеДанныеПриСравненииЗначенияСЭталономAllure", Ложь);	
	Allure.Вставить("ПодставлятьВОтчетеAllureЗначенияПеременных", Истина);	
	Allure.Вставить("ПрикладыватьКОтчетуAllureДанныеОСостоянииВсехФорм", Ложь);	
	Allure.Вставить("ПрикладыватьКОтчетуAllureДанныеОСетевыхСоединениях", Ложь);	
	Allure.Вставить("ПрикладыватьКОтчетуAllureДанныеОПроцессахОС", Ложь);	
	Allure.Вставить("ТегиПропускающиеСценарийAllure", "");	
	Allure.Вставить("КаталогОтносительноКоторогоНадоСтроитьИерархию", "");
	Allure.Вставить("ДанныеАллюрМеток", Новый Массив);
	Настройки.Вставить("ОтчетAllure", Allure);
	
	// Отчет JUnit
	Настройки.Вставить("ДелатьОтчетВФорматеjUnit", Ложь);
	Настройки.Вставить("СкриншотыjUnit", Ложь);
	JUnit = Новый Структура;
	JUnit.Вставить("КаталогВыгрузкиJUnit", "");
	Настройки.Вставить("ОтчетJUnit", JUnit);
	
	// Отчет Cucumber
	Настройки.Вставить("ДелатьОтчетВФорматеCucumberJson", Ложь);
	Cucumber = Новый Структура;
	Cucumber.Вставить("КаталогВыгрузкиCucumberJson", "");	
	Настройки.Вставить("ОтчетCucumber", Cucumber);
	
	// Отчет СППР
	Настройки.Вставить("ДелатьОтчетВФорматеСППР", Ложь);
	СППР = Новый Структура;
	СППР.Вставить("КаталогВыгрузкиСППР", "");
	Настройки.Вставить("ОтчетСППР", СППР);
	
	// Инструкции
	Настройки.Вставить("АвтонумерацияШагов", Ложь);
	
	// Инструкция HTML
	Настройки.Вставить("СоздаватьИнструкциюHTML", Ложь);
	ИнструкцияHTML = Новый Структура;	
	ИнструкцияHTML.Вставить("КаталогВыгрузкиИнструкцийHTML", "");
	Настройки.Вставить("ИнструкцияHTML", ИнструкцияHTML);
	
	// Инструкция Markdown
	Настройки.Вставить("СоздаватьИнструкциюMarkdown", Ложь);
	ИнструкцияMarkdown = Новый Структура;
	ИнструкцияMarkdown.Вставить("КаталогВыгрузкиИнструкцийMarkdown", "");
	Настройки.Вставить("ИнструкцияMarkdown", ИнструкцияMarkdown);
	
	Настройки.Вставить("ДелатьОтчетВоВнутреннемФормате");
	Настройки.Вставить("КаталогиБиблиотек", "");
	Настройки.Вставить("СписокТеговИсключение", Новый СписокЗначений);
	Настройки.Вставить("СписокТеговОтбор", Новый СписокЗначений);
	Настройки.Вставить("СписокСценариевДляВыполнения", Новый Массив);
	Настройки.Вставить("ДелатьЛогВыполненияСценариевВЖР", Ложь);
	Настройки.Вставить("ДелатьЛогВыполненияСценариевВТекстовыйФайл", Ложь);
	Настройки.Вставить("ВыводитьВЛогВыполнениеШагов", Ложь);
	Настройки.Вставить("ПодробныйЛогВыполненияСценариев", Ложь);
	Настройки.Вставить("ВыводитьЛогВКонсоль", Ложь);
	Настройки.Вставить("ЗвуковоеОповещениеПриОкончанииВыполненияСценария", Ложь);
	Настройки.Вставить("ПоказыватьОкноОстановкиВыполненияСценария", Истина);
	Настройки.Вставить("ПоказыватьОкноОстановкиЗаписиДействийПользователя", Истина);
	Настройки.Вставить("ОтображатьЗакладкиСверху", Ложь);
	Настройки.Вставить("ПоказыватьРазличияВРедактореОтдельно", Истина);
	Настройки.Вставить("ПроверкаСинтаксисаВРедакторе", Истина);
	Настройки.Вставить("ОтображениеТабуляцииИПробелов", 0);
	Настройки.Вставить("ДелатьЛогОшибокВТекстовыйФайл", Ложь);
	Настройки.Вставить("СобиратьДанныеОСостоянииАктивнойФормыПриОшибке", Ложь);
	Настройки.Вставить("СобиратьДанныеОСостоянииВсехФормПриОшибке", Ложь);
	Настройки.Вставить("СобиратьДанныеОСетевыхСоединениях", Ложь);
	Настройки.Вставить("СобиратьДанныеОПроцессахОС", Ложь);
	Настройки.Вставить("СобиратьДанныеОЗначенияхПеременных", Ложь);
	Настройки.Вставить("КомандаЗапускаБраузера", "");
	Настройки.Вставить("ИспользоватьБраузерПлюсWebSocket", Ложь);
	Настройки.Вставить("ЭмулироватьДвиженияМышкиVanessaExt", Ложь);
	Настройки.Вставить("ЭмулироватьВводКлавиатурыVanessaExt", Ложь);
	Настройки.Вставить("СмещениеПоГоризонталиДвиженияМышкиVanessaExt", 0);
	Настройки.Вставить("СмещениеПоВертикалиДвиженияМышкиVanessaExt", 0);
	Настройки.Вставить("КоличествоШаговПриДвиженииМышкиVanessaExt", 150);
	Настройки.Вставить("ПаузаМеждуШагамиПриДвиженииМышкиVanessaExt", 3);
	Настройки.Вставить("ПодсвечиватьКликМышкиВБраузереVanessaExt", Ложь);
	Настройки.Вставить("ЦветПодсветкиКликаМышкиVanessaExt", 255);
	Настройки.Вставить("РадиусПодсветкиКликаМышкиVanessaExt", 30);
	Настройки.Вставить("ДлительностьПодсветкиКликаМышкиVanessaExt", 12);
	Настройки.Вставить("ТолщинаПодсветкиКликаМышкиVanessaExt", 12);
	Настройки.Вставить("ПрозрачностьПодсветкиКликаМышкиVanessaExt", 127);
	Настройки.Вставить("ПоискКартинокСПомощьюКомпонентыVanessaExt", Истина);
	Настройки.Вставить("ПорогПоискаКартинки", 0.99);
	Настройки.Вставить("ИгнорироватьОшибкиПоискаЭлементовВБраузере", Ложь);
	Настройки.Вставить("ИспользоватьUIAutomation", Ложь);
	Настройки.Вставить("КоэффициентМасштабированияЭкрана", 1);
	Настройки.Вставить("ИмяФайлаЛогВыполненияСценариев", "");
	Настройки.Вставить("ИмяКаталогаЛогОшибок", "");
	Настройки.Вставить("КомандаСделатьСкриншот", "");
	Настройки.Вставить("ИспользоватьКомпонентуVanessaExt", Ложь);
	Настройки.Вставить("ИспользоватьПарсерGherkinИзКомпонентыVanessaExt", Ложь);
	Настройки.Вставить("ИспользоватьВнешнююКомпонентуДляСкриншотов", Ложь);
	Настройки.Вставить("СпособСнятияСкриншотовВнешнейКомпонентой", 0);
	Настройки.Вставить("ДелатьСкриншотПриВозникновенииОшибки", Ложь);
	Настройки.Вставить("СниматьСкриншотКаждогоОкна1С", Ложь);
	Настройки.Вставить("КаталогВыгрузкиСкриншотов", "");
	Настройки.Вставить("КаталогПроекта", "");
	Настройки.Вставить("МетаданныеБиблиотек", Новый СписокЗначений);
	Настройки.Вставить("КаталогКешОзвучкиДляИнтерактивнойСправки", "");
	Настройки.Вставить("СоздаватьФайлыОзвучкиДляСправки", Ложь);
	Настройки.Вставить("ПодключатьГорячуюКлавишуДляПолученияСправкиОбЭлементе", Истина);
	
	// Запись видео
	Настройки.Вставить("СоздаватьИнструкциюВидео", Ложь);
	Настройки.Вставить("ОзвучиватьВыполнениеСценария", Ложь);
	ЗаписьВидео = Новый Структура;	
	ЗаписьВидео.Вставить("КаталогВыгрузкиИнструкцийВидео", "");
	ЗаписьВидео.Вставить("ЗаписьВидеоКомандаНачатьЗаписьВидео", "");
	ЗаписьВидео.Вставить("ЗаписьВидеоИнструмент", "ffmpeg");
	ЗаписьВидео.Вставить("ЗаписьВидеоЭкранШирина", "");
	ЗаписьВидео.Вставить("ЗаписьВидеоЭкранВысота", "");
	ЗаписьВидео.Вставить("ЗаписьВидеоЭкранСлева", "");
	ЗаписьВидео.Вставить("ЗаписьВидеоЭкранСверху", "");
	ЗаписьВидео.Вставить("ЗаписьВидеоКоличествоКадров", "");
	ЗаписьВидео.Вставить("ЗаписьВидеоФайлКурсораМышки");
	ЗаписьВидео.Вставить("ЗаписьВидеоПодсвечиватьАктивныеЭлементыФорм");
	ЗаписьВидео.Вставить("ЗаписьВидеоПеремещатьКурсорМышкиКАктивномуЭлементуФормы");
	ЗаписьВидео.Вставить("ЗаписьВидеоКаталогДляВременныхФайлов");
	ЗаписьВидео.Вставить("ЗаписьВидеоФайлВодянойЗнак");
	ЗаписьВидео.Вставить("ЗаписьВидеоКомандаFfmpeg", "ffmpeg");
	ЗаписьВидео.Вставить("ЗаписьВидеоКомандаConvert", "magick convert");
	ЗаписьВидео.Вставить("ЗаписьВидеоКаталогМузыки");
	ЗаписьВидео.Вставить("ЗаписьВидеоГромкостьМузыки");
	ЗаписьВидео.Вставить("ЗаписьВидеоДелатьНаложениеTTS");
	ЗаписьВидео.Вставить("ЗаписьВидеоТипОзвучкиTTS");
	
	ЗаписьВидео.Вставить("ЗаписьВидеоYandexTTSЯзык");
	ЗаписьВидео.Вставить("ЗаписьВидеоYandexTTSГолос");
	ЗаписьВидео.Вставить("ЗаписьВидеоYandexTTSЭмоция");
	ЗаписьВидео.Вставить("ЗаписьВидеоYandexTTSСкорость");
	ЗаписьВидео.Вставить("ЗаписьВидеоYandexTTSИдентификаторКаталога");
	ЗаписьВидео.Вставить("ЗаписьВидеоYandexTTSOauthToken");
	ЗаписьВидео.Вставить("ЗаписьВидеоYandexTTSВариантЗапроса");
	
	ЗаписьВидео.Вставить("ЗаписьВидеоAmazonГолос");
	ЗаписьВидео.Вставить("ЗаписьВидеоAmazonДвижок");
	ЗаписьВидео.Вставить("ЗаписьВидеоAmazonЯзык");
	ЗаписьВидео.Вставить("ЗаписьВидеоAmazonРегион", "us-east-1");
	ЗаписьВидео.Вставить("ЗаписьВидеоAmazonКлючДоступа");
	ЗаписьВидео.Вставить("ЗаписьВидеоAmazonСекретныйКлюч");
	
	ЗаписьВидео.Вставить("ЗаписьВидеоСберTTSГолос");
	ЗаписьВидео.Вставить("ЗаписьВидеоСберTTSClientID");
	ЗаписьВидео.Вставить("ЗаписьВидеоСберTTSClientSecret");
	
	ЗаписьВидео.Вставить("ЗаписьВидеоПутьКДвижкуTTS");
	ЗаписьВидео.Вставить("ЗаписьВидеоИмяTTS");
	ЗаписьВидео.Вставить("ЗаписьВидеоСловарьЗамен", Новый СписокЗначений);
	ЗаписьВидео.Вставить("ЗаписьВидеоГруппаШаговКакШаг", Истина);
	ЗаписьВидео.Вставить("ЗаписьВидеоОтключитьМасштабированиеШаговПоВремени");
	ЗаписьВидео.Вставить("ЗаписьВидеоПодсвечиватьНажатияМышки");
	ЗаписьВидео.Вставить("ЗаписьВидеоОтключитьСлайдСЗаголовкомФичи");
	ЗаписьВидео.Вставить("ЗаписьВидеоОтключитьСлайдСценария");
	ЗаписьВидео.Вставить("ЗаписьВидеоОтключитьСлайдФинал");
	ЗаписьВидео.Вставить("ЗаписьВидеоЭмулироватьВводСКлавиатуры");
	ЗаписьВидео.Вставить("ЗаписьВидеоСкрытьСлужебныеОкна");
	ЗаписьВидео.Вставить("ЗаписьВидеоСкоростьПроизношения");
	ЗаписьВидео.Вставить("ЗаписьВидеоКэшироватьФайлыTTS");
	ЗаписьВидео.Вставить("ЗаписьВидеоКэшФайловTTS");
	ЗаписьВидео.Вставить("ЗаписьВидеоКэшироватьВидеоВставки");
	ЗаписьВидео.Вставить("ЗаписьВидеоКэшВидеоВставок");
	ЗаписьВидео.Вставить("ЗаписьВидеоДобавлятьСубтитры");
	ЗаписьВидео.Вставить("ЗаписьВидеоПроцентУскорения");
	ЗаписьВидео.Вставить("ЗаписьВидеоФормироватьИнструкциюТипВидео");
	ЗаписьВидео.Вставить("ЗаписьВидеоФормироватьИнструкциюТипHTML");
	ЗаписьВидео.Вставить("ЗаписьВидеоФормироватьИнструкциюТипMarkdown");		
	ЗаписьВидео.Вставить("ЗаписьВидеоЭмулироватьДвиженияМышкиSikuliX");		
	ЗаписьВидео.Вставить("ЗаписьВидеоПутьКОбработкеДвижкаTTS");		
	ЗаписьВидео.Вставить("ЗаписьВидеоЗаменитьСлайдЗаголовок");
	ЗаписьВидео.Вставить("ЗаписьВидеоПутьКСлайдуЗаголовок");
	ЗаписьВидео.Вставить("ЗаписьВидеоДобавитьМузыкуКСлайдуЗаголовок");
	ЗаписьВидео.Вставить("ЗаписьВидеоЗаменитьСлайдФинал");
	ЗаписьВидео.Вставить("ЗаписьВидеоПутьКСлайдуФинал");
	ЗаписьВидео.Вставить("ЗаписьВидеоДобавитьМузыкуКСлайдуФинал");
	ЗаписьВидео.Вставить("НастройкиДругогоДвижкаTTS", Новый Массив);
	Настройки.Вставить("ЗаписьВидео", ЗаписьВидео);
		
	// SikuliXServer
	Настройки.Вставить("ИспользоватьSikuliXСервер", Ложь);
	SikuliXServer = Новый Структура;
	SikuliXServer.Вставить("КаталогиСкриптовSikuliX", "");
	SikuliXServer.Вставить("КаталогДляГенерацииКартинок", "");
	Настройки.Вставить("SikuliXServer", SikuliXServer);
	
	Настройки.Вставить("ИскатьЭлементыФормыПоИмени", Истина);
	Настройки.Вставить("ДобавлятьПриНакликиванииМетаИнформацию", Ложь);
	Настройки.Вставить("ТегTreeВключенПоУмолчанию", Истина);
	
	Если НастройкиЗагрузки Тогда	
		//Настройки.Вставить("Ключ", "");
	КонецЕсли;
	
	Если НастрокиВыгрузки Тогда
		//Настройки.Вставить("Ключ", "");
	КонецЕсли;
	
	Возврат Настройки;
	
КонецФункции

Функция ЗначениеИзТегаСценария(СтрокаДерева, НачалоТега)
	Если ТипЗнч(СтрокаДерева.ПроизвольныеЗначения) <> Тип("Структура")
			ИЛИ НЕ СтрокаДерева.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	МассивТегов = СтрокаДерева.ПроизвольныеЗначения.МассивТегов;
	НрегНачалоТега = Нрег(НачалоТега);
	СтрДлинаНачалоТега = СтрДлина(НачалоТега) + 1;
	Для Каждого Элем Из МассивТегов Цикл
		Если Найти(Элем.Тег, НачалоТега) = 1 Тогда
			Возврат Сред(Элем.Тег, СтрДлинаНачалоТега); 
		КонецЕсли;	 
	КонецЦикла;	 
КонецФункции	 

Функция ПолучитьТекстСообщенияПользователю(Текст) Экспорт
	
	Если ТекстСообщенийПользователю <> Неопределено Тогда
		Значение = ТекстСообщенийПользователю[Текст];
		Если ЗначениеЗаполнено(Значение) Тогда
			Возврат Значение;
		КонецЕсли;	 
	КонецЕсли;	 
	
	Возврат Текст;
	
КонецФункции	 

Функция ПолучитьВерсиюОбработки(ДобавлятьНазвание = Истина, ТолькоЦифры = Ложь) Экспорт
	Версия = "1.2.038.10";
	
	Если ТолькоЦифры Тогда
		Возврат Версия;	
	ИначеЕсли ДобавлятьНазвание Тогда
		Возврат "vanessa-automation ver " + Версия;	
	Иначе
		Возврат "ver " + Версия;	
	КонецЕсли;
	
КонецФункции

Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
		
	Если ЕстьПоддержкаФункцияРазложитьСтрокуВМассивПодстрок Тогда
		Если ПропускатьПустыеСтроки = Истина Тогда
			Возврат Вычислить("СтрРазделить(Строка,Разделитель,Ложь)");
		Иначе
			Возврат Вычислить("СтрРазделить(Строка,Разделитель,Истина)");
		КонецЕсли;	 
	КонецЕсли;	 
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Возвращает сведения о внешней обработке.
//
Функция СведенияОВнешнейОбработке() Экспорт
	
	МодульДополнительныеОтчетыИОбработки = Вычислить("ДополнительныеОтчетыИОбработки");
	Если ТипЗнч(МодульДополнительныеОтчетыИОбработки) <> Тип("ОбщийМодуль") Тогда
		Возврат Неопределено;
	КонецЕсли;

	МодульДополнительныеОтчетыИОбработкиКлиентСервер = Вычислить("ДополнительныеОтчетыИОбработкиКлиентСервер");
	
	// BSLLS:UsingHardcodeNetworkAddress-off
	ПараметрыРегистрации = МодульДополнительныеОтчетыИОбработки.СведенияОВнешнейОбработке("2.2.2.1"); 
	// BSLLS:UsingHardcodeNetworkAddress-on
    
    ПараметрыРегистрации.Вид = МодульДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительнаяОбработка();
    ПараметрыРегистрации.Версия = ПолучитьВерсиюОбработки(Ложь, Истина);
	ПараметрыРегистрации.БезопасныйРежим = Ложь;
    
    НоваяКоманда = ПараметрыРегистрации.Команды.Добавить();
    НоваяКоманда.Представление = "Vanessa Automation";
    НоваяКоманда.Идентификатор = "VA";
    НоваяКоманда.Использование = МодульДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыОткрытиеФормы();
    НоваяКоманда.ПоказыватьОповещение = Ложь;
    
    Возврат ПараметрыРегистрации;
    
КонецФункции

// Позволяет сделать поиск в строке "ПроверяемаяСтрока" подстроки "Шаблон"
// при этом подстрока "Шаблон" может содержать символы *
// например СтрокаСоответствуетШаблону("Привет","*вет")
// Параметры:
//   ПроверяемаяСтрока  - Строка - Проверяемая ссылка.
//   Шаблон             - Строка - Строка регулярного выражения.
Функция СтрокаСоответствуетШаблону(ПроверяемаяСтрока, Знач Шаблон) Экспорт
	Если ПроверяемаяСтрока = Шаблон Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Шаблон = ПодготовитьШаблонКИспользованиюВРегулярке(Шаблон, ЭтоLinux);
	
	Если ЭтоLinux Тогда
		Возврат ПроверитьСтрокуRegExpLinux(ПроверяемаяСтрока, Шаблон);
	Иначе	
		Если Регулярка = Неопределено Тогда
			Регулярка = Новый COMОбъект("VBScript.RegExp");
		КонецЕсли;
		
		Регулярка.Global = Истина;
		// для VBScript.RegExp явно указываем что есть начало и конец строки
		Шаблон            = "^" + Шаблон + "$";
		Регулярка.Pattern = Шаблон;
		Возврат Регулярка.Test(ПроверяемаяСтрока);
	КонецЕсли;	 
КонецФункции 

#Область Plugins

Функция ТипыПлагинов()
	Результат = Новый Структура;
	Результат.Вставить("Загрузчик", "Загрузчик");
	Результат.Вставить("Утилита", "Утилита");
	Результат.Вставить("ГенераторОтчета", "ГенераторОтчета");
	
	Возврат Новый ФиксированнаяСтруктура(Результат);
КонецФункции

Функция Плагин(Знач Идентификатор) Экспорт
	
	ИдентификаторПлагинаСПрефиксомПодсистемы = Идентификатор;
	ИдентификаторПлагинаБезПрефиксаПодсистемы = Идентификатор;
	Плагин = Плагины[ИдентификаторПлагинаБезПрефиксаПодсистемы];
	Если ТипЗнч(Плагин) = Тип("Строка") Тогда
		Плагин = СоздатьОбъектПлагина(Плагин);
	КонецЕсли;
	
	Возврат Плагин;
	
КонецФункции

Функция ПолучитьОписанияПлагиновПоТипу(Знач ТипПлагина) Экспорт
	Результат = Новый Массив;
	Для каждого КлючЗначение Из Плагины Цикл
		Плагин = Плагин(КлючЗначение.Ключ);
		Плагин.Инициализация(ЭтотОбъект);
		ОписаниеПлагина = Плагин.ОписаниеПлагина(ТипыПлагинов);
		Если ОписаниеПлагина.Тип = ТипПлагина Тогда
			Результат.Добавить(ОписаниеПлагина);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция СоздатьОбъектПлагина(Идентификатор, ВстроенаВКонфигурацию = Ложь, ЭтоОтчет = Ложь) Экспорт
	
	ОбъектПлагина = Неопределено;
	Если ЭтоОтчет = Истина Тогда
		ОбъектПлагина = ВнешниеОтчеты.Создать(Идентификатор, Ложь);				
	Иначе
		ОбъектПлагина = ВнешниеОбработки.Создать(Идентификатор, Ложь);	
	КонецЕсли;
	
	Возврат ОбъектПлагина;
	
КонецФункции

#КонецОбласти

Функция Транслит(Стр) Экспорт
    Рез = СокрЛП(Стр);   
    Рез = СтрЗаменить(Рез, "а", "a");
    Рез = СтрЗаменить(Рез, "б", "b");
    Рез = СтрЗаменить(Рез, "в", "v");
    Рез = СтрЗаменить(Рез, "г", "g");
    Рез = СтрЗаменить(Рез, "д", "d");
    Рез = СтрЗаменить(Рез, "е", "e");
    Рез = СтрЗаменить(Рез, "ё", "e");
    Рез = СтрЗаменить(Рез, "ж", "zh");
    Рез = СтрЗаменить(Рез, "з", "z");
    Рез = СтрЗаменить(Рез, "и", "i");
    Рез = СтрЗаменить(Рез, "к", "k");
    Рез = СтрЗаменить(Рез, "л", "l");
    Рез = СтрЗаменить(Рез, "м", "m");
    Рез = СтрЗаменить(Рез, "н", "n");
    Рез = СтрЗаменить(Рез, "о", "o");
    Рез = СтрЗаменить(Рез, "п", "p");
    Рез = СтрЗаменить(Рез, "р", "r");
    Рез = СтрЗаменить(Рез, "с", "s");
    Рез = СтрЗаменить(Рез, "т", "t");
    Рез = СтрЗаменить(Рез, "у", "u");
    Рез = СтрЗаменить(Рез, "ф", "f");
    Рез = СтрЗаменить(Рез, "х", "h");
    Рез = СтрЗаменить(Рез, "ч", "ch");
    Рез = СтрЗаменить(Рез, "ш", "sh");
    Рез = СтрЗаменить(Рез, "щ", "sch");
    Рез = СтрЗаменить(Рез, "ъ", "");
    Рез = СтрЗаменить(Рез, "ь", "");
    Рез = СтрЗаменить(Рез, "э", "e");
    Рез = СтрЗаменить(Рез, "ю", "yu");
    Рез = СтрЗаменить(Рез, "й", "i");
    Рез = СтрЗаменить(Рез, "ц", "c");
    Рез = СтрЗаменить(Рез, "я", "ya");
    Рез = СтрЗаменить(Рез, "ы", "i");
    Рез = СтрЗаменить(Рез, "А", "A");
    Рез = СтрЗаменить(Рез, "Б", "B");
    Рез = СтрЗаменить(Рез, "В", "V");
    Рез = СтрЗаменить(Рез, "Г", "G");
    Рез = СтрЗаменить(Рез, "Д", "D");
    Рез = СтрЗаменить(Рез, "Е", "E");
    Рез = СтрЗаменить(Рез, "Ё", "E");
    Рез = СтрЗаменить(Рез, "Ж", "ZH");
    Рез = СтрЗаменить(Рез, "З", "Z");
    Рез = СтрЗаменить(Рез, "И", "I");
    Рез = СтрЗаменить(Рез, "К", "K");
    Рез = СтрЗаменить(Рез, "Л", "L");
    Рез = СтрЗаменить(Рез, "М", "M");
    Рез = СтрЗаменить(Рез, "Н", "N");
    Рез = СтрЗаменить(Рез, "О", "O");
    Рез = СтрЗаменить(Рез, "П", "P");
    Рез = СтрЗаменить(Рез, "Р", "R");
    Рез = СтрЗаменить(Рез, "С", "S");
    Рез = СтрЗаменить(Рез, "Т", "T");
    Рез = СтрЗаменить(Рез, "У", "U");
    Рез = СтрЗаменить(Рез, "Ф", "F");
    Рез = СтрЗаменить(Рез, "Х", "H");
    Рез = СтрЗаменить(Рез, "Ч", "CH");
    Рез = СтрЗаменить(Рез, "Ш", "SH");
    Рез = СтрЗаменить(Рез, "Щ", "SCH");
    Рез = СтрЗаменить(Рез, "Ъ", "");
    Рез = СтрЗаменить(Рез, "Ь", "");
    Рез = СтрЗаменить(Рез, "Ы", "I");
    Рез = СтрЗаменить(Рез, "Ц", "C");
    Рез = СтрЗаменить(Рез, "Э", "E");
    Рез = СтрЗаменить(Рез, "Ю", "YU");
    Рез = СтрЗаменить(Рез, "Я", "YA");
    Рез = СтрЗаменить(Рез, "Й", "I");
    Возврат(Рез);
КонецФункции

Процедура СделатьСообщение(Знач Сообщение, ТипСообщения = "Информация") Экспорт
	
	ТипСообщения = ?(ТипСообщения = "Информация", СтатусСообщения.Обычное, СтатусСообщения.ОченьВажное);
	
	Если ДелатьСообщенияТранслитом Тогда
		Сообщение = Транслит(Сообщение);
	КонецЕсли;	 
	
	ТекстСообщения = ПолучитьТекстСообщенияПользователю("%1. %2");
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Строка(ТекущаяДата()));
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", Сообщение);
	Сообщить(ТекстСообщения, ТипСообщения);
	
КонецПроцедуры

// для совместимости с ОФ
Процедура СообщитьПользователю(Знач Сообщение, ТипСообщения = "Информация") Экспорт
	СделатьСообщение(Сообщение, ТипСообщения);
КонецПроцедуры

Процедура Отладка(Знач Сообщение) Экспорт
	Если DebugLog Тогда
		СделатьСообщение(Сообщение);
	КонецЕсли; 
КонецПроцедуры

Функция ДополнитьСлешВПуть(Знач Каталог)
	Разделитель = "\";

	Если ЭтоLinux Тогда
		Разделитель = "/";
	КонецЕсли;
	
	Если Найти(Прав(Каталог, 1), "\/") > 0 Тогда 
		Каталог = Лев(Каталог, СтрДлина(Каталог) - 1);
	КонецЕсли;
	
	Если Прав(Каталог, 1) <> Разделитель Тогда
		Каталог = Каталог + Разделитель;
	КонецЕсли;
	
	Возврат Каталог;
	
КонецФункции

#Область Allure

Процедура ЗаписатьСтатусВШагИлиСценарий(ОбъектДляЗаписи, Статус)
	Если Статус = "Success" Тогда
		ОбъектДляЗаписи.status = "passed";
	ИначеЕсли Статус = "Pending" Тогда
		ОбъектДляЗаписи.status = "broken";
	ИначеЕсли Статус = "Failed" Тогда
		ОбъектДляЗаписи.status = "failed";
	Иначе	// все остальное, включая skipped
		ОбъектДляЗаписи.status = "skipped";
	КонецЕсли; 

КонецПроцедуры

Процедура ДобавитьПрефиксAllureВСтроку(Стр)
	Стр = СтрЗаменить(Стр, "<test-suite-result", "<ns2:test-suite");
	Стр = СтрЗаменить(Стр, "</test-suite-result>", "</ns2:test-suite>");
	Стр = СтрЗаменить(Стр, "xmlns=""urn:model.allure.qatools.yandex.ru""", "xmlns:ns2=""urn:model.allure.qatools.yandex.ru""");
КонецПроцедуры

Процедура ДобавитьМетку(Фабрика, СписокМеток, name, value)
	
	Если НЕ ЗначениеЗаполнено(value) Тогда
		Возврат;
	КонецЕсли;

	Типlabel    = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "label");
	Метка       = Фабрика.Создать(Типlabel);
	Метка.name  = name;
	Метка.value = value;
	
	СписокМеток.label.Добавить(Метка);
КонецПроцедуры

Функция УбратьСимволыДляКорректногоОтчетаAllure(Знач Стр)
	Возврат СтрЗаменить(Стр, ".", "_");
КонецФункции	

Функция ПолучитьПрефиксИмениСценария(ДобавлятьКИмениСценарияУсловияВыгрузки = Ложь)
	
	Если ДобавлятьКИмениСценарияУсловияВыгрузки И ЗначениеЗаполнено(ИмяТекущейСборки) Тогда
		Возврат "(" + УбратьСимволыДляКорректногоОтчетаAllure(ИмяТекущейСборки) + ") ";
	КонецЕсли;
	Возврат "";
	
КонецФункции	

Процедура ДанныеПоИерархииОтчетаИзОтносительногоПути(epic, feature, story, СтрСтроки, Знач ОтносительныйПуть)
	ПолныйПуть = СтрСтроки.ПолныйПуть;
	ПолныйПутьКопия        = СтрЗаменить(НРег(ПолныйПуть), "/", "\");
	ОтносительныйПутьКопия = СтрЗаменить(НРег(ОтносительныйПуть), "/", "\");
	Если Прав(ОтносительныйПутьКопия, 1) <> "\" Тогда
		ОтносительныйПутьКопия = ОтносительныйПутьКопия + "\";
	КонецЕсли;	 
	
	Поз = Найти(ПолныйПутьКопия, ОтносительныйПутьКопия);
	
	Если Поз = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	ПраваяЧастьКопия = Сред(ПолныйПутьКопия, Поз + СтрДлина(ОтносительныйПутьКопия));
	ПраваяЧасть      = Сред(ПолныйПуть, Поз + СтрДлина(ОтносительныйПутьКопия));
	
	Каталог1 = "";
	Каталог2 = "";
	Каталог3 = "";
	
	Поз = Найти(ПраваяЧастьКопия, "\");
	Если Поз > 0 Тогда
		Каталог1 = Лев(ПраваяЧасть, Поз - 1);
		ПраваяЧастьКопия = Сред(ПраваяЧастьКопия, Поз + 1);
		ПраваяЧасть      = Сред(ПраваяЧасть, Поз + 1);
	КонецЕсли;	 
	
	Поз = Найти(ПраваяЧастьКопия, "\");
	Если Поз > 0 Тогда
		Каталог2 = Лев(ПраваяЧасть, Поз - 1);
		ПраваяЧастьКопия = Сред(ПраваяЧастьКопия, Поз + 1);
		ПраваяЧасть      = Сред(ПраваяЧасть, Поз + 1);
	КонецЕсли;	 
	
	Поз = Найти(ПраваяЧастьКопия, "\");
	Если Поз > 0 Тогда
		Каталог3 = Лев(ПраваяЧасть, Поз - 1);
		ПраваяЧастьКопия = Сред(ПраваяЧастьКопия, Поз + 1);
		ПраваяЧасть      = Сред(ПраваяЧасть, Поз + 1);
	КонецЕсли;	 
	
	СобранныеДанные = Новый Структура;
	СобранныеДанные.Вставить("Каталог1", Каталог1);
	СобранныеДанные.Вставить("Каталог2", Каталог2);
	СобранныеДанные.Вставить("Каталог3", Каталог3);
	
	Если ЗначениеЗаполнено(УровеньОтчета1) Тогда
		epic = УровеньОтчетаПоСобраннымДанным(УровеньОтчета1, СтрСтроки, СобранныеДанные, 1);
	КонецЕсли;	 
	Если ЗначениеЗаполнено(УровеньОтчета2) Тогда
		feature = УровеньОтчетаПоСобраннымДанным(УровеньОтчета2, СтрСтроки, СобранныеДанные, 2);
	КонецЕсли;	 
	Если ЗначениеЗаполнено(УровеньОтчета3) Тогда
		story = УровеньОтчетаПоСобраннымДанным(УровеньОтчета3, СтрСтроки, СобранныеДанные, 3);
	КонецЕсли;	 
КонецПроцедуры 

Процедура ДанныеПоИерархииОтчетаИзОтносительногоПути2(epic, feature, story, suite, СтрСтроки, СтрокаСценария, Знач ОтносительныйПуть)
	ПолныйПуть = СтрСтроки.ПолныйПуть;
	Если СтрСтроки.Тип = "Примеры" Тогда
		ПолныйПуть = СтрСтроки.Родитель.ПолныйПуть;
	КонецЕсли;	 
	ПолныйПутьКопия        = СтрЗаменить(НРег(ПолныйПуть), "/", "\");
	ОтносительныйПутьКопия = СтрЗаменить(НРег(ОтносительныйПуть), "/", "\");
	Если Прав(ОтносительныйПутьКопия, 1) <> "\" Тогда
		ОтносительныйПутьКопия = ОтносительныйПутьКопия + "\";
	КонецЕсли;	 
	
	Поз = Найти(ПолныйПутьКопия, ОтносительныйПутьКопия);
	
	Если Поз = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	ПраваяЧастьКопия = Сред(ПолныйПутьКопия, Поз + СтрДлина(ОтносительныйПутьКопия));
	ПраваяЧасть      = Сред(ПолныйПуть, Поз + СтрДлина(ОтносительныйПутьКопия));
	
	Каталог1 = "";
	Каталог2 = "";
	Каталог3 = "";
	
	Поз = Найти(ПраваяЧастьКопия, "\");
	Если Поз > 0 Тогда
		Каталог1 = Лев(ПраваяЧасть, Поз - 1);
		ПраваяЧастьКопия = Сред(ПраваяЧастьКопия, Поз + 1);
		ПраваяЧасть      = Сред(ПраваяЧасть, Поз + 1);
	КонецЕсли;	 
	
	Поз = Найти(ПраваяЧастьКопия, "\");
	Если Поз > 0 Тогда
		Каталог2 = Лев(ПраваяЧасть, Поз - 1);
		ПраваяЧастьКопия = Сред(ПраваяЧастьКопия, Поз + 1);
		ПраваяЧасть      = Сред(ПраваяЧасть, Поз + 1);
	КонецЕсли;	 
	
	Поз = Найти(ПраваяЧастьКопия, "\");
	Если Поз > 0 Тогда
		Каталог3 = Лев(ПраваяЧасть, Поз - 1);
		ПраваяЧастьКопия = Сред(ПраваяЧастьКопия, Поз + 1);
		ПраваяЧасть      = Сред(ПраваяЧасть, Поз + 1);
	КонецЕсли;	 
	
	СобранныеДанные = Новый Структура;
	СобранныеДанные.Вставить("Каталог1", Каталог1);
	СобранныеДанные.Вставить("Каталог2", Каталог2);
	СобранныеДанные.Вставить("Каталог3", Каталог3);
	
	Если ЗначениеЗаполнено(УровеньОтчета1) Тогда
		epic = УровеньОтчетаПоСобраннымДанным2(УровеньОтчета1, СтрСтроки, СтрокаСценария, СобранныеДанные, 1);
	КонецЕсли;	 
	Если ЗначениеЗаполнено(УровеньОтчета2) Тогда
		feature = УровеньОтчетаПоСобраннымДанным2(УровеньОтчета2, СтрСтроки, СтрокаСценария, СобранныеДанные, 2);
	КонецЕсли;	 
	Если ЗначениеЗаполнено(УровеньОтчета3) Тогда
		story = УровеньОтчетаПоСобраннымДанным2(УровеньОтчета3, СтрСтроки, СтрокаСценария, СобранныеДанные, 3);
	КонецЕсли;	 
	Если ЗначениеЗаполнено(ГруппировкаTestSuites) Тогда
		suite = УровеньОтчетаПоСобраннымДанным2(ГруппировкаTestSuites, СтрСтроки, СтрокаСценария, СобранныеДанные, 1);
	КонецЕсли;	 
КонецПроцедуры 

Функция УровеньОтчетаПоСобраннымДанным(СтрокаКакОпределятьУровень, СтрСтроки, СобранныеДанные, Уровень)
	МассивЗначений = РазложитьСтрокуВМассивПодстрок(СтрокаКакОпределятьУровень, ";");
	Для Каждого ТекЗначение Из МассивЗначений Цикл
		ТекЗначение = НРег(ТекЗначение);
		Если ТекЗначение = "каталог1" Или ТекЗначение = "catalog1" Тогда
			Возврат СобранныеДанные.Каталог1; 
		ИначеЕсли ТекЗначение = "каталог2" Или ТекЗначение = "catalog2" Тогда
			Возврат СобранныеДанные.Каталог2; 
		ИначеЕсли ТекЗначение = "каталог3" Или ТекЗначение = "catalog3" Тогда
			Возврат СобранныеДанные.Каталог3; 
		ИначеЕсли ТекЗначение = "имяфичи" Или ТекЗначение = "featurename" Тогда
			Если СтрСтроки.Тип = "Фича" Тогда
				Возврат СтрСтроки.Имя; 
			КонецЕсли;	 
			
			Возврат Неопределено;
		ИначеЕсли ТекЗначение = "имясценария" Или ТекЗначение = "scenarioname" Тогда
			Если Уровень = 3 Тогда
				СтрСтроки.ПроизвольныеЗначения.Вставить("ИмяСценария_для_story", Истина);
			КонецЕсли;	 
			
			Возврат Неопределено; 
			
		ИначеЕсли Лев(ТекЗначение, 1) = "#" Тогда
			Результат = "";
			Если ТипЗнч(СтрСтроки.ПроизвольныеЗначения) = Тип("Структура")  Тогда
				Для Каждого КомментарийСтруктура Из СтрСтроки.ПроизвольныеЗначения.МассивКомментариев Цикл
					Комментарий = СокрЛП(КомментарийСтруктура.Комментарий);
					НрегКомментарий = НРег(Комментарий);
					Если Лев(НрегКомментарий, 1) <> "#" Тогда
						НрегКомментарий = "#" + НрегКомментарий;
						Комментарий     = "#" + Комментарий;
					КонецЕсли;	 
					Если Лев(НрегКомментарий, СтрДлина(ТекЗначение)) = ТекЗначение Тогда
						ПромСтр = Сред(Комментарий, СтрДлина(ТекЗначение) + 1);
						Если ЗначениеЗаполнено(ПромСтр) Тогда
							Результат = ПромСтр;
						КонецЕсли;	 
					КонецЕсли;	 
				КонецЦикла;	 
			КонецЕсли;	 
			
			Если ЗначениеЗаполнено(Результат) Тогда
				Возврат Результат; 
			КонецЕсли;	 
		КонецЕсли;	 
	КонецЦикла;	
КонецФункции	                                     

Функция ВеткаФичи(Знач СтрокаДерева)
	Пока Истина Цикл
		Если СтрокаДерева.Тип = "Фича" Тогда
			Прервать;
		КонецЕсли;	 
		
		СтрокаДерева = СтрокаДерева.Родитель;
		
		Если СтрокаДерева = Неопределено Тогда
			Прервать;
		КонецЕсли;	 
	КонецЦикла;
	
	Возврат СтрокаДерева; 
КонецФункции	 

Процедура ЗначениеУровняОтчетаИзКомментария(Комментарий, ТекЗначение, Результат)
	Комментарий = СокрЛП(Комментарий);
	НрегКомментарий = НРег(Комментарий);
	Если Лев(НрегКомментарий, 1) <> "#" Тогда
		НрегКомментарий = "#" + НрегКомментарий;
		Комментарий     = "#" + Комментарий;
	КонецЕсли;	 
	Если Лев(НрегКомментарий, СтрДлина(ТекЗначение)) = ТекЗначение Тогда
		ПромСтр = Сред(Комментарий, СтрДлина(ТекЗначение) + 1);
		Если ЗначениеЗаполнено(ПромСтр) Тогда
			Результат = ПромСтр;
		КонецЕсли;	 
	КонецЕсли;	 
КонецПроцедуры 

Функция УровеньОтчетаПоСобраннымДанным2(СтрокаКакОпределятьУровень, Знач СтрСтроки, СтрокаСценария, СобранныеДанные, Уровень)
	МассивЗначений = РазложитьСтрокуВМассивПодстрок(СтрокаКакОпределятьУровень, ";");
	Для Каждого ТекЗначение Из МассивЗначений Цикл
		ТекЗначение = НРег(ТекЗначение);
		Если ТекЗначение = "каталог1" Или ТекЗначение = "catalog1" Тогда
			Возврат СобранныеДанные.Каталог1; 
		ИначеЕсли ТекЗначение = "каталог2" Или ТекЗначение = "catalog2" Тогда
			Возврат СобранныеДанные.Каталог2; 
		ИначеЕсли ТекЗначение = "каталог3" Или ТекЗначение = "catalog3" Тогда
			Возврат СобранныеДанные.Каталог3; 
		ИначеЕсли ТекЗначение = "имяфичи" Или ТекЗначение = "featurename" Тогда
			СтрокаФичи = ВеткаФичи(СтрСтроки);
			Если СтрокаФичи.Тип = "Фича" Тогда
				Возврат СтрокаФичи.Имя; 
			КонецЕсли;	 
			
			Возврат Неопределено;
		ИначеЕсли ТекЗначение = "имяфичафайла" Или ТекЗначение = "featurefilename" Тогда
			СтрокаФичи = ВеткаФичи(СтрСтроки);
			Если СтрокаФичи.Тип = "Фича" Тогда
				Если НЕ ПустаяСтрока(СтрокаФичи.ПолныйПуть) Тогда
					Файл = Новый Файл(СтрокаФичи.ПолныйПуть);
					Возврат Файл.ИмяБезРасширения; 
				КонецЕсли;	 
			КонецЕсли;	 
			
			Возврат Неопределено;
		ИначеЕсли ТекЗначение = "имясценария" Или ТекЗначение = "scenarioname" Тогда
			Если Уровень = 3 Тогда
				СтрСтроки.ПроизвольныеЗначения.Вставить("ИмяСценария_для_story", Истина);
			КонецЕсли;	 
			
			Возврат Неопределено; 
			
		ИначеЕсли Лев(ТекЗначение, 1) = "#" Тогда
			СтрокаФичи = ВеткаФичи(СтрСтроки);
			Результат = "";
			Если ТипЗнч(СтрокаФичи.ПроизвольныеЗначения) = Тип("Структура")  Тогда
				Если СтрокаФичи.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
					Для Каждого КомментарийСтруктура Из СтрокаФичи.ПроизвольныеЗначения.МассивКомментариев Цикл
						ЗначениеУровняОтчетаИзКомментария(КомментарийСтруктура.Комментарий, ТекЗначение, Результат);
					КонецЦикла;	 
				КонецЕсли;	 
				Если СтрокаСценария.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
					Для Каждого КомментарийСтруктура Из СтрокаСценария.ПроизвольныеЗначения.МассивКомментариев Цикл
						ЗначениеУровняОтчетаИзКомментария(КомментарийСтруктура.Комментарий, ТекЗначение, Результат);
					КонецЦикла;	 
				КонецЕсли;	 
			КонецЕсли;	 
			
			Если ЗначениеЗаполнено(Результат) Тогда
				Возврат Результат; 
			КонецЕсли;	 
		КонецЕсли;	 
	КонецЦикла;	
КонецФункции	                                     

Процедура ОбойтиДеревоДляОтчетаАллюр(Дерево, Фабрика, ТекущаяФича = Неопределено, СписокСценариев = Неопределено, СписокШагов = Неопределено)
	Для каждого СтрСтроки Из Дерево.Строки Цикл
		Если СтрСтроки.Тип = "Фича" Тогда
			
			GUID             = Новый УникальныйИдентификатор();
			РеальноеИмяФайла = "" + GUID + "-testsuite.xml";
			ИмяФайлаXML      = ДополнитьСлешВПуть(КаталогВыгрузкиAllure) + РеальноеИмяФайла;
			
			Если ОтчетВРежимеУФ Тогда
				СтруктураФайлаXML = Новый Структура;
				СтруктураФайлаXML.Вставить("РеальноеИмяФайла", РеальноеИмяФайла);
				
				ИмяФайлаXML = ПолучитьИмяВременногоФайла("xml");
			КонецЕсли;	 
			
			ЗТ = Новый ЗаписьТекста(ИмяФайлаXML, КодировкаТекста.ANSI);
			ЗТ.Закрыть();
			
			ВременныйФайлXML = ПолучитьИмяВременногоФайла("xml");
			ЗаписьXML = Новый ЗаписьXML;
			
			ЗаписьXML.ОткрытьФайл(ВременныйФайлXML);			
			ЗаписьXML.ЗаписатьОбъявлениеXML();
			
			ТипTestSuiteResult = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "test-suite-result");
			ТекущаяФича        = Фабрика.Создать(ТипTestSuiteResult);
			ТекущаяФича.name   = СтрСтроки.Имя;
			
			ТипTestCasesResult = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "test-cases-result");
			СписокСценариев    = Фабрика.Создать(ТипTestCasesResult);
			
			Типlabels   = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "labels");
			СписокМеток = Фабрика.Создать(Типlabels);
			
			Если СтрСтроки.ПроизвольныеЗначения = Неопределено Тогда
				СтрСтроки.ПроизвольныеЗначения = Новый Структура;
			КонецЕсли;	 
			
			Если ЗначениеЗаполнено(УровеньОтчета1) ИЛИ ЗначениеЗаполнено(УровеньОтчета2) ИЛИ ЗначениеЗаполнено(УровеньОтчета3) Тогда
				epic    = "";
				feature = "";
				story   = "";
				ДанныеПоИерархииОтчетаИзОтносительногоПути(epic, feature, story, СтрСтроки, КаталогОтносительноКоторогоНадоСтроитьИерархию);
				
				ДобавитьМетку(Фабрика, СписокМеток, "epic", epic);
				ДобавитьМетку(Фабрика, СписокМеток, "feature", feature);
				
				СтрСтроки.ПроизвольныеЗначения.Вставить("story", story);
			Иначе	
				epic = "";
				Если ТипЗнч(СтрСтроки.ПроизвольныеЗначения) = Тип("Структура")  Тогда
					Для Каждого КомментарийСтруктура Из СтрСтроки.ПроизвольныеЗначения.МассивКомментариев Цикл
						Комментарий = СокрЛП(КомментарийСтруктура.Комментарий);
						НрегКомментарий = НРег(Комментарий);
						Если Лев(НрегКомментарий, 12) = "report.epic=" Тогда
							ПромСтр = Сред(Комментарий, 13);
							Если ЗначениеЗаполнено(ПромСтр) Тогда
								epic = ПромСтр;
								Прервать;
							КонецЕсли;	 
						КонецЕсли;	 
					КонецЦикла;	 
				КонецЕсли;	 
				Если ЗначениеЗаполнено(epic) Тогда
					ДобавитьМетку(Фабрика, СписокМеток, "epic", epic);
				КонецЕсли;	 

				feature = СтрСтроки.Имя;
				Если ТипЗнч(СтрСтроки.ПроизвольныеЗначения) = Тип("Структура")  Тогда
					Для Каждого КомментарийСтруктура Из СтрСтроки.ПроизвольныеЗначения.МассивКомментариев Цикл
						Комментарий = СокрЛП(КомментарийСтруктура.Комментарий);
						НрегКомментарий = НРег(Комментарий);
						Если Лев(НрегКомментарий, 15) = "report.feature=" Тогда
							ПромСтр = Сред(Комментарий, 16);
							Если ЗначениеЗаполнено(ПромСтр) Тогда
								feature = ПромСтр;
								Прервать;
							КонецЕсли;	 
						КонецЕсли;	 
					КонецЦикла;	 
				КонецЕсли;	 
				ДобавитьМетку(Фабрика, СписокМеток, "feature", feature);
			КонецЕсли;	 
						
			ОбойтиДеревоДляОтчетаАллюр(СтрСтроки, Фабрика, ТекущаяФича, СписокСценариев, СписокШагов);
			
			ТекущаяФича.test_cases = СписокСценариев;
			
			ДобавитьМетку(Фабрика, СписокМеток, "framework", "vanessa-automation");
			ДобавитьМетку(Фабрика, СписокМеток, "language", "1С");
					
			ТекущаяФича.labels = СписокМеток;
			
			Фабрика.ЗаписатьXML(ЗаписьXML, ТекущаяФича);
			ЗаписьXML.Закрыть();
						
			// делаем запись без BOM и немного преобразуем строки xml
			ЗТ = Новый ЗаписьТекста(ИмяФайлаXML,,, Истина);
			Текст = Новый ЧтениеТекста;
			Текст.Открыть(ВременныйФайлXML, "UTF-8");
			
			Стр = Текст.ПрочитатьСтроку();
			Пока Стр <> Неопределено Цикл
				ДобавитьПрефиксAllureВСтроку(Стр);
				ЗТ.ЗаписатьСтроку(Стр);
				Стр = Текст.ПрочитатьСтроку();
			КонецЦикла;	
			ЗТ.Закрыть();
			Текст.Закрыть();
			УдалитьФайлы(ВременныйФайлXML);

			Если ОтчетВРежимеУФ Тогда
				ДвоичныеДанные = Новый ДвоичныеДанные(ИмяФайлаXML);
				СтруктураФайлаXML.Вставить("ФайлXMLДвоичныеДанные", ДвоичныеДанные);
				ПараметрыОтчетаУФ.МассивXMLОтчетаAllure.Добавить(СтруктураФайлаXML);
				
				УдалитьФайлы(ИмяФайлаXML);
			Иначе	
				ТекстСообщения = ПолучитьТекстСообщенияПользователю("Файл отчета Allure-report (%1) записан.");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ИмяФайлаXML);
				СделатьСообщение(ТекстСообщения);
			КонецЕсли;	 
						
		ИначеЕсли (СтрСтроки.Тип = "Сценарий") ИЛИ (СтрСтроки.Тип = "Пример") Тогда
			Если (СтрСтроки.ДопТип = "Контекст") Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий включается в каждый сценарий
				
			ИначеЕсли (СтрСтроки.ДопТип = "СтруктураСценария") ИЛИ (СтрСтроки.Строки.Количество() = 0) Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаАллюр(СтрСтроки, Фабрика, ТекущаяФича, СписокСценариев, СписокШагов);
			Иначе
				
				РезультатПрохожденияТестовСценария = ПолучитьРезультатПрохожденияТестовСценария(СтрСтроки);
				
				Если РезультатПрохожденияТестовСценария = Неопределено Тогда
					Продолжить;
				КонецЕсли; 
				
				ТипTestCaseResult = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "test-case-result");
				Сценарий = Фабрика.Создать(ТипTestCaseResult);
				
				ПрефиксИмениСценария = ПолучитьПрефиксИмениСценария(ДобавлятьКИмениСценарияУсловияВыгрузки);
				Сценарий.name = ПрефиксИмениСценария + СтрСтроки.Имя;
				Если СтрСтроки.Тип = "Пример" Тогда
					Сценарий.name = ПрефиксИмениСценария + СтрСтроки.Родитель.Родитель.Имя + " №" + (СтрСтроки.Родитель.Строки.Индекс(СтрСтроки));
				КонецЕсли; 
				
				Сценарий.start = РезультатПрохожденияТестовСценария.ВремяНачала - РазницаВМилисекундахМеждуЮниксИНачалЭпохи;
				Сценарий.stop  = РезультатПрохожденияТестовСценария.ВремяОкончания  - РазницаВМилисекундахМеждуЮниксИНачалЭпохи;
							
				ТипSteps    = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "steps");
				СписокШагов = Фабрика.Создать(ТипSteps);

				Если СтрСтроки.ДопТип = "СтруктураСценария" Тогда
					ОбойтиДеревоДляОтчетаАллюр(СтрСтроки, Фабрика, ТекущаяФича, СписокСценариев, СписокШагов);
				Иначе
					Для каждого СтрРезультатПрохожденияТестовШагов Из РезультатПрохожденияТестовСценария.РезультатПрохожденияТестовШагов Цикл
						ТипStep   = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "step");
						Шаг       = Фабрика.Создать(ТипStep);
						Шаг.name  = СтрРезультатПрохожденияТестовШагов.Имя;
						Шаг.title = СтрРезультатПрохожденияТестовШагов.Имя;
						
						Если СтрРезультатПрохожденияТестовШагов.ВремяНачала <> Неопределено Тогда
							Шаг.start = СтрРезультатПрохожденияТестовШагов.ВремяНачала - РазницаВМилисекундахМеждуЮниксИНачалЭпохи;
							Шаг.stop  = СтрРезультатПрохожденияТестовШагов.ВремяОкончания - РазницаВМилисекундахМеждуЮниксИНачалЭпохи;
						КонецЕсли; 
						
						ЗаписатьСтатусВШагИлиСценарий(Шаг, СтрРезультатПрохожденияТестовШагов.Статус);
						
						СписокШагов.step.Добавить(Шаг);
					КонецЦикла;
				КонецЕсли;	 
				
				ЗаписатьСтатусВШагИлиСценарий(Сценарий, СтрСтроки.Статус);
				Если (СтрСтроки.Статус = "Failed") ИЛИ (СтрСтроки.Статус = "Pending") Тогда
					ТипFailure            = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "failure");
					ОбъектFailure         = Фабрика.Создать(ТипFailure);
					ОбъектFailure.message = РезультатПрохожденияТестовСценария.ОписаниеОшибки;
					
					Сценарий.failure = ОбъектFailure;
				КонецЕсли; 
				Сценарий.steps = СписокШагов;
								
				Если РезультатПрохожденияТестовСценария.Свойство("МассивСкриншотов") Тогда
					// значит есть скриншоты
					
					Типattachments    = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "attachments");
					Списокattachments = Фабрика.Создать(Типattachments);
					
					Для каждого СтруктураСкриншот Из РезультатПрохожденияТестовСценария.МассивСкриншотов Цикл
						Типattachment  = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "attachment");
						attachment      = Фабрика.Создать(Типattachment);
						
						attachment.title  = "screenshot";
						attachment.source = СтруктураСкриншот.ИмяФайла;
						
						Списокattachments.attachment.Добавить(attachment);
					КонецЦикла;
					Сценарий.attachments = Списокattachments;
				КонецЕсли;	 
								
				Типlabels   = Фабрика.Тип("urn:model.allure.qatools.yandex.ru", "labels");
				СписокМеток = Фабрика.Создать(Типlabels);
				story = "";
				Если ЗначениеЗаполнено(УровеньОтчета3) И ТипЗнч(СтрСтроки.Родитель.ПроизвольныеЗначения) = Тип("Структура") Тогда
					Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("story")
							И ЗначениеЗаполнено(СтрСтроки.Родитель.ПроизвольныеЗначения.story) Тогда
						story = СтрСтроки.Родитель.ПроизвольныеЗначения.story;
					ИначеЕсли СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("ИмяСценария_для_story")
							И СтрСтроки.Родитель.ПроизвольныеЗначения.ИмяСценария_для_story = Истина Тогда
						story = СтрСтроки.Имя;
					КонецЕсли;	 
				КонецЕсли;
				
				Если НЕ ЗначениеЗаполнено(story) И ТипЗнч(СтрСтроки.Родитель.ПроизвольныеЗначения) = Тип("Структура") Тогда
					Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("story") Тогда
						story = СтрСтроки.Родитель.ПроизвольныеЗначения.story;
					Иначе	
						Для Каждого КомментарийСтруктура Из СтрСтроки.Родитель.ПроизвольныеЗначения.МассивКомментариев Цикл
							Комментарий = СокрЛП(КомментарийСтруктура.Комментарий);
							НрегКомментарий = НРег(Комментарий);
							Если Лев(НрегКомментарий, 13) = "report.story=" Тогда
								ПромСтр = Сред(Комментарий, 14);
								Если ЗначениеЗаполнено(ПромСтр) Тогда
									story = ПромСтр;
									Прервать;
								КонецЕсли;	 
							КонецЕсли;	 
						КонецЦикла;	 
					КонецЕсли;
				КонецЕсли;	 
				
				Если НЕ ЗначениеЗаполнено(story) Тогда
					story = СтрСтроки.Имя;
				КонецЕсли;	 
				
				ДобавитьМетку(Фабрика, СписокМеток, "story", story);
				Сценарий.labels = СписокМеток;
				
				СписокСценариев.test_case.Добавить(Сценарий);
			КонецЕсли; 
		ИначеЕсли СтрСтроки.Тип = "Шаг" Тогда
			Если СтрСтроки.Родитель.ДопТип = "СтруктураСценария" Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаАллюр(СтрСтроки, Фабрика, ТекущаяФича, СписокСценариев, СписокШагов);
			КонецЕсли; 
		Иначе	
			ОбойтиДеревоДляОтчетаАллюр(СтрСтроки, Фабрика, ТекущаяФича, СписокСценариев, СписокШагов);
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

Процедура СформироватьОтчетАллюр(СтруктураОФ = Неопределено) Экспорт
	Перем СтарыйКаталог, ИмяФайла;
	СтарыйКаталог = КаталогВыгрузкиAllure;
	
	Если СтруктураОФ <> Неопределено Тогда
		// для УФ формируется отчет в новом формате
		СформироватьОтчетАллюр2(СтруктураОФ, ДеревоТестов, ИмяТекущейСборки);
		Возврат;		
	КонецЕсли;	 
			
	ОтчетВРежимеУФ = Ложь;
	
	Если СтруктураОФ = Неопределено Тогда
		ИмяФайла = КаталогИнструментов + "/vendor/allure-framework/allure.xsd"; 
	КонецЕсли;	 
	
	Файл = Новый Файл(КаталогВыгрузкиAllure);
	Если Не Файл.Существует() Тогда
		СделатьСообщение("Не могу сформировать отчет Allure. Не существует каталог для вывода отчета.");
		Возврат;
	КонецЕсли; 

	Фабрика      = СоздатьФабрикуXDTO(ИмяФайла);

	КаталогВыгрузкиAllure = ДополнитьСлешВПуть(КаталогВыгрузкиAllure);

	ОбойтиДеревоДляОтчетаАллюр(ДеревоТестов, Фабрика);
	
	КаталогВыгрузкиAllure = СтарыйКаталог;

КонецПроцедуры

Функция ПолучитьРезультатПрохожденияТестовСценария(СтрСтроки)
	
	РезультатПрохожденияТестовСценария = Неопределено;
	
	Если ОтчетВРежимеУФ Тогда
		ИДВМассиве = ПараметрыОтчетаУФ.МассивИДСтрокиДерева[СтрСтроки.ИДСтроки];
		Если ИДВМассиве <> Неопределено Тогда
			РезультатПрохожденияТестовСценария = ПараметрыОтчетаУФ.МассивРезультатПрохожденияТестовСценария[ИДВМассиве];
		КонецЕсли;
	Иначе
		РезультатПрохожденияТестовСценария = СтрСтроки.РезультатПрохожденияТестовСценария;
	КонецЕсли;
	
	Возврат РезультатПрохожденияТестовСценария;

КонецФункции

#КонецОбласти

#Область Allure2

Процедура ЗаписатьСтатусВШагИлиСценарий2(ОбъектДляЗаписи, Статус, МассивТегов = Неопределено)
	Если МассивТегов = Неопределено Тогда
		МассивТегов = Новый Массив;
	КонецЕсли;
	
	Если Статус = "Success" Тогда
		ОбъектДляЗаписи.status = "passed";
	ИначеЕсли Статус = "Pending" Тогда
		Для Каждого Элемент Из МассивТегов Цикл
			Если Элемент.тег = "skipped" Тогда
				ОбъектДляЗаписи.status = "skipped";
				Возврат;
			КонецЕсли;
		КонецЦикла;
		ОбъектДляЗаписи.status = "pending";
	ИначеЕсли Статус = "Failed" Тогда
		ОбъектДляЗаписи.status = "failed";
	ИначеЕсли Статус = "Skipped" Тогда
		ОбъектДляЗаписи.status = "skipped";
	ИначеЕсли Статус = "Broken" Тогда
		ОбъектДляЗаписи.status = "broken";
	Иначе	
		ОбъектДляЗаписи.status = "skipped";
	КонецЕсли; 
КонецПроцедуры

Процедура ДобавитьМетку2(СписокМеток, name, value, СписокПереопределяемый = Неопределено)
	Если СписокПереопределяемый <> Неопределено И ТипЗнч(СписокПереопределяемый) = Тип("СписокЗначений") Тогда
		Если СписокПереопределяемый.НайтиПоЗначению(name) <> Неопределено Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Метка       = Новый Структура("name, value");
	Метка.name  = name;
	Метка.value = value;
	
	// Сделано специально, т.к. некоторые метки берут в отчет Первые, 
	// поэтому из сценария мы ставим их в начало, перед фичей.
	СписокМеток.Вставить(0, Метка);
	
КонецПроцедуры

Функция УбратьСимволыДляКорректногоОтчетаAllure2(Знач Стр)
	Стр = СтрЗаменить(Стр, ".", "_");
	Возврат Стр;
КонецФункции	

Функция ПолучитьПрефиксИмениСценария2(ДобавлятьКИмениСценарияУсловияВыгрузки = Ложь)
	
	Если ДобавлятьКИмениСценарияУсловияВыгрузки Тогда 
		Если ЗначениеЗаполнено(ИмяТекущейСборки) Тогда
			Возврат "(" + УбратьСимволыДляКорректногоОтчетаAllure2(ИмяТекущейСборки) + ") ";
		КонецЕсли;	 
	КонецЕсли;
	
	Возврат "";
	
КонецФункции	

Функция ПолучитьОписаниеСценарияАллюр2()
	Перем СтруктураРезультата;
	
	GUID             = Новый УникальныйИдентификатор();
	СтруктураРезультата = Новый Структура(); 
	СтруктураРезультата.Вставить("uuid", Строка(GUID));
	СтруктураРезультата.Вставить("historyId", Неопределено);
	СтруктураРезультата.Вставить("name", Неопределено);
	СтруктураРезультата.Вставить("fullName", Неопределено);
	СтруктураРезультата.Вставить("start", Неопределено);
	СтруктураРезультата.Вставить("stop", Неопределено);
	СтруктураРезультата.Вставить("statusDetails",  Новый Структура("known, muted,flaky", Ложь, Ложь, Ложь));
	СтруктураРезультата.Вставить("status", Неопределено);
	СтруктураРезультата.Вставить("stage", "finished"); // Внятного описания, зачем это в каждом сценарии нет. 
	СтруктураРезультата.Вставить("steps", Новый Массив());
	СтруктураРезультата.Вставить("parameters", Новый Массив());
	СтруктураРезультата.Вставить("labels", Новый Массив());
	СтруктураРезультата.Вставить("links", Новый Массив());
	СтруктураРезультата.Вставить("attachments", Новый Массив());
	СтруктураРезультата.Вставить("description", Неопределено);
	
	Возврат СтруктураРезультата;
	
КонецФункции

Функция ПолучитьОписаниеКонтекстныхШаговАллюр2()
	Перем СтруктураРезультата;
	
	СтруктураРезультата = Новый Структура("uuid, name, description, children, befores, start, stop");
	СтруктураРезультата.Вставить("befores", Новый Массив());
	СтруктураРезультата.Вставить("children", Новый Массив());

	Возврат СтруктураРезультата;
	
КонецФункции

Функция ПолучитьОписаниеШагаАллюр2()
	Перем СтруктураРезультата;
	
	СтруктураРезультата = Новый Структура("name, start, stop, status, stage");
	СтруктураРезультата.Вставить("statusDetails",  Новый Структура("known, muted,flaky", Ложь, Ложь, Ложь));
	СтруктураРезультата.Вставить("parameters", Новый Массив());
	СтруктураРезультата.Вставить("attachments", Новый Массив());
	СтруктураРезультата.Вставить("steps", Новый Массив());
		
	Возврат СтруктураРезультата;

КонецФункции

Процедура ЗаписатьОписаниеАллюр2(Строка, СтруктураВыгрузки)

	ДополнительноеОписание = Новый Структура;
	Если ТипЗнч(ДополнительноеОписание) = Тип("Структура") И ДополнительноеОписание.Свойство("description") Тогда
		СтруктураВыгрузки.Вставить("description", ДополнительноеОписание["description"]);
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьФайлКЭлементуАллюр2(СтруктураВыгрузки, Имя, ИмяФайла, Тип = "image/png")
	
	attachment = Новый Структура("name, source, type");
	attachment.name    = Имя;
	attachment.source  = ИмяФайла;
	attachment.type	= Тип;
	
	СтруктураВыгрузки.attachments.Добавить(attachment);

КонецПроцедуры

Функция ИмяФайлаСкриншотаБезКаталога()
	УИД = Новый УникальныйИдентификатор;
	Возврат "" + УИД + "-attachment.png";
КонецФункции

Процедура ДобавитьСкриншотыКСценариюИлиШагуАллюр2(СтруктураВыгрузки, РезультатПрохождения)
	
	Если РезультатПрохождения.Свойство("МассивСкриншотов") Тогда
		// значит есть скриншоты
		
		Для каждого СтруктураСкриншот Из РезультатПрохождения.МассивСкриншотов Цикл
			ИмяФайлаСкриншотаВОтчете = "screenshot";
			Если СтруктураСкриншот.Свойство("ЗаголовокВнутреннегоОкна") Тогда
				ИмяФайлаСкриншотаВОтчете = СтруктураСкриншот.ЗаголовокВнутреннегоОкна;
			ИначеЕсли СтруктураСкриншот.Свойство("ИмяСкриншотаДляОтчета") Тогда
				ИмяФайлаСкриншотаВОтчете = СтруктураСкриншот.ИмяСкриншотаДляОтчета;
			КонецЕсли;
			Если СтруктураСкриншот.Свойство("ИмяКлиентаТестирования") Тогда
				ИмяФайлаСкриншотаВОтчете = СтруктураСкриншот.ИмяКлиентаТестирования + "." + ИмяФайлаСкриншотаВОтчете;
			КонецЕсли;	 
			
			Если СтруктураСкриншот.Свойство("ИмяФайлаИспользовалось") И СтруктураСкриншот.ИмяФайлаИспользовалось Тогда
				СтруктураСкриншот.ИмяФайла = ИмяФайлаСкриншотаБезКаталога();
			КонецЕсли;	 
			
			ДобавитьФайлКЭлементуАллюр2(СтруктураВыгрузки, ИмяФайлаСкриншотаВОтчете, СтруктураСкриншот.ИмяФайла, "image/png");
			СтруктураСкриншот.Вставить("ИмяФайлаИспользовалось", Истина);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьФайлыКСценариюИлиШагуАллюр2(СтруктураВыгрузки, СписокФайлов, МассивXMLОтчетаAllure, ДопПараметрыАллюр2)
	
	Для каждого СтруктураФайл Из СписокФайлов Цикл
		РеальноеИмяФайла = СтруктураФайл.ИмяФайла;
		Если СтруктураФайл.Свойство("ДвоичныеДанные") Тогда
			ФайлОбъект = Новый Файл(Строка(СтруктураФайл.ИмяФайла) );
			
			РеальноеИмяФайла = Строка(Новый УникальныйИдентификатор()) + "-attachment" + ФайлОбъект.Расширение;
			
			СтруктураФайлаXML = Новый Структура;
			СтруктураФайлаXML.Вставить("РеальноеИмяФайла", РеальноеИмяФайла); 
			СтруктураФайлаXML.Вставить("ФайлXMLДвоичныеДанные", СтруктураФайл.ДвоичныеДанные);
			МассивXMLОтчетаAllure.Добавить(СтруктураФайлаXML);
		КонецЕсли;
		
		ТипФайла = Неопределено;
		СтруктураФайл.Свойство("ТипФайла", ТипФайла);
		Если ТипФайла = Неопределено Тогда
			ТипФайла = "text/plain";
		КонецЕсли;
		ДобавитьФайлКЭлементуАллюр2(СтруктураВыгрузки, СтруктураФайл.ИмяФайла, РеальноеИмяФайла, ТипФайла);
	КонецЦикла;
	
КонецПроцедуры

Функция ПодставитьЗначенияПеременныхВШаг(Знач Стр, ДанныеШага)
	Для Каждого Элем Из ДанныеШага.ПеременныеДляСохраненияВШаг Цикл
		Если Элем.Тип Тогда
			//Это глобальная переменная
			СпецСимволы = "$$";
		Иначе	
			//Это локальная переменная
			СпецСимволы = "$";
		КонецЕсли;	 
		
		Стр = СтрЗаменить(Стр, СпецСимволы + Элем.Имя + СпецСимволы, Элем.Значение);
	КонецЦикла;	 
	
	Возврат Стр; 
КонецФункции	 

Функция ВставитьГруппыШагов(СтрокаВыполнения, ДопПараметрыАллюр2, РезультатыПрохождения, МассивШагов)
	ДанныеГруппыШагов = ДопПараметрыАллюр2.ГруппыШагов[СтрокаВыполнения.ИдСтроки];
	Если ДанныеГруппыШагов <> Неопределено Тогда
		Возврат ДанныеГруппыШагов; 
	КонецЕсли;	 
	
	Если СтрокаВыполнения.Тип = "Сценарий" ИЛИ СтрокаВыполнения.Тип = "Пример" Тогда
		Возврат МассивШагов;
	КонецЕсли;	 
	
	МассивШагов = ВставитьГруппыШагов(СтрокаВыполнения.Родитель, ДопПараметрыАллюр2, РезультатыПрохождения, МассивШагов);
	
	Если (СтрокаВыполнения.Тип = "Область" И ПустаяСтрока(СтрокаВыполнения.ДопТип))
		ИЛИ СтрокаВыполнения.Тип = "ШагСценарий"
		ИЛИ СтрокаВыполнения.ДопТип = "Попытка"
		ИЛИ СтрокаВыполнения.ДопТип = "Исключение"
		ИЛИ СтрокаВыполнения.ДопТип = "УсловиеИначе"
		Тогда
		ШагВложенный = ПолучитьОписаниеШагаАллюр2();
		ШагВложенный.name  = Строка(СтрокаВыполнения.Имя);
		ШагВложенный.stage = "finished";
		ЗаписатьСтатусВШагИлиСценарий2(ШагВложенный, РезультатыПрохождения.Статус);
		МассивШагов.Добавить(ШагВложенный);
		МассивШагов = ШагВложенный.steps;
		ДопПараметрыАллюр2.ГруппыШагов.Вставить(СтрокаВыполнения.ИдСтроки, ШагВложенный.steps);
	КонецЕсли;	 
	
	Возврат МассивШагов; 
КонецФункции	 

Процедура ЗаписатьВыполнениеШагаАллюр2(МассивШагов, ДеревоТестов, РезультатыПрохождения, СоответствиеГрупп, МассивXMLОтчетаAllure, СтруктураВыгрузкиСценария, ДопПараметрыАллюр2)
	Перем ШагВложенный;	
	
	МассивШаговДобавления = МассивШагов;
	СтрокаВыполнения = ДопПараметрыАллюр2.СтрокаДереваПоИдСтроки[РезультатыПрохождения.ИДСтроки];
	Если СтрокаВыполнения <> Неопределено Тогда
		МассивШаговДобавления = ВставитьГруппыШагов(СтрокаВыполнения.Родитель, ДопПараметрыАллюр2, РезультатыПрохождения, МассивШаговДобавления);
	КонецЕсли;
	
	Шаг = ПолучитьОписаниеШагаАллюр2();
	Шаг.name  = Строка(РезультатыПрохождения.Имя);
	ПодставитьЗначенияПеременныхВШаг = Ложь;
	Если РезультатыПрохождения.Свойство("ПеременныеДляСохраненияВШаг") Тогда
		ПодставитьЗначенияПеременныхВШаг = Истина;
		Шаг.name = ПодставитьЗначенияПеременныхВШаг(Строка(РезультатыПрохождения.Имя), РезультатыПрохождения);
	КонецЕсли;	 
	Если РезультатыПрохождения.ВремяНачала <> Неопределено Тогда
		Шаг.start = (РезультатыПрохождения.ВремяНачала - РазницаВМилисекундахМеждуЮниксИНачалЭпохи);
		Шаг.stop  = (РезультатыПрохождения.ВремяОкончания - РазницаВМилисекундахМеждуЮниксИНачалЭпохи);
	КонецЕсли;
	Шаг.stage = "finished";
	
	Если СтрокаВыполнения <> Неопределено Тогда	
		Счетчик = 1;
		Для каждого Элемент Из СтрокаВыполнения.ЗначенияПараметров Цикл
			ИмяПараметра = "Парам" + Счетчик;
			Счетчик = Счетчик + 1;
			Если ПодставитьЗначенияПеременныхВШаг Тогда
				Шаг["parameters"].Добавить(Новый Структура("name, value", ИмяПараметра,
					ПодставитьЗначенияПеременныхВШаг(Элемент.Значение.Значение, РезультатыПрохождения)));
			Иначе	
				Шаг["parameters"].Добавить(Новый Структура("name, value",
					ИмяПараметра, Элемент.Значение.Значение));
			КонецЕсли;	 
			
		КонецЦикла;
		
		МассивПараметров = Новый Массив();		
		Если СтрокаВыполнения.ШагСПараметрамиВТаблице = Истина Тогда
			СтрокаCSV = "";
			ПарамТаблица = Новый Массив;
			ПодчиненныеСтроки = СтрокаВыполнения.Строки;
			Для каждого СтрокиТаблицы Из ПодчиненныеСтроки Цикл
				Если ЗначениеЗаполнено(СтрокиТаблицы.Тип) Тогда
					// значит это уже не строка таблицы
					Прервать;
				КонецЕсли;	 
				
				СтруктураПарамТаблица = Новый Структура;
				
				Если (СтрокиТаблицы.СтрокаПараметровШагаВВидеТаблицы <> Истина) ИЛИ (НЕ ЗначениеЗаполнено(СтрокиТаблицы.Имя)) Тогда
					ПарамТаблица = Новый Массив;
					МассивПараметров.Добавить(ПарамТаблица);
					Продолжить;
				КонецЕсли;	 
				
				НомерКолонки = 0;
				Для каждого Колонка Из СтрокиТаблицы.ПараметрыТаблицы Цикл
					НомерКолонки       = НомерКолонки + 1;
					СтруктураПараметра = Колонка.Значение;
					Значение           = Строка(СтруктураПараметра.Значение);
					Если ПодставитьЗначенияПеременныхВШаг Тогда
						Значение = ПодставитьЗначенияПеременныхВШаг(Значение, РезультатыПрохождения);
					КонецЕсли;	 
					СтрокаCSV = СтрокаCSV + ?(НомерКолонки = 1, "", ",") + """" + СтрЗаменить(Значение, """", """""") + """";
					СтруктураПарамТаблица.Вставить("Кол" + НомерКолонки, Значение);
				КонецЦикла;
				
				ПарамТаблица.Добавить(СтруктураПарамТаблица);
				СтрокаCSV = СтрокаCSV + Символы.ПС;
			КонецЦикла;
			
			Если ПарамТаблица.Количество() > 0 Тогда
				МассивПараметров.Добавить(ПарамТаблица);
			КонецЕсли;
			
			Если МассивПараметров.Количество() > 0 Тогда
				РеальноеИмяФайла = Строка(Новый УникальныйИдентификатор) + "-attachment.csv";
				
				ВременноеИмяФайла = ПолучитьИмяВременногоФайла("csv");
				Запись = Новый ЗаписьТекста;
				Запись.Открыть(ВременноеИмяФайла);
				Запись.Записать(СтрокаCSV);
				Запись.Закрыть();
				
				ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ВременноеИмяФайла);
				СтруктураФайлаXML = Новый Структура;
				СтруктураФайлаXML.Вставить("РеальноеИмяФайла", Строка(РеальноеИмяФайла)); 
				СтруктураФайлаXML.Вставить("ФайлXMLДвоичныеДанные", ДвоичныеДанныеФайла);
				МассивXMLОтчетаAllure.Добавить(СтруктураФайлаXML);
				УдалитьФайлы(ВременноеИмяФайла);
				ДобавитьФайлКЭлементуАллюр2(Шаг, "table", РеальноеИмяФайла, "text/csv");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если СтрокаВыполнения.ПроизвольныеЗначения = Неопределено Тогда
		СтрокаВыполнения.ПроизвольныеЗначения = Новый Структура;
	КонецЕсли;	 
	
	Если СтрокаВыполнения.Родитель.ПроизвольныеЗначения = Неопределено Тогда
		СтрокаВыполнения.Родитель.ПроизвольныеЗначения = Новый Структура;
	КонецЕсли;	 
	
	МассивТегов = Неопределено;
	СтрокаВыполнения.ПроизвольныеЗначения.Свойство("МассивТегов", МассивТегов);
	Если СтрокаВыполнения.Родитель.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
		СтрокаВыполнения.Родитель.ПроизвольныеЗначения.Свойство("МассивТегов", МассивТегов);
	КонецЕсли;

	ЗаписатьСтатусВШагИлиСценарий2(Шаг, РезультатыПрохождения.Статус, МассивТегов);
	Если ((РезультатыПрохождения.Статус = "Failed") ИЛИ (РезультатыПрохождения.Статус = "Pending")) 
		И РезультатыПрохождения.Свойство("ОписаниеОшибки") Тогда
		ОписаниеОшибки = "";
		ПодробноеОписаниеОшибки = "";
		ПодробноеОписаниеОшибкиAllure2(РезультатыПрохождения.ОписаниеОшибки, ОписаниеОшибки, ПодробноеОписаниеОшибки);
		Шаг.Вставить("statusDetails", 
			Новый Структура("known, muted, flaky, message, trace", 
							Ложь, Ложь, Ложь, ОписаниеОшибки, ПодробноеОписаниеОшибки));
	КонецЕсли; 
	
	МассивШаговДобавления.Добавить(Шаг);
	
	Если СтрокаВыполнения.Тип = "Область" И НЕ ПустаяСтрока(СтрокаВыполнения.ДопТип) Тогда
		МассивШаговДобавления = Шаг.steps;
		ДопПараметрыАллюр2.ГруппыШагов.Вставить(СтрокаВыполнения.ИдСтроки, Шаг.steps);
	КонецЕсли;	 
	
	Если ШагВложенный <> Неопределено Тогда
		Если ШагВложенный.start = Неопределено ИЛИ ШагВложенный.start > Шаг.start Тогда
			ШагВложенный.start = Шаг.start;
		КонецЕсли;
		
		Если ШагВложенный.stop = Неопределено ИЛИ ШагВложенный.stop <  Шаг.stop Тогда
			ШагВложенный.stop = Шаг.stop;
		КонецЕсли;
	КонецЕсли;
	
	Если РезультатыПрохождения.Свойство("СписокФайлов") Тогда
		ДобавитьФайлыКСценариюИлиШагуАллюр2(Шаг, РезультатыПрохождения.СписокФайлов, МассивXMLОтчетаAllure, ДопПараметрыАллюр2);
		
		СписокФайловДляСценария = Новый Массив;
		Для Каждого СтруктураФайл Из РезультатыПрохождения.СписокФайлов Цикл
			Если СтруктураФайл.Свойство("ДобавлятьФайлКСценарию") И НЕ СтруктураФайл.ДобавлятьФайлКСценарию Тогда
				Продолжить;
			КонецЕсли;	 
			
			СписокФайловДляСценария.Добавить(СтруктураФайл);
		КонецЦикла;	 
		
		ДобавитьФайлыКСценариюИлиШагуАллюр2(СтруктураВыгрузкиСценария, СписокФайловДляСценария, МассивXMLОтчетаAllure, ДопПараметрыАллюр2);
	КонецЕсли;	 
	
	ДобавитьСкриншотыКСценариюИлиШагуАллюр2(Шаг, РезультатыПрохождения);
КонецПроцедуры

Процедура ПодробноеОписаниеОшибкиAllure2(Знач ИсходнаяСтрока, ОписаниеОшибки, ПодробноеОписаниеОшибки)
	ПодробноеОписаниеОшибки = ИсходнаяСтрока;
	
	СтрокаДеталиОшибки = ПолучитьТекстСообщенияПользователю("ДеталиОшибки:");
	Поз = Найти(ИсходнаяСтрока, СтрокаДеталиОшибки);
	Если Поз > 0 Тогда
		ИсходнаяСтрока = СокрЛП(Сред(ИсходнаяСтрока, Поз + 1 + СтрДлина(СтрокаДеталиОшибки)));
		ОписаниеОшибки = ИсходнаяСтрока;
		Возврат;
	КонецЕсли;	 
	
	Пока Истина Цикл
		Поз1 = Найти(ИсходнаяСтрока, "{");
		Поз2 = Найти(ИсходнаяСтрока, "}:");
		
		Если Поз1 = 0 ИЛИ Поз2 = 0 ИЛИ Поз1 > Поз2 Тогда
			Прервать;
		КонецЕсли;	 
		
		ЧастьСтроки1 = Лев(ИсходнаяСтрока, Поз1 - 1);
		ЧастьСтроки2 = СокрЛ(Сред(ИсходнаяСтрока, Поз2 + 3));
		
		ИсходнаяСтрока = ЧастьСтроки1 + ЧастьСтроки2;
	КонецЦикла;	

	СтрокаТехническиеДанные = ПолучитьТекстСообщенияПользователю("Технические данные");
	Поз = Найти(ИсходнаяСтрока, СтрокаТехническиеДанные);
	Если Поз > 0 Тогда
		ИсходнаяСтрока = СокрЛП(Лев(ИсходнаяСтрока, Поз - 1));
	КонецЕсли;	 
	
	ВСкобках = 0;
	
	ОткСкобки = "<([";
	ЗакрСкобки = ">)]";
	Прерывание = ".:" + Символы.ПС;
	
	Для Поз = 0 По СтрДлина(ИсходнаяСтрока) - 1 Цикл
		
		Символ = Сред(ИсходнаяСтрока, Поз, 1);
		Если Найти(ОткСкобки, Символ) > 0 Тогда
			
			ВСкобках = ВСкобках + 1;
			
		ИначеЕсли Найти(ЗакрСкобки, Символ) > 0 Тогда
			
			ВСкобках = Макс(ВСкобках - 1, 0);
			
		ИначеЕсли Найти(Прерывание, Символ) > 0 И ВСкобках = 0 Тогда
			
			ИсходнаяСтрока = Лев(ИсходнаяСтрока, Поз);
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ОписаниеОшибки = ИсходнаяСтрока;
	
КонецПроцедуры 

Процедура ЗаписатьОбъектВJson(СтруктураОбъекта, ИмяФайла, МассивXMLОтчетаAllure) 
	Перем ВременноеИмяФайла, ЗаписьJSON, ПараметрыЗаписиJSON, ДвоичныеДанныеФайла, СтруктураФайлаXML;
	
	ВременноеИмяФайла = ПолучитьИмяВременногоФайла("json");
	ЗаписьJSON = Новый ЗаписьJSON;
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON( , Символы.Таб);
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	ЗаписьJSON.ОткрытьФайл(ВременноеИмяФайла, , , ПараметрыЗаписиJSON);
	
	ЗаписатьJSON(ЗаписьJSON, СтруктураОбъекта); 
	ЗаписьJSON.Закрыть();
	
	ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ВременноеИмяФайла);
	СтруктураФайлаXML = Новый Структура;
	СтруктураФайлаXML.Вставить("РеальноеИмяФайла", Строка(ИмяФайла)); 
	СтруктураФайлаXML.Вставить("ФайлXMLДвоичныеДанные", ДвоичныеДанныеФайла);
	МассивXMLОтчетаAllure.Добавить(СтруктураФайлаXML);
	УдалитьФайлы(ВременноеИмяФайла);
	
КонецПроцедуры

Функция ОпределитьМассивТеговШага(СтрСтроки)
	Перем МассивТегов;
	МассивТегов = Новый Массив;

	МассивТеговШага = Новый Массив;
	Если ТипЗнч(СтрСтроки.ПроизвольныеЗначения) = Тип("Структура") Тогда 
		Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТеговШага") Тогда
			СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТеговШага", МассивТеговШага);
		КонецЕсли;
		
		Если ТипЗнч(МассивТеговШага) = Тип("Массив") И МассивТеговШага.Количество() = 0 Тогда 
			Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
				СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов", МассивТеговШага);
			КонецЕсли;
		ИначеЕсли  НЕ ТипЗнч(МассивТеговШага) = Тип("Массив")   Тогда
			Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
				СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов", МассивТеговШага);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(МассивТеговШага) = Тип("Массив") Тогда
		Если (МассивТеговШага.Количество() = 0 И ТипЗнч(СтрСтроки.Родитель) = Тип("СтрокаДереваЗначений"))
			ИЛИ (ТипЗнч(СтрСтроки.Родитель) = Тип("СтрокаДереваЗначений") И НЕ МассивТеговШага.Количество() > 0)  Тогда
			
			МассивТеговШага = ОпределитьМассивТеговШага(СтрСтроки.Родитель);
			
		КонецЕсли; 
	КонецЕсли; 
	
	Если ТипЗнч(МассивТеговШага) = Тип("Массив") Тогда
		ФиксМассив = Новый ФиксированныйМассив(МассивТеговШага);
		МассивТегов = Новый Массив(ФиксМассив);
	КонецЕсли;
	
	Возврат МассивТегов;
	
КонецФункции			

Функция ПустойРезультатПрохожденияТестовСценария(СтрокаДерева)
	РезультатПрохожденияТестовШагов = Новый Структура;
	РезультатПрохожденияТестовШагов.Вставить("ВремяНачала", ТекущаяУниверсальнаяДатаВМиллисекундах());
	РезультатПрохожденияТестовШагов.Вставить("ВремяОкончания", РезультатПрохожденияТестовШагов.ВремяНачала);
	РезультатПрохожденияТестовШагов.Вставить("ДатаНачала", ТекущаяДата());
	РезультатПрохожденияТестовШагов.Вставить("ИДСтроки", СтрокаДерева.ИДСтроки);
	РезультатПрохожденияТестовШагов.Вставить("НомерСтрокиВФиче", СтрокаДерева.НомерСтрокиВФиче);
	РезультатПрохожденияТестовШагов.Вставить("ОписаниеОшибки", "");
	РезультатПрохожденияТестовШагов.Вставить("РезультатПрохожденияТестовШагов", Новый Массив);
	Возврат РезультатПрохожденияТестовШагов; 
КонецФункции	 

Процедура РассчитатьДлительностьВыполненияГруппШаговРекурсивно(Шаги, НачалоВыполненияРодитель, ОкончаниеВыполненияРодитель)
	Для Каждого ТекШаг Из Шаги Цикл
		НачалоВыполнения = ТекШаг.start;
		ОкончаниеВыполнения = ТекШаг.stop;
		РассчитатьДлительностьВыполненияГруппШаговРекурсивно(ТекШаг.Steps, НачалоВыполнения, ОкончаниеВыполнения);
		ТекШаг.start = НачалоВыполнения;
		ТекШаг.stop = ОкончаниеВыполнения;
		
		Если НачалоВыполненияРодитель = Неопределено ИЛИ НачалоВыполненияРодитель > НачалоВыполнения Тогда
			НачалоВыполненияРодитель = НачалоВыполнения;
		КонецЕсли;	 
		Если ОкончаниеВыполненияРодитель = Неопределено ИЛИ ОкончаниеВыполненияРодитель < ОкончаниеВыполнения Тогда
			ОкончаниеВыполненияРодитель = ОкончаниеВыполнения;
		КонецЕсли;	 
	КонецЦикла;	 
КонецПроцедуры 

Процедура РассчитатьДлительностьВыполненияГруппШагов(СтруктураВыгрузки)
	Если СтруктураВыгрузки.Свойство("Steps") Тогда
		НачалоВыполнения = СтруктураВыгрузки.start;
		ОкончаниеВыполнения = СтруктураВыгрузки.stop;
		РассчитатьДлительностьВыполненияГруппШаговРекурсивно(СтруктураВыгрузки.Steps, НачалоВыполнения, ОкончаниеВыполнения);
	КонецЕсли;	 
КонецПроцедуры 

Процедура ОбойтиДеревоДляОтчетаАллюр2(Дерево, ДеревоТестов, ДанныеАллюрМеток, ДопПараметрыАллюр2)
	
	Для каждого СтрСтроки Из Дерево.Строки Цикл
		Если СтрСтроки.Тип = "Фича" Тогда
			
			ОбойтиДеревоДляОтчетаАллюр2(СтрСтроки, ДеревоТестов, ДанныеАллюрМеток, ДопПараметрыАллюр2); 
					
		ИначеЕсли (СтрСтроки.Тип = "Сценарий") ИЛИ (СтрСтроки.Тип = "Пример") Тогда
			Если (СтрСтроки.ДопТип = "Контекст") Тогда
				// его не ненадо добавлять в отчет, т.к. этот сценарий включается в каждый сценарий
				
			ИначеЕсли (СтрСтроки.ДопТип = "СтруктураСценария") ИЛИ (СтрСтроки.Строки.Количество() = 0) Тогда
				// его не ненадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаАллюр2(СтрСтроки, ДеревоТестов, ДанныеАллюрМеток, ДопПараметрыАллюр2); 
			Иначе
				
				РезультатПрохожденияТестовСценария = ПолучитьРезультатПрохожденияТестовСценария(СтрСтроки);
				Если РезультатПрохожденияТестовСценария = Неопределено Тогда
					РезультатПрохожденияТестовСценария = ПустойРезультатПрохожденияТестовСценария(СтрСтроки);
				КонецЕсли;
								
				GUID = Новый УникальныйИдентификатор();
				СтруктураВыгрузки = ПолучитьОписаниеСценарияАллюр2();
				СтруктураВыгрузки.Вставить("uuid", Строка(GUID));			
				
				ПрефиксИмениСценария = ПолучитьПрефиксИмениСценария2(ДобавлятьКИмениСценарияУсловияВыгрузки);
				
				СтрокаФичи = СтрСтроки.Родитель;
				Если СтрСтроки.Тип = "Пример" Тогда
					СтруктураВыгрузки.name	= ПрефиксИмениСценария + СтрСтроки.Родитель.Родитель.Имя + " №" + (СтрСтроки.Родитель.Строки.Индекс(СтрСтроки));
					СтрокаФичи		= СтрСтроки.Родитель.Родитель.Родитель;
					
					Для Каждого ИменованныйПараметр Из СтрСтроки.ИменованныеПараметры Цикл
						Если НРег(ИменованныйПараметр.Значение.ИмяПараметра) = "description"
							ИЛИ НРег(ИменованныйПараметр.Значение.ИмяПараметра) = "описание"
							Тогда
							СтруктураВыгрузки.name = ИменованныйПараметр.Значение.Значение;
						КонецЕсли;	 
					КонецЦикла;	 
					
				Иначе	
					СтруктураВыгрузки.name     = ПрефиксИмениСценария + СтрСтроки.Имя;
				КонецЕсли;
				СтруктураВыгрузки.historyId = СтрокаФичи.Имя + "." +  СтруктураВыгрузки.name;
				
				МассивТеговШага = ОпределитьМассивТеговШага(СтрСтроки);
				
				ЗаписатьОписаниеАллюр2(СтрокаФичи, СтруктураВыгрузки);
				ЗаписатьОписаниеАллюр2(СтрСтроки, СтруктураВыгрузки);
				
				СтруктураВыгрузки.Вставить("start", (РезультатПрохожденияТестовСценария.ВремяНачала - РазницаВМилисекундахМеждуЮниксИНачалЭпохи));
				Если РезультатПрохожденияТестовСценария.Свойство("ВремяОкончания") Тогда
					СтруктураВыгрузки.Вставить("stop", (РезультатПрохожденияТестовСценария.ВремяОкончания - РазницаВМилисекундахМеждуЮниксИНачалЭпохи));	
				КонецЕсли;	 
				
				Если СтрСтроки.ПроизвольныеЗначения = Неопределено Тогда
					СтрСтроки.ПроизвольныеЗначения = Новый Структура;
				КонецЕсли;	 
				
				МассивШаговBefore = Новый Массив();
				Если СтрСтроки.ДопТип = "СтруктураСценария" Тогда
					ОбойтиДеревоДляОтчетаАллюр2(СтрСтроки, ДеревоТестов, ДанныеАллюрМеток, ДопПараметрыАллюр2); 
				Иначе
					СоответствиеГрупп = Новый Соответствие;
					МассивШаговДляЗаполнения = СтруктураВыгрузки.steps;
					Если СтрСтроки.Тип = "Пример" Тогда
						Шаг = ПолучитьОписаниеШагаАллюр2();
						Шаг.name = СтрСтроки.Имя;
						
						Для Каждого ИменованныйПараметр Из СтрСтроки.ИменованныеПараметры Цикл
							Если НРег(ИменованныйПараметр.Значение.ИмяПараметра) = "description"
								ИЛИ НРег(ИменованныйПараметр.Значение.ИмяПараметра) = "описание"
								Тогда
								Шаг.name = ИменованныйПараметр.Значение.Значение;
							КонецЕсли;	 
						КонецЦикла;	 
						
						МассивТегов = Неопределено;
						СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов", МассивТегов);
						
						ЗаписатьСтатусВШагИлиСценарий2(Шаг, СтрСтроки.Статус, МассивТегов);
						МассивШаговДляЗаполнения = Шаг.steps;
						СтруктураВыгрузки.steps.Добавить(Шаг);
					КонецЕсли;
					
					Для каждого СтрРезультатПрохожденияТестовШагов Из РезультатПрохожденияТестовСценария.РезультатПрохожденияТестовШагов Цикл
						
						Если СтрРезультатПрохожденияТестовШагов.ЭтоШагКонтекста Тогда
							МассивШаговBefore.Добавить(СтрРезультатПрохожденияТестовШагов);
						Иначе							
							ЗаписатьВыполнениеШагаАллюр2(
								МассивШаговДляЗаполнения,
								ДеревоТестов,
								СтрРезультатПрохожденияТестовШагов,
								СоответствиеГрупп, 
								ПараметрыОтчетаУФ.МассивXMLОтчетаAllure,
								СтруктураВыгрузки,
								ДопПараметрыАллюр2);
							ВложенныеШаги = Неопределено;
							Если СтрРезультатПрохожденияТестовШагов.Свойство("ВложенныеШаги", ВложенныеШаги) 
								И ТипЗнч(ВложенныеШаги) = Тип("Массив") Тогда
								ТекущийШагРезультата = МассивШаговДляЗаполнения.Получить(МассивШаговДляЗаполнения.ВГраница());
								Для каждого СтрПрохожденияВложенныхШагов Из ВложенныеШаги Цикл
									ЗаписатьВыполнениеШагаАллюр2(
										ТекущийШагРезультата.steps,
										ДеревоТестов,
										СтрПрохожденияВложенныхШагов,
										СоответствиеГрупп, 
										ПараметрыОтчетаУФ.МассивXMLОтчетаAllure,
										СтруктураВыгрузки,
										ДопПараметрыАллюр2);
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;	 		
				
				МассивТегов = Неопределено;
				Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
					СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов", МассивТегов);
				КонецЕсли;
				
				Если МассивТегов = Неопределено Тогда 
					Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
						СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов", МассивТегов);
					КонецЕсли;
				КонецЕсли;
				
				Если   МассивТеговШага = Неопределено ИЛИ (ТипЗнч(МассивТеговШага) = Тип("Массив") И МассивТеговШага.Количество() = 0) Тогда
					МассивТеговШага = ОпределитьМассивТеговШага(СтрСтроки);
				КонецЕсли;			
				
				Если РезультатПрохожденияТестовСценария.Свойство("Статус") Тогда
					ТекСтатус = РезультатПрохожденияТестовСценария.Статус;
				Иначе	
					ТекСтатус = СтрСтроки.Статус;
				КонецЕсли;	 
				
				Если РезультатПрохожденияТестовСценария.Свойство("СчитатьСценарийУпавшим") И РезультатПрохожденияТестовСценария.СчитатьСценарийУпавшим Тогда
					ТекСтатус = "Failed";
				КонецЕсли;	 
				
				Если РезультатПрохожденияТестовСценария.Свойство("УстановленСтатусВручную") Тогда
					ТекСтатус = РезультатПрохожденияТестовСценария.УстановленСтатусВручную;
				КонецЕсли;	 
				
				ЗаписатьСтатусВШагИлиСценарий2(СтруктураВыгрузки, ТекСтатус, МассивТегов);
				
				Если (СтрСтроки.Статус = "Failed") Или (СтрСтроки.Статус = "Pending") ИЛИ ТекСтатус = "Failed" Тогда
					ОписаниеОшибки = "";
					ПодробноеОписаниеОшибки = "";
					ПодробноеОписаниеОшибкиAllure2(РезультатПрохожденияТестовСценария.ОписаниеОшибки, ОписаниеОшибки, ПодробноеОписаниеОшибки);
					
					СтруктураОписанияОшибки = Новый Структура;
					СтруктураОписанияОшибки.Вставить("known", Ложь);
					СтруктураОписанияОшибки.Вставить("muted", Ложь);
					СтруктураОписанияОшибки.Вставить("flaky", Ложь);
					СтруктураОписанияОшибки.Вставить("message", ОписаниеОшибки);
					СтруктураОписанияОшибки.Вставить("trace", ПодробноеОписаниеОшибки);
					
					СтруктураВыгрузки.Вставить("statusDetails", СтруктураОписанияОшибки);
				КонецЕсли; 
				
				ДобавитьСкриншотыКСценариюИлиШагуАллюр2(СтруктураВыгрузки, РезультатПрохожденияТестовСценария);
				Если РезультатПрохожденияТестовСценария.Свойство("СписокФайлов") Тогда
					ДобавитьФайлыКСценариюИлиШагуАллюр2(СтруктураВыгрузки, РезультатПрохожденияТестовСценария.СписокФайлов, ПараметрыОтчетаУФ.МассивXMLОтчетаAllure, ДопПараметрыАллюр2);
				КонецЕсли;	 
				
				СисИнформация = Новый СистемнаяИнформация;
				СписокМетокПереопределяемый = Новый СписокЗначений;
				Если РезультатПрохожденияТестовСценария.Свойство("СписокМеток") Тогда
					СписокМетокПереопределяемый = РезультатПрохожденияТестовСценария["СписокМеток"];
				КонецЕсли;
				
				СписокСсылок = Новый СписокЗначений;
				Если РезультатПрохожденияТестовСценария.Свойство("СписокСсылок") Тогда
					СписокСсылок = РезультатПрохожденияТестовСценария["СписокСсылок"];
				КонецЕсли;
				
				Для каждого СсылкаUrl Из СписокСсылок Цикл
					ОписаниеСсылки = Новый Структура("name,url,type");
					ОписаниеСсылки.name = СсылкаUrl.Значение.name;
					ОписаниеСсылки.url = СсылкаUrl.Значение.url;
					ОписаниеСсылки.type = СсылкаUrl.Значение.type;
					
					СтруктураВыгрузки.links.Добавить(ОписаниеСсылки);					
				КонецЦикла;
				
				МассивТегов = Новый Массив();
				ЗначениеМеткиStory = СтрСтроки.Имя;
				Если СтрокаФичи.Тип = "Фича" Тогда
					ДополнительноеОписаниеФичи = СтрокаФичи.ПроизвольныеЗначения;
					//ДополнительноеОписаниеФичи= Новый Структура;
					Если ТипЗнч(ДополнительноеОписаниеФичи) = Тип("Структура") И ДополнительноеОписаниеФичи.Свойство("name") Тогда
						ЗначениеМеткиStory = ДополнительноеОписаниеФичи["name"];
					КонецЕсли;
					
					Если ТипЗнч(ДополнительноеОписаниеФичи) = Тип("Структура") И ДополнительноеОписаниеФичи.Свойство("tags") Тогда
						МассивТегов = ДополнительноеОписаниеФичи["tags"];
					КонецЕсли;
					
				КонецЕсли;
				
				ФайлФичи = Новый Файл(СтрокаФичи.ПолныйПуть);
				ПутьФичи = Новый Файл(ФайлФичи.Путь);
				КаталогФичи = ПутьФичи.ИмяБезРасширения;
				
				СписокМеток =  СтруктураВыгрузки.labels;

				ДобавитьМетку2(СписокМеток, "host", ИмяКомпьютера(), СписокМетокПереопределяемый);
				ДобавитьМетку2(СписокМеток, "package", КаталогФичи, СписокМетокПереопределяемый);
				Если РезультатПрохожденияТестовСценария.Свойство("ЕстьДополнительныеФайлыСравненияЗначенияСЭталоном")
					И РезультатПрохожденияТестовСценария.ЕстьДополнительныеФайлыСравненияЗначенияСЭталоном Тогда
					ДобавитьМетку2(СписокМеток, "testType", "screenshotDiff", СписокМетокПереопределяемый);
				КонецЕсли;	 

				Для каждого Строка Из ДанныеАллюрМеток Цикл 
					Если ПустаяСтрока(Строка.РегулярноеВыражение) Тогда
						//если не указано регулярное выражение, то метка добавляется безусловно
						ДобавитьМетку2(СписокМеток, Строка.ИмяМетки, Строка.Значение, СписокМетокПереопределяемый);
					КонецЕсли;	 
				КонецЦикла;		
				
				Для каждого Тег Из МассивТеговШага Цикл
					ДобавитьМетку2(СписокМеток, "tag", Тег.Тег, СписокМетокПереопределяемый);
					Для каждого Строка Из ДанныеАллюрМеток Цикл 
						Если ПустаяСтрока(Строка.РегулярноеВыражение) Тогда
							//если не указано регулярное выражение, то метка игнорируется
							Продолжить;
						КонецЕсли;	 
						
						Если СтрокаСоответствуетШаблону(Тег.Тег, Строка.РегулярноеВыражение) Тогда 
							ДобавитьМетку2(СписокМеток, Строка.ИмяМетки, Строка.Значение, СписокМетокПереопределяемый);
						КонецЕсли;
					КонецЦикла;		
				КонецЦикла;
				
				Если СтрСтроки.Родитель.ПроизвольныеЗначения = Неопределено Тогда
					СтрСтроки.Родитель.ПроизвольныеЗначения = Новый Структура;
				КонецЕсли;	 
				
				Если ЗначениеЗаполнено(УровеньОтчета1) 
						ИЛИ ЗначениеЗаполнено(УровеньОтчета2) 
						ИЛИ ЗначениеЗаполнено(УровеньОтчета3) 
						ИЛИ ЗначениеЗаполнено(ГруппировкаTestSuites) Тогда
						
					epic    = "";
					feature = "";
					story   = "";
					suite   = "";
					ДанныеПоИерархииОтчетаИзОтносительногоПути2(epic, feature, story, suite, СтрСтроки.Родитель, СтрСтроки, КаталогОтносительноКоторогоНадоСтроитьИерархию);
					
					Если ЗначениеЗаполнено(suite) Тогда
							
						ДобавитьМетку2(СписокМеток, "suite", suite, СписокМетокПереопределяемый);
							
					КонецЕсли;	 
					
					Если ЗначениеЗаполнено(epic)
							И ИспользоватьУровеньОтчета(УровеньОтчета1) Тогда
							
						ДобавитьМетку2(СписокМеток, "epic", epic, СписокМетокПереопределяемый);
						
					КонецЕсли;	 
					
					Если ЗначениеЗаполнено(feature)
							И ИспользоватьУровеньОтчета(УровеньОтчета2) Тогда
							
						ДобавитьМетку2(СписокМеток, "feature", feature, СписокМетокПереопределяемый);
						
					КонецЕсли;	 

					Если ЗначениеЗаполнено(story) 
							И ИспользоватьУровеньОтчета(УровеньОтчета3) Тогда
							
						СтрСтроки.Родитель.ПроизвольныеЗначения.Вставить("story", story);
						
					КонецЕсли;
				Иначе	
					epic = "";
					Если ТипЗнч(СтрСтроки.Родитель.ПроизвольныеЗначения) = Тип("Структура")  Тогда
						// смотрим комментарии фичи
						МассивКомментариев = Новый Массив;
						Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
							МассивКомментариев = СтрСтроки.Родитель.ПроизвольныеЗначения.МассивКомментариев;
						КонецЕсли;	 
						
						Если СтрСтроки.Родитель.Тип = "Примеры" Тогда
							Если СтрСтроки.Родитель.Родитель.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
								МассивКомментариев = СтрСтроки.Родитель.Родитель.ПроизвольныеЗначения.МассивКомментариев;
							КонецЕсли;	 
						КонецЕсли;	 
						
						Для Каждого КомментарийСтруктура Из МассивКомментариев Цикл
							Комментарий = СокрЛП(КомментарийСтруктура.Комментарий);
							НрегКомментарий = НРег(Комментарий);
							Если Лев(НрегКомментарий, 12) = "report.epic=" Тогда
								ПромСтр = Сред(Комментарий, 13);
								Если ЗначениеЗаполнено(ПромСтр) Тогда
									epic = ПромСтр;
									Прервать;
								КонецЕсли;	 
							КонецЕсли;	 
						КонецЦикла;	 
					КонецЕсли;	 
					Если ЗначениеЗаполнено(epic) Тогда
						ДобавитьМетку2(СписокМеток, "epic", epic, СписокМетокПереопределяемый);
						
					КонецЕсли;	 

					feature = СтрСтроки.Имя;
					Если ТипЗнч(СтрСтроки.Родитель.ПроизвольныеЗначения) = Тип("Структура")  Тогда
						// смотрим комментарии фичи
						МассивКомментариев = Новый Массив;
						Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
							МассивКомментариев = СтрСтроки.Родитель.ПроизвольныеЗначения.МассивКомментариев;
						КонецЕсли;	 
						
						Если СтрСтроки.Родитель.Тип = "Примеры" 
								И СтрСтроки.Родитель.Родитель.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
							МассивКомментариев = СтрСтроки.Родитель.Родитель.ПроизвольныеЗначения.МассивКомментариев;
						КонецЕсли;	 
						
						Для Каждого КомментарийСтруктура Из МассивКомментариев Цикл
							Комментарий = СокрЛП(КомментарийСтруктура.Комментарий);
							НрегКомментарий = НРег(Комментарий);
							Если Лев(НрегКомментарий, 15) = "report.feature=" Тогда
								ПромСтр = Сред(Комментарий, 16);
								Если ЗначениеЗаполнено(ПромСтр) Тогда
									feature = ПромСтр;
									Прервать;
								КонецЕсли;	 
							КонецЕсли;	 
						КонецЦикла;	 
					КонецЕсли;	 
					ДобавитьМетку2(СписокМеток, "feature", feature, СписокМетокПереопределяемый);
				КонецЕсли;	 

				story = "";
				Если ЗначениеЗаполнено(УровеньОтчета3) 
						И ИспользоватьУровеньОтчета(УровеньОтчета3) Тогда
						
					Если ТипЗнч(СтрСтроки.Родитель.ПроизвольныеЗначения) = Тип("Структура") Тогда
								
						Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("story") 
								И ЗначениеЗаполнено(СтрСтроки.Родитель.ПроизвольныеЗначения.story) Тогда
								
							story = СтрСтроки.Родитель.ПроизвольныеЗначения.story;
								
						КонецЕсли;	 

						Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("ИмяСценария_для_story")
								И СтрСтроки.Родитель.ПроизвольныеЗначения.ИмяСценария_для_story = Истина Тогда
								
							story = СтрСтроки.Имя;
							
							Если СтрСтроки.Тип = "Пример" Тогда
								
								story = СтрСтроки.Родитель.Родитель.Имя;
								
							КонецЕсли;	 
							
						КонецЕсли;	 
						
					КонецЕсли;	 
					
				КонецЕсли;
				
				Если НЕ ЗначениеЗаполнено(story) Тогда
					Если ТипЗнч(СтрСтроки.Родитель.ПроизвольныеЗначения) = Тип("Структура")  Тогда
						Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("story") Тогда
							story = СтрСтроки.Родитель.ПроизвольныеЗначения.story;
						Иначе	
							// смотрим комментарии фичи
							МассивКомментариев = Новый Массив;
							Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
								МассивКомментариев = СтрСтроки.Родитель.ПроизвольныеЗначения.МассивКомментариев;
							КонецЕсли;	 
							
							Если СтрСтроки.Родитель.Тип = "Примеры" Тогда
								Если СтрСтроки.Родитель.Родитель.ПроизвольныеЗначения.Свойство("МассивКомментариев") Тогда
									МассивКомментариев = СтрСтроки.Родитель.Родитель.ПроизвольныеЗначения.МассивКомментариев;
								КонецЕсли;	 
							КонецЕсли;	 
							Для Каждого КомментарийСтруктура Из МассивКомментариев Цикл
								Комментарий = СокрЛП(КомментарийСтруктура.Комментарий);
								НрегКомментарий = НРег(Комментарий);
								Если Лев(НрегКомментарий, 13) = "report.story=" Тогда
									ПромСтр = Сред(Комментарий, 14);
									Если ЗначениеЗаполнено(ПромСтр) Тогда
										story = ПромСтр;
										Прервать;
									КонецЕсли;	 
								КонецЕсли;	 
							КонецЦикла;	 
						КонецЕсли;	 
					КонецЕсли;	 
				КонецЕсли;	 
				
				Если НЕ ЗначениеЗаполнено(story) Тогда
					story = СтрСтроки.Имя;
				КонецЕсли;	 
				
				Если ЗначениеЗаполнено(story) 
							И ИспользоватьУровеньОтчета(УровеньОтчета3) Тогда
							
					ДобавитьМетку2(СписокМеток, "story", story, СписокМетокПереопределяемый);
					
				КонецЕсли;	 

				Для каждого Тег Из МассивТегов Цикл
					ДобавитьМетку2(СписокМеток, "tag", Тег.Тег, СписокМетокПереопределяемый);
				КонецЦикла;
				
				Для каждого ЭлементМетки Из СписокМетокПереопределяемый Цикл
					ДобавитьМетку2(СписокМеток, ЭлементМетки.Значение, ЭлементМетки.Представление);
				КонецЦикла;

				СписокМетокПереопределяемый = Новый СписокЗначений;
				Если СтрСтроки.Строки.Количество() > 0 Тогда
					РезультатПрохожденияТестовСценария = ПолучитьРезультатПрохожденияТестовСценария(СтрСтроки.Строки[0]);
					Если РезультатПрохожденияТестовСценария <> Неопределено И РезультатПрохожденияТестовСценария.Свойство("СписокМеток") Тогда
						СписокМетокПереопределяемый = РезультатПрохожденияТестовСценария["СписокМеток"];
					КонецЕсли;
				КонецЕсли;			
				
				Для каждого ЭлементМетки Из СписокМетокПереопределяемый Цикл
					ДобавитьМетку2(СписокМеток, ЭлементМетки.Значение, ЭлементМетки.Представление);
				КонецЦикла;

				РассчитатьДлительностьВыполненияГруппШагов(СтруктураВыгрузки);
				РеальноеИмяФайла = "" + GUID + "-result.json";
				ЗаписатьОбъектВJson(СтруктураВыгрузки, РеальноеИмяФайла, ПараметрыОтчетаУФ.МассивXMLОтчетаAllure);
				
				Если МассивШаговBefore.Количество() > 0 Тогда
					СтруктураШаговКонтекста = ПолучитьОписаниеКонтекстныхШаговАллюр2();
					СтруктураШаговКонтекста.uuid = Строка(Новый УникальныйИдентификатор);
					СтруктураШаговКонтекста.name = "Контекст_" + СтруктураВыгрузки.name;
					СтруктураШаговКонтекста.description =  "";
					СтруктураШаговКонтекста.children.Добавить(Строка(GUID));
					СтруктураШаговКонтекста.Вставить("befores", Новый Массив());
					
					ВремяНачала = 0;
					ВремяОкончания = 0;
					СоответствиеГрупп = Новый Соответствие;
					СоответствиеГрупп.Вставить("УдалятьРодителейПриСмене", Истина);
					Для Сч = 0 По МассивШаговBefore.ВГраница() Цикл
						
						ЭлементМассива = МассивШаговBefore.Получить(Сч);
						
						ЗаписатьВыполнениеШагаАллюр2(
						СтруктураШаговКонтекста.befores,
						ДеревоТестов,
						ЭлементМассива,
						СоответствиеГрупп, 
						ПараметрыОтчетаУФ.МассивXMLОтчетаAllure,
						СтруктураВыгрузки,
						ДопПараметрыАллюр2
						);
						
					КонецЦикла;
					РеальноеИмяФайла = "" + GUID + "-container.json";
					РассчитатьДлительностьВыполненияГруппШагов(СтруктураШаговКонтекста);
					ЗаписатьОбъектВJson(СтруктураШаговКонтекста, РеальноеИмяФайла, ПараметрыОтчетаУФ.МассивXMLОтчетаAllure);
				КонецЕсли;
				
				
			КонецЕсли; 
		ИначеЕсли СтрСтроки.Тип = "Шаг" Тогда
			Если СтрСтроки.Родитель.ДопТип = "СтруктураСценария" Тогда
				// его не ненадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаАллюр2(СтрСтроки, ДеревоТестов, ДанныеАллюрМеток, ДопПараметрыАллюр2); 
			КонецЕсли; 
		Иначе	
			ОбойтиДеревоДляОтчетаАллюр2(СтрСтроки, ДеревоТестов, ДанныеАллюрМеток, ДопПараметрыАллюр2); 
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

Процедура СтрокаДереваПоИдСтрокиРекурсивно(Дерево, Результат)
	Для Каждого ТекСтрока Из Дерево.Строки Цикл
		Результат.Вставить(ТекСтрока.ИдСтроки, ТекСтрока);
		СтрокаДереваПоИдСтрокиРекурсивно(ТекСтрока, Результат)
	КонецЦикла;	 
КонецПроцедуры 

Функция СтрокаДереваПоИдСтроки(Дерево)
	Результат = Новый Соответствие;
	СтрокаДереваПоИдСтрокиРекурсивно(Дерево, Результат);
	Возврат Результат; 
КонецФункции	 

Процедура СформироватьОтчетАллюр2(СтруктураОФ, ДеревоТестовПарам, ИмяСборки) Экспорт
	Перем СтарыйКаталог, ИмяФайла;
	
	ОтчетВРежимеУФ = Ложь;
	
	ДанныеАллюрМеток = Новый ТаблицаЗначений;
	
	Если СтруктураОФ = Неопределено Тогда
		ВызватьИсключение "Не поддерживаем ОФ";
	КонецЕсли;
	
	ИмяТекущейСборки = ИмяСборки;
	ОтчетВРежимеУФ = Истина;
	ПараметрыОтчетаУФ    = СтруктураОФ;
		
	СтруктураОФ.Свойство("ДанныеАллюрМеток", ДанныеАллюрМеток);
		
	МассивXMLОтчетаAllure = Новый Массив;
	СтруктураОФ.Вставить("МассивXMLОтчетаAllure", МассивXMLОтчетаAllure);
	
	ДопПараметрыАллюр2 = Новый Структура;
	ДопПараметрыАллюр2.Вставить("КешИменПриложенныхФайлов", Новый Соответствие);
	ДопПараметрыАллюр2.Вставить("ГруппыШагов", Новый Соответствие);
	ДопПараметрыАллюр2.Вставить("СтрокаДереваПоИдСтроки", СтрокаДереваПоИдСтроки(ДеревоТестовПарам));
	ОбойтиДеревоДляОтчетаАллюр2(ДеревоТестовПарам, ДеревоТестовПарам, ДанныеАллюрМеток, ДопПараметрыАллюр2);
	ДопПараметрыАллюр2.СтрокаДереваПоИдСтроки.Очистить();
КонецПроцедуры

Функция ИспользоватьУровеньОтчета(ЗначениеГруппировки)
	
	Результат = Не (НРег(ЗначениеГруппировки) = "неиспользовать"
						ИЛИ НРег(ЗначениеГруппировки) = "donotuse");
						
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область jUnit

Функция Определить_classname(ДопПараметры, МассивТегов, РезультатПрохожденияТестовСценария, СтрСтроки)
	Если (СтрСтроки.Статус = "Failed") Тогда
		Для Каждого Элем Из МассивТегов Цикл
			Если НРег(Элем.Тег) <> "classname=moduleexceptionpath" Тогда
				Продолжить;
			КонецЕсли;
			ИсходнаяСтрока = РезультатПрохожденияТестовСценария.ОписаниеОшибки;
				
			Поз1 = Найти(ИсходнаяСтрока, "{");
			Поз2 = Найти(ИсходнаяСтрока, "}:");
				
			Если Поз1 = 0 ИЛИ Поз2 = 0 ИЛИ Поз1 > Поз2 Тогда
				Возврат ИсходнаяСтрока;
			КонецЕсли;	 
			
			ИсходнаяСтрока = Сред(ИсходнаяСтрока, Поз1 + 1, Поз2 - Поз1 - 1);
			Возврат ИсходнаяСтрока;
		КонецЦикла;	 
	КонецЕсли;	 
	
	classname = ДопПараметры.ТекущаяФичаИмя;
	
	Если ДопПараметры.ТекУровеньКаталога >= 2 Тогда
		classname = ДопПараметры.УровниКаталогов[0] + "." + ДопПараметры.ТекущаяФичаИмя;
	КонецЕсли;	 
	
	Возврат classname;
КонецФункции	

Процедура ОбойтиДеревоДляОтчетаjUnit(Дерево, ЗаписьXML, ДопПараметры, ДанныеФичи = Неопределено)
	ДелительМиллисек = 1000;
	Для каждого СтрСтроки Из Дерево.Строки Цикл
		Если СтрСтроки.Тип = "Фича" Тогда
			
			ДопПараметры.Вставить("ТекущаяФичаИмя", СтрСтроки.Имя);
			
			МассивСценариев = Новый Массив;
			
			ДанныеФичи = Новый Структура;
			ДанныеФичи.Вставить("МассивСценариев", МассивСценариев);
			ДанныеФичи.Вставить("errors", 0);
			ДанныеФичи.Вставить("skipped", 0);
			ДанныеФичи.Вставить("tests", 0);
			ДанныеФичи.Вставить("failures", 0);
			ДанныеФичи.Вставить("time", 0);
			
			ОбойтиДеревоДляОтчетаjUnit(СтрСтроки, ЗаписьXML, ДопПараметры, ДанныеФичи);
			
			ПрефиксИмениСценария = "";
			Если ДобавлятьКИмениСценарияУсловияВыгрузки Тогда
				ПрефиксИмениСценария = ПолучитьПрефиксИмениСценария();
			КонецЕсли;	 

			ЗаписьXML.ЗаписатьНачалоЭлемента("testsuite");
			ЗаписьXML.ЗаписатьАтрибут("name", СтрСтроки.Имя);
			ЗаписьXML.ЗаписатьАтрибут("errors", Формат(ДанныеФичи.errors, "ЧГ=; ЧН=0"));
			ЗаписьXML.ЗаписатьАтрибут("skipped", Формат(ДанныеФичи.skipped, "ЧГ=; ЧН=0"));
			ЗаписьXML.ЗаписатьАтрибут("tests", Формат(ДанныеФичи.tests, "ЧГ=; ЧН=0"));
			ЗаписьXML.ЗаписатьАтрибут("failures", Формат(ДанныеФичи.failures, "ЧГ=; ЧН=0"));
			ЗаписьXML.ЗаписатьАтрибут("time", Формат(ДанныеФичи.time / ДелительМиллисек, "ЧГ=; ЧН=0"));

			Для Каждого Сценарий Из МассивСценариев Цикл
				ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
				
				Если ДобавлятьКИмениСценарияУсловияВыгрузки Тогда
					ЗаписьXML.ЗаписатьАтрибут("name", ПрефиксИмениСценария + Сценарий.name);
				Иначе	
					ЗаписьXML.ЗаписатьАтрибут("name", Сценарий.name);
				КонецЕсли;	 
				ЗаписьXML.ЗаписатьАтрибут("classname", Сценарий.classname);
				ЗаписьXML.ЗаписатьАтрибут("time", Формат(Сценарий.time / ДелительМиллисек, "ЧГ=; ЧН=0"));
				Если Сценарий.Статус = "Failed" Тогда
					ТекстОшибкиКратко = "";
					Если ТипЗнч(Сценарий.СтрокаСценария.ПроизвольныеЗначения) = Тип("Структура") Тогда
						Если Сценарий.СтрокаСценария.ПроизвольныеЗначения.Свойство("ТекстОшибкиКратко") Тогда
							ТекстОшибкиКратко = Сценарий.СтрокаСценария.ПроизвольныеЗначения.ТекстОшибкиКратко;
						КонецЕсли;	 
					КонецЕсли;	 
					
					ОшибкаAssert = Ложь;
					Если ТипЗнч(Сценарий.СтрокаСценария.ПроизвольныеЗначения) = Тип("Структура") Тогда
						Если Сценарий.СтрокаСценария.ПроизвольныеЗначения.Свойство("ОшибкаAssert") Тогда
							ОшибкаAssert = Сценарий.СтрокаСценария.ПроизвольныеЗначения.ОшибкаAssert;
						КонецЕсли;	 
					КонецЕсли;	 
					
					ПолныйТекстОшибкиjUnut = ПолныйТекстОшибкиjUnut(Сценарий.message, ДопПараметры);
					
					Если ОшибкаAssert Тогда
						ЗаписьXML.ЗаписатьНачалоЭлемента("failure");
						ЗаписьXML.ЗаписатьНачалоЭлемента("expected");
						ЗаписьXML.ЗаписатьТекст(ЗначениеВСтрокуjUnit(Сценарий.СтрокаСценария.ПроизвольныеЗначения.ЗначениеExpected));
						ЗаписьXML.ЗаписатьКонецЭлемента();
						ЗаписьXML.ЗаписатьНачалоЭлемента("actual");
						ЗаписьXML.ЗаписатьТекст(ЗначениеВСтрокуjUnit(Сценарий.СтрокаСценария.ПроизвольныеЗначения.ЗначениеActual));
						ЗаписьXML.ЗаписатьКонецЭлемента();
					Иначе
						ЗаписьXML.ЗаписатьНачалоЭлемента("error");						
					КонецЕсли;	 
					
					ЗаписьXML.ЗаписатьТекст(ПолныйТекстОшибкиjUnut);					
					ЗаписьXML.ЗаписатьКонецЭлемента();
					
					РезультатПрохождения = ПолучитьРезультатПрохожденияТестовСценария(Сценарий.СтрокаСценария);
					
					Если ДелатьСкриншотПриВозникновенииОшибки И СкриншотыjUnit 
							И РезультатПрохождения.МассивСкриншотов.Количество() Тогда
						
						ЗаписьXML.ЗаписатьНачалоЭлемента("system-out");
						
							Если РезультатПрохождения.МассивСкриншотов[0].Свойство("ИсходноеИмяФайла") Тогда
								ЗаписьXML.ЗаписатьТекст(ПриложитьСкриншотJUnit(РезультатПрохождения.МассивСкриншотов[0].ИсходноеИмяФайла));
							Иначе
								ЗаписьXML.ЗаписатьТекст(ПриложитьСкриншотJUnit(РезультатПрохождения.МассивСкриншотов[0].ИмяФайла));
							КонецЕсли;	 
						
						ЗаписьXML.ЗаписатьКонецЭлемента();
						
					КонецЕсли;
					
				ИначеЕсли Сценарий.Статус = "Pending" Тогда
					ЗаписьXML.ЗаписатьНачалоЭлемента("skipped");
					ЗаписьXML.ЗаписатьКонецЭлемента();
				КонецЕсли;	 
				
				ЗаписьXML.ЗаписатьКонецЭлемента();
			КонецЦикла;	

			Если МассивСценариев.Количество() > 0 И ТипЗнч(МассивСценариев[0].СтрокаСценария.ПроизвольныеЗначения) = Тип("Структура") Тогда
				ПроизвольныеЗначения = МассивСценариев[0].СтрокаСценария.ПроизвольныеЗначения;
				
				properties = Новый Массив;
				Если (ПроизвольныеЗначения.Свойство("МассивТегов") И ТипЗнч(ПроизвольныеЗначения.МассивТегов) = Тип("Массив")) Тогда
					
					Для Каждого ДанныеТега Из ПроизвольныеЗначения.МассивТегов Цикл
						Поз = Найти(ДанныеТега.ТегИсходный, "=");
						Если Поз > 0 Тогда
							Имя      = Лев(ДанныеТега.ТегИсходный, Поз - 1);
							Значение = Сред(ДанныеТега.ТегИсходный, Поз + 1);
							
							property = Новый Структура;
							property.Вставить("Имя", Имя);
							property.Вставить("Значение", Значение);
							
							properties.Добавить(property);
						КонецЕсли;	 
					КонецЦикла;	 
				КонецЕсли;
				
				Если  ДопПараметры.Свойство("ЛогОшибки") И (ТипЗнч(ДопПараметры.ЛогОшибки) = Тип("Структура")) Тогда
					Для Каждого Элемент Из ДопПараметры.ЛогОшибки Цикл
						property = Новый Структура;
						property.Вставить("Имя", Элемент.Ключ);
						Если ТипЗнч(Элемент.Значение) = Тип("Булево") Тогда
							ЗначениеЭлемента = ?(Элемент.Значение, "true", "false");
						ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Массив") Тогда
							ЗначениеЭлемента = "";
							Для Каждого Элем Из Элемент.Значение Цикл
								ЗначениеЭлемента = ЗначениеЭлемента + Строка(Элем) + ";";
							КонецЦикла;	
							ЗначениеЭлемента = Лев(ЗначениеЭлемента, СтрДлина(ЗначениеЭлемента) - 1);
						Иначе
							ЗначениеЭлемента = Строка(Элемент.Значение);
						КонецЕсли;	
						property.Вставить("Значение", ЗначениеЭлемента);
							
						properties.Добавить(property);
					КонецЦикла;	 
				КонецЕсли;

					
				Если properties.Количество() > 0 Тогда
						
					ЗаписьXML.ЗаписатьНачалоЭлемента("properties");
					Для Каждого property Из properties Цикл
						ЗаписьXML.ЗаписатьНачалоЭлемента("property");
						ЗаписьXML.ЗаписатьАтрибут("name", property.Имя);
						ЗаписьXML.ЗаписатьАтрибут("value", property.Значение);
						ЗаписьXML.ЗаписатьКонецЭлемента();
					КонецЦикла;	 
					ЗаписьXML.ЗаписатьКонецЭлемента();
				КонецЕсли;	 
			КонецЕсли;	 

			
			ЗаписьXML.ЗаписатьКонецЭлемента();
			
		ИначеЕсли (СтрСтроки.Тип = "Сценарий") ИЛИ (СтрСтроки.Тип = "Пример") Тогда
			Если (СтрСтроки.ДопТип = "Контекст") Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий включается в каждый сценарий
				
			ИначеЕсли (СтрСтроки.ДопТип = "СтруктураСценария") ИЛИ (СтрСтроки.Строки.Количество() = 0) Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаjUnit(СтрСтроки, ЗаписьXML, ДопПараметры, ДанныеФичи);
			Иначе
				
				РезультатПрохожденияТестовСценария = ПолучитьРезультатПрохожденияТестовСценария(СтрСтроки);
				
				Если РезультатПрохожденияТестовСценария = Неопределено Тогда
					Продолжить;
				КонецЕсли; 
				
				ЛогОшибки = ?(РезультатПрохожденияТестовСценария.Свойство("ЛогОшибки"),РезультатПрохожденияТестовСценария.ЛогОшибки, Неопределено);
				ДопПараметры.Вставить("ЛогОшибки", ЛогОшибки);
				
				Сценарий          = Новый Структура;
				Сценарий.Вставить("СтрокаСценария", СтрСтроки);
				ДанныеФичи.МассивСценариев.Добавить(Сценарий);

				МассивТегов = Новый Массив;
				
				Если СтрСтроки.Тип = "Пример" Тогда
					Сценарий.Вставить("name", СтрСтроки.Родитель.Родитель.Имя + " №" + (СтрСтроки.Родитель.Строки.Индекс(СтрСтроки)));//для структуры сценария надо вести нумерацию
					Если ТипЗнч(СтрСтроки.Родитель.ПроизвольныеЗначения) = Тип("Структура") Тогда
						Если СтрСтроки.Родитель.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
							МассивТегов = СтрСтроки.Родитель.ПроизвольныеЗначения.МассивТегов;
						КонецЕсли;	 
					КонецЕсли;	 
				Иначе	
					Сценарий.Вставить("name", СтрСтроки.Имя);
					Если ТипЗнч(СтрСтроки.ПроизвольныеЗначения) = Тип("Структура") Тогда
						Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
							МассивТегов = СтрСтроки.ПроизвольныеЗначения.МассивТегов;
						КонецЕсли;	 
					КонецЕсли;	 
				КонецЕсли; 
				
				classname = Определить_classname(ДопПараметры, МассивТегов, РезультатПрохожденияТестовСценария, СтрСтроки);
				Сценарий.Вставить("classname", classname);
				
				Если РезультатПрохожденияТестовСценария.Свойство("ВремяОкончания") И РезультатПрохожденияТестовСценария.Свойство("ВремяНачала") Тогда
					Сценарий.Вставить("time", РезультатПрохожденияТестовСценария.ВремяОкончания - РезультатПрохожденияТестовСценария.ВремяНачала);
				Иначе	
					Сценарий.Вставить("time", 0);
				КонецЕсли;	 
				ДанныеФичи.time = ДанныеФичи.time + Сценарий.time;

				Если СтрСтроки.ДопТип = "СтруктураСценария" Тогда
					ОбойтиДеревоДляОтчетаjUnit(СтрСтроки, ЗаписьXML, ДопПараметры, ДанныеФичи);
				КонецЕсли;	 
				
				Сценарий.Вставить("Статус", СтрСтроки.Статус);
				
				ДанныеФичи.tests = ДанныеФичи.tests + 1;
				
				Если (СтрСтроки.Статус = "Failed")  Тогда
					Сценарий.Вставить("message", РезультатПрохожденияТестовСценария.ОписаниеОшибки);
					ДанныеФичи.failures = ДанныеФичи.failures + 1;
				ИначеЕсли (СтрСтроки.Статус = "Pending") Тогда
					Сценарий.Вставить("message", РезультатПрохожденияТестовСценария.ОписаниеОшибки);
					ДанныеФичи.skipped = ДанныеФичи.skipped + 1;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли СтрСтроки.Тип = "Шаг" Тогда
			Если СтрСтроки.Родитель.ДопТип = "СтруктураСценария" Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаjUnit(СтрСтроки, ЗаписьXML, ДопПараметры, ДанныеФичи);
			КонецЕсли; 
		ИначеЕсли СтрСтроки.Тип = "Каталог" Тогда
			
			ДопПараметры.ТекУровеньКаталога = ДопПараметры.ТекУровеньКаталога + 1;
			// Запоминаем уровни каталогов. Нас интересует только уровень 2 и 3. Т.е. если каталоги лежат как
			// features\Core\FeatureLoad, то мы запомним только Core\FeatureLoad
			Если ДопПараметры.ТекУровеньКаталога = 2 Тогда
				ДопПараметры.УровниКаталогов[0] = СтрСтроки.Имя;
			ИначеЕсли ДопПараметры.ТекУровеньКаталога = 3 Тогда
				ДопПараметры.УровниКаталогов[1] = СтрСтроки.Имя;
			КонецЕсли;	 

			ОбойтиДеревоДляОтчетаjUnit(СтрСтроки, ЗаписьXML, ДопПараметры, ДанныеФичи);

			ДопПараметры.ТекУровеньКаталога = ДопПараметры.ТекУровеньКаталога - 1;
		Иначе	
			ОбойтиДеревоДляОтчетаjUnit(СтрСтроки, ЗаписьXML, ДопПараметры, ДанныеФичи);
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

Процедура СформироватьОтчетjUnit(СтруктураОФ) Экспорт
	
	Перем СтарыйКаталог, ПутьКВременномуКаталогуНаСервере, ИмяФайла;
	
	СтарыйКаталог = КаталогВыгрузкиjUnit;
	
	ОтчетВРежимеУФ = Ложь;
	Если НЕ СтруктураОФ.ЭтоОФ Тогда
		ОтчетВРежимеУФ = Истина;
		МассивXMLОтчетаjUnit = Новый Массив;
		СтруктураОФ.Вставить("МассивXMLОтчетаjUnit", МассивXMLОтчетаjUnit);

		ПараметрыОтчетаУФ    = СтруктураОФ;
	КонецЕсли;

	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
	
	// делаем запись без BOM
	ЗТ = Новый ЗаписьТекста(ИмяВременногоФайла, "Windows-1251",, Ложь); 
	ЗТ.Закрыть();
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.ОткрытьФайл(ИмяВременногоФайла, "UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	ЗаписьXML.ЗаписатьНачалоЭлемента("testsuites");

	// Определим уровни иерархии для отчета
	// если был загружен каталог - тогда фичи буду браться начиная со второго уровня каталога, чтобы не тратить уровень
	// иерархии на очевидное
	
	// JUnit позволяет создать три уровня иерархии для просмотра в Jenkins http://stackoverflow.com/questions/38118602/jenkins-test-result-parsing
	// т.е. может быть два уровня каталогов и третий уровень с тестами
	
	ДопПараметры = Новый Структура;
	ДопПараметры.Вставить("УровниКаталогов", Новый Массив);
	ДопПараметры.УровниКаталогов.Добавить("");
	ДопПараметры.УровниКаталогов.Добавить("");
	
	ДопПараметры.Вставить("ТекУровеньКаталога", 0);
	Если СтруктураОФ.Свойство("СтрокаТехническиеДанные") Тогда
		ДопПараметры.Вставить("СтрокаТехническиеДанные", СтруктураОФ.СтрокаТехническиеДанные);
	Иначе	
		ДопПараметры.Вставить("СтрокаТехническиеДанные", Неопределено);
	КонецЕсли;
	
	ОбойтиДеревоДляОтчетаjUnit(ДеревоТестов, ЗаписьXML, ДопПараметры);
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.Закрыть();
	
	ДД = Новый ДвоичныеДанные(ИмяВременногоФайла);
	СтруктураОФ.Вставить("xml", ДД);
	
	УдалитьФайлы(ИмяВременногоФайла);
	
КонецПроцедуры

Функция ПриложитьСкриншотJUnit(ФайлСкриншота)
	
	СтрокаШаблон = "[[ATTACHMENT|%1/%2]]";
	ОтносительныйПутьККаталогуСкриншотов = СтрЗаменить(
												СтрЗаменить(КаталогВыгрузкиСкриншотов, "\", "/")
												, СтрЗаменить(КаталогПроекта, "\", "/")
												, "");
												
	Если Лев(ОтносительныйПутьККаталогуСкриншотов, 1) <> "/" Тогда
		
		ОтносительныйПутьККаталогуСкриншотов = "/" + ОтносительныйПутьККаталогуСкриншотов;
		
	КонецЕсли;
												
	Результат = СтрЗаменить(СтрокаШаблон, "%1", ОтносительныйПутьККаталогуСкриншотов);
	Результат = СтрЗаменить(Результат,    "%2", ФайлСкриншота);
	
	Возврат Результат;
	
КонецФункции

Функция СведенияОСкриншотахJUnit(МассивРезультатов)
	
	Результат = Новый Соответствие;
	
	Для Каждого Эл Из МассивРезультатов Цикл
		
		Если Эл.МассивСкриншотов.Количество() Тогда
			
			Результат.Вставить(Эл.ИДСтроки, Эл.МассивСкриншотов[0]);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Cucumber

Функция ЭтоЦелоеЧисло(Стр)
	Для Ккк = 1 По СтрДлина(Стр) Цикл
		Символ = Сред(Стр, Ккк, 1);
		Если    Символ = "0"
			Или Символ = "1"
			Или Символ = "2"
			Или Символ = "3"
			Или Символ = "4"
			Или Символ = "5"
			Или Символ = "6"
			Или Символ = "7"
			Или Символ = "8"
			Или Символ = "9"
			Тогда
			// это цифра
		Иначе
			Возврат Ложь;	
		КонецЕсли;	 
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

Функция ПолучитьНомерСтрокиИзПути(Стр)
	Длина = СтрДлина(Стр);
	Рез   = "";
	Для Ккк = 1 По Длина Цикл
		Символ = Сред(Стр, Длина - Ккк + 1, 1);
		Если ЭтоЦелоеЧисло(Символ) Тогда
			Рез = Символ + Рез;
		Иначе	
			Прервать;
		КонецЕсли;	 
	КонецЦикла; 
	
	Если Рез = "" Тогда
		Рез = "0";
	КонецЕсли;	 
	
	Возврат Число(Рез);
КонецФункции	

Процедура ПолучитьПервоеСлово(Знач Стр, keyword, Name)
	Стр = СокрЛП(СтрЗаменить(Стр, Символы.Таб," "));
	Поз = Найти(Стр," ");
	keyword = Лев(Стр, Поз - 1);
	Name = СокрЛП(Сред(Стр, Поз + 1));
КонецПроцедуры

Процедура ОбойтиДеревоДляОтчетаCucumberJson(Дерево, ЗаписьJson, ДопПараметры, ДанныеФичи = Неопределено)
	Для каждого СтрСтроки Из Дерево.Строки Цикл
		Если      СтрСтроки.Тип = "Фича" Тогда
			
			ЗаписьJson.ЗаписатьНачалоОбъекта(); //начало фичи
			
			ДопПараметры.Вставить("ТекущаяФичаИмя", СтрСтроки.Имя);
			
			МассивСценариев = Новый Массив;
			
			ДанныеФичи = Новый Структура;
			ДанныеФичи.Вставить("МассивСценариев", МассивСценариев);
			ДанныеФичи.Вставить("errors", 0);
			ДанныеФичи.Вставить("skipped", 0);
			ДанныеФичи.Вставить("tests", 0);
			ДанныеФичи.Вставить("failures", 0);
			ДанныеФичи.Вставить("time", 0);
			
			ОбойтиДеревоДляОтчетаCucumberJson(СтрСтроки, ЗаписьJson, ДопПараметры, ДанныеФичи);
			
			ПрефиксИмениСценария = "";
			Если ДобавлятьКИмениСценарияУсловияВыгрузки Тогда
				ПрефиксИмениСценария = ПолучитьПрефиксИмениСценария();
			КонецЕсли;	 

			ЗаписьJSON.ЗаписатьИмяСвойства("uri");
			ЗаписьJSON.ЗаписатьЗначение(СтрСтроки.Имя);
			
			ЗаписьJSON.ЗаписатьИмяСвойства("keyword");
			ЗаписьJSON.ЗаписатьЗначение("Feature");
			
			ЗаписьJSON.ЗаписатьИмяСвойства("id");
			ЗаписьJSON.ЗаписатьЗначение(Транслит(ПрефиксИмениСценария + СтрСтроки.ПолныйПуть));
			
			ЗаписьJSON.ЗаписатьИмяСвойства("name");
			ЗаписьJSON.ЗаписатьЗначение(ПрефиксИмениСценария + СтрСтроки.Имя);

			ЗаписьJSON.ЗаписатьИмяСвойства("description");
			ЗаписьJSON.ЗаписатьЗначение("");

			// теги фичи
			ЗаписьJSON.ЗаписатьИмяСвойства("tags");
			ЗаписьJSON.ЗаписатьНачалоМассива();
			Если ТипЗнч(СтрСтроки.ПроизвольныеЗначения) = Тип("Структура")  Тогда
				МассивТегов = Новый Массив;
				Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
					МассивТегов = СтрСтроки.ПроизвольныеЗначения.МассивТегов;
				КонецЕсли;	 
				
				Для Каждого СвойстваТега Из МассивТегов Цикл
					ЗаписьJson.ЗаписатьНачалоОбъекта();
					
					ЗаписьJSON.ЗаписатьИмяСвойства("name");
					ЗаписьJSON.ЗаписатьЗначение("@" + СвойстваТега.Тег);
					
					ЗаписьJSON.ЗаписатьИмяСвойства("line");
					ЗаписьJSON.ЗаписатьЗначение(СвойстваТега.НомерСтроки);
					
					ЗаписьJson.ЗаписатьКонецОбъекта();
				КонецЦикла;	
			КонецЕсли;	 
			ЗаписьJSON.ЗаписатьКонецМассива();

			ЗаписьJSON.ЗаписатьИмяСвойства("elements");
			ЗаписьJSON.ЗаписатьНачалоМассива(); //elements

			НомерСценария = 0;
			Для Каждого Сценарий Из МассивСценариев Цикл
				НомерСценария = НомерСценария + 1;
				ЗаписьJson.ЗаписатьНачалоОбъекта();
				
				ЗаписьJSON.ЗаписатьИмяСвойства("keyword");
				ЗаписьJSON.ЗаписатьЗначение("Scenario");

				ЗаписьJSON.ЗаписатьИмяСвойства("id");
				ЗаписьJSON.ЗаписатьЗначение(Транслит(ДопПараметры.ТекущаяФичаИмя + "-" +  Сценарий.name + НомерСценария));
				
				ЗаписьJSON.ЗаписатьИмяСвойства("name");
				ЗаписьJSON.ЗаписатьЗначение(Сценарий.name);
				
				ЗаписьJSON.ЗаписатьИмяСвойства("line");
				ЗаписьJSON.ЗаписатьЗначение(Сценарий.НомерСтрокиВФиче);
				
				ЗаписьJSON.ЗаписатьИмяСвойства("description");
				ЗаписьJSON.ЗаписатьЗначение("");
				
				// теги сценария
				ЗаписьJSON.ЗаписатьИмяСвойства("tags");
				ЗаписьJSON.ЗаписатьНачалоМассива();
				Если Сценарий.МассивТегов <> Неопределено Тогда
					Для Каждого СвойстваТега Из Сценарий.МассивТегов Цикл
						ЗаписьJson.ЗаписатьНачалоОбъекта();
						
						ЗаписьJSON.ЗаписатьИмяСвойства("name");
						ЗаписьJSON.ЗаписатьЗначение("@" + СвойстваТега.Тег);
						
						ЗаписьJSON.ЗаписатьИмяСвойства("line");
						ЗаписьJSON.ЗаписатьЗначение(СвойстваТега.НомерСтроки);
						
						ЗаписьJson.ЗаписатьКонецОбъекта();
					КонецЦикла;	
				КонецЕсли;	 
				ЗаписьJSON.ЗаписатьКонецМассива();

				ЗаписьJSON.ЗаписатьИмяСвойства("type");
				ЗаписьJSON.ЗаписатьЗначение("scenario");
				
				// шаги сценария
				ЗаписьJSON.ЗаписатьИмяСвойства("steps");
				ЗаписьJSON.ЗаписатьНачалоМассива();
				ЕстьУпавшийШаг        = Ложь;
				ЕстьНеРеализованыйШаг = Ложь;
				Для Каждого Шаг Из Сценарий.МассивШагов Цикл
					ЗаписьJson.ЗаписатьНачалоОбъекта();
					
					keyword = "";
					name    = "";
					ПолучитьПервоеСлово(Шаг.name, keyword, name);
					
					ЗаписьJSON.ЗаписатьИмяСвойства("keyword");
					ЗаписьJSON.ЗаписатьЗначение(keyword);
					
					ЗаписьJSON.ЗаписатьИмяСвойства("name");
					ЗаписьJSON.ЗаписатьЗначение(name);
					
					ЗаписьJSON.ЗаписатьИмяСвойства("line");
					ЗаписьJSON.ЗаписатьЗначение(Шаг.НомерСтрокиВФиче);
					
					МассивРисунков = Неопределено;
					Если Шаг.Свойство("embeddings", МассивРисунков) И МассивРисунков.Количество() > 0 Тогда
						
						ЗаписьJson.ЗаписатьИмяСвойства("embeddings");
						ЗаписьJson.ЗаписатьНачалоМассива();
						Для каждого Элемент Из МассивРисунков Цикл
							
							ЗаписьJson.ЗаписатьНачалоОбъекта();
							ЗаписьJson.ЗаписатьИмяСвойства("mime_type");
							ЗаписьJson.ЗаписатьЗначение(Элемент["mime_type"]);
							
							ЗаписьJson.ЗаписатьИмяСвойства("data");
							ЗаписьJson.ЗаписатьЗначение(Формат(Элемент["data"], "ЧГ=; ЧН=0"));
							ЗаписьJson.ЗаписатьКонецОбъекта();
						КонецЦикла;
						
						ЗаписьJSON.ЗаписатьКонецМассива();
					КонецЕсли;

					// статус шага
					ЗаписьJSON.ЗаписатьИмяСвойства("result");
					ЗаписьJson.ЗаписатьНачалоОбъекта();
					
					ЗаписьJSON.ЗаписатьИмяСвойства("status");
					Если Шаг.Статус = "Failed" Тогда
						ЗаписьJSON.ЗаписатьЗначение("failed");
						
						ЗаписьJSON.ЗаписатьИмяСвойства("error_message");
						Если Шаг.Свойство("message") Тогда
							ЗаписьJSON.ЗаписатьЗначение(Шаг.message);
						Иначе	
							// значит ошибка возникла не в шагах, а раньше, например в ПередНачаломСценария()
							ЗаписьJSON.ЗаписатьЗначение(Сценарий.message);
						КонецЕсли;	 
						
						ЕстьУпавшийШаг = Истина;
					ИначеЕсли Шаг.Статус = "Pending" Тогда
						Если ЕстьУпавшийШаг Тогда
							ЗаписьJSON.ЗаписатьЗначение("skipped");
						Иначе	
							ЗаписьJSON.ЗаписатьЗначение("pending");
							ЕстьНеРеализованыйШаг = Истина;
						КонецЕсли;	 
					Иначе	
						Если ЕстьУпавшийШаг ИЛИ ЕстьНеРеализованыйШаг Тогда
							ЗаписьJSON.ЗаписатьЗначение("skipped");
						Иначе	
							ЗаписьJSON.ЗаписатьЗначение("passed");
						КонецЕсли;	 
					КонецЕсли;	 
					
					ЗаписьJSON.ЗаписатьИмяСвойства("duration");
					ЗаписьJSON.ЗаписатьЗначение((Шаг.stop - Шаг.start) * 1000000);
					
					ЗаписьJson.ЗаписатьКонецОбъекта();

					ЗаписьJson.ЗаписатьКонецОбъекта();
				КонецЦикла;	
				ЗаписьJSON.ЗаписатьКонецМассива();

				ЗаписьJson.ЗаписатьКонецОбъекта();
			КонецЦикла;	

			ЗаписьJSON.ЗаписатьКонецМассива(); //elements
			ЗаписьJson.ЗаписатьКонецОбъекта(); //фича
		ИначеЕсли (СтрСтроки.Тип = "Сценарий") ИЛИ (СтрСтроки.Тип = "Пример") Тогда
			Если (СтрСтроки.ДопТип = "Контекст") Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий включается в каждый сценарий
				
			ИначеЕсли (СтрСтроки.ДопТип = "СтруктураСценария") ИЛИ (СтрСтроки.Строки.Количество() = 0) Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаCucumberJson(СтрСтроки, ЗаписьJson, ДопПараметры, ДанныеФичи);
			Иначе
				
				РезультатПрохожденияТестовСценария = ПолучитьРезультатПрохожденияТестовСценария(СтрСтроки);
				
				Если РезультатПрохожденияТестовСценария = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Сценарий          = Новый Структура;
				ДанныеФичи.МассивСценариев.Добавить(Сценарий);
				
				МассивТегов = Новый Массив;
				
				Если СтрСтроки.Тип = "Пример" Тогда
					Сценарий.Вставить("name", СтрСтроки.Родитель.Родитель.Имя + " №" + (СтрСтроки.Родитель.Строки.Индекс(СтрСтроки)));//для структуры сценария надо вести нумерацию
				Иначе	
					Сценарий.Вставить("name", СтрСтроки.Имя);
				КонецЕсли; 
				
				classname = Определить_classname(ДопПараметры, МассивТегов, РезультатПрохожденияТестовСценария, СтрСтроки);
				Сценарий.Вставить("classname", classname);
				Сценарий.Вставить("ПолныйПуть", СтрСтроки.ПолныйПуть);
				Если ТипЗнч(СтрСтроки.ПроизвольныеЗначения) = Тип("Структура")  Тогда
					МассивТегов = Новый Массив;
					Если СтрСтроки.ПроизвольныеЗначения.Свойство("МассивТегов") Тогда
						МассивТегов = СтрСтроки.ПроизвольныеЗначения.МассивТегов;
					КонецЕсли;	 
				Иначе	
					МассивТегов = Новый Массив;
				КонецЕсли;	 
				Сценарий.Вставить("МассивТегов", МассивТегов);
				
				Если РезультатПрохожденияТестовСценария.Свойство("ВремяОкончания") Тогда
					Сценарий.Вставить("time", РезультатПрохожденияТестовСценария.ВремяОкончания - РезультатПрохожденияТестовСценария.ВремяНачала);
				Иначе	
					Сценарий.Вставить("time", 0);
				КонецЕсли;	 
				ДанныеФичи.time = ДанныеФичи.time + Сценарий.time;
				
				Сценарий.Вставить("МассивШагов", Новый Массив);
				Сценарий.Вставить("id", ПолучитьНомерСтрокиИзПути(СтрСтроки.ПолныйПуть));
				Сценарий.Вставить("НомерСтрокиВФиче", СтрСтроки.НомерСтрокиВФиче);

				ДанныеШага = Неопределено;
				
				Если СтрСтроки.ДопТип = "СтруктураСценария" Тогда
					ОбойтиДеревоДляОтчетаCucumberJson(СтрСтроки, ЗаписьJson, ДопПараметры, ДанныеФичи);
				Иначе
					Для каждого СтрРезультатПрохожденияТестовШагов Из РезультатПрохожденияТестовСценария.РезультатПрохожденияТестовШагов Цикл
						
						ДанныеШага = Новый Структура;
						ДанныеШага.Вставить("name", СтрРезультатПрохожденияТестовШагов.Имя);
						ДанныеШага.Вставить("start", 0);
						ДанныеШага.Вставить("stop", 0);
						ДанныеШага.Вставить("Статус", СтрРезультатПрохожденияТестовШагов.Статус);
						ДанныеШага.Вставить("НомерСтрокиВФиче", РезультатПрохожденияТестовСценария.НомерСтрокиВФиче);
						
						Если СтрРезультатПрохожденияТестовШагов.ВремяНачала <> Неопределено Тогда
							ДанныеШага.Вставить("start", СтрРезультатПрохожденияТестовШагов.ВремяНачала - РазницаВМилисекундахМеждуЮниксИНачалЭпохи);
							ДанныеШага.Вставить("stop", СтрРезультатПрохожденияТестовШагов.ВремяОкончания - РазницаВМилисекундахМеждуЮниксИНачалЭпохи);
						КонецЕсли;	
						
						Если РезультатПрохожденияТестовСценария.Свойство("МассивСкриншотов") И СтрРезультатПрохожденияТестовШагов.Статус = "Failed" Тогда
							// значит есть скриншоты
							
							ДанныеШага.Вставить("embeddings", Новый Массив);
							
							Для каждого СтруктураСкриншот Из РезультатПрохожденияТестовСценария.МассивСкриншотов Цикл
								СтрокаРисунка = Base64Строка(СтруктураСкриншот.ДвоичныеДанные);
								СтрокаРисунка = СтрЗаменить(СтрокаРисунка, Символы.ВК, "");
								СтрокаРисунка = СтрЗаменить(СтрокаРисунка, Символы.ПС, "");
								СтруктураРисунка = Новый Структура("mime_type, data", "image/png", СтрокаРисунка);
								ДанныеШага["embeddings"].Добавить(СтруктураРисунка);
							КонецЦикла;
						КонецЕсли;
						
						Сценарий.МассивШагов.Добавить(ДанныеШага);
						
					КонецЦикла;
				КонецЕсли;	 
				
				Сценарий.Вставить("Статус", СтрСтроки.Статус);
				
				ДанныеФичи.tests = ДанныеФичи.tests + 1;
				
				Если (СтрСтроки.Статус = "Failed")  Тогда
					Сценарий.Вставить("message", РезультатПрохожденияТестовСценария.ОписаниеОшибки);
					Если ДанныеШага <> Неопределено Тогда
						ДанныеШага.Вставить("message", РезультатПрохожденияТестовСценария.ОписаниеОшибки);
					КонецЕсли;	 
					ДанныеФичи.failures = ДанныеФичи.failures + 1;
				ИначеЕсли (СтрСтроки.Статус = "Pending") Тогда
					Сценарий.Вставить("message", РезультатПрохожденияТестовСценария.ОписаниеОшибки);
					Если ДанныеШага <> Неопределено Тогда
						ДанныеШага.Вставить("message", РезультатПрохожденияТестовСценария.ОписаниеОшибки);
					КонецЕсли;	 
					ДанныеФичи.skipped = ДанныеФичи.skipped + 1;
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли СтрСтроки.Тип = "Шаг" Тогда
			Если СтрСтроки.Родитель.ДопТип = "СтруктураСценария" Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаCucumberJson(СтрСтроки, ЗаписьJSON, ДопПараметры, ДанныеФичи);
			КонецЕсли; 
		ИначеЕсли СтрСтроки.Тип = "Каталог" Тогда
			
			ДопПараметры.ТекУровеньКаталога = ДопПараметры.ТекУровеньКаталога + 1;
			// Запоминаем уровни каталогов. Нас интересует только уровень 2 и 3. Т.е. если каталоги лежат как
			// features\Core\FeatureLoad, то мы запомним только Core\FeatureLoad
			Если ДопПараметры.ТекУровеньКаталога = 2 Тогда
				ДопПараметры.УровниКаталогов[0] = СтрСтроки.Имя;
			ИначеЕсли ДопПараметры.ТекУровеньКаталога = 3 Тогда
				ДопПараметры.УровниКаталогов[1] = СтрСтроки.Имя;
			КонецЕсли;	 

			ОбойтиДеревоДляОтчетаCucumberJson(СтрСтроки, ЗаписьJSON, ДопПараметры, ДанныеФичи);

			ДопПараметры.ТекУровеньКаталога = ДопПараметры.ТекУровеньКаталога - 1;
		Иначе	
			ОбойтиДеревоДляОтчетаCucumberJson(СтрСтроки, ЗаписьJSON, ДопПараметры, ДанныеФичи);
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

Процедура СформироватьОтчетCucumberJson(СтруктураОФ) Экспорт
	Перем СтарыйКаталог, ПутьКВременномуКаталогуНаСервере, ИмяФайла;
	СтарыйКаталог = КаталогВыгрузкиCucumberJson;
	
	ОтчетВРежимеУФ = Ложь;
	Если СтруктураОФ.ЭтоОФ Тогда
		ОтчетВРежимеУФ = Ложь;
	Иначе	
		ОтчетВРежимеУФ = Истина;
		МассивJsonОтчетаCucumberJson = Новый Массив;
		СтруктураОФ.Вставить("МассивJsonОтчетаCucumberJson", МассивJsonОтчетаCucumberJson);

		ПараметрыОтчетаУФ    = СтруктураОФ;
	КонецЕсли;

	ВременныйJson = ПолучитьИмяВременногоФайла("json");
	
	// делаем запись без BOM
	ЗТ = Новый ЗаписьТекста(ВременныйJson, "Windows-1251",, Ложь); 
	ЗТ.Закрыть();
	
	Попытка
		ЗаписьJson = Вычислить("Новый ЗаписьJson()");
		ТиповойJSON = Истина;
	Исключение
		Если ТекущийРежимЗапуска() = РежимЗапускаКлиентскогоПриложения.ОбычноеПриложение Тогда
			ЗаписьJson = ПолучитьФорму("ЗаписьJSON");
		Иначе
			Возврат;
		КонецЕсли;
		ТиповойJSON = Ложь;
	КонецПопытки;
	Если ТиповойJSON Тогда
		ЗаписьJson.ОткрытьФайл(ВременныйJson,, Ложь, Вычислить("Новый ПараметрыЗаписиJSON(,Символы.Таб)"));
	Иначе
		ЗаписьJson.ОткрытьФайл(ВременныйJson, Символы.Таб);
	КонецЕсли;
	
	ЗаписьJson.ЗаписатьНачалоМассива();
	
	ДопПараметры = Новый Структура;
	ДопПараметры.Вставить("УровниКаталогов", Новый Массив);
	ДопПараметры.УровниКаталогов.Добавить("");
	ДопПараметры.УровниКаталогов.Добавить("");
	
	ДопПараметры.Вставить("ТекУровеньКаталога", 0);
	ОбойтиДеревоДляОтчетаCucumberJson(ДеревоТестов, ЗаписьJson, ДопПараметры);
	
	ЗаписьJson.ЗаписатьКонецМассива();
	Если ТиповойJSON Тогда
		ЗаписьJson.Закрыть();
	Иначе
		ЗаписьJson.ЗакрытьФайл();
	КонецЕсли;
	
	ДД = Новый ДвоичныеДанные(ВременныйJson);
	СтруктураОФ.Вставить("Json", ДД);
	УдалитьФайлы(ВременныйJson);
	
КонецПроцедуры

#КонецОбласти

#Область ОтчетСППР

Функция СтруктураФайлаОшибкиСППР()
	
	СтруктураОтчета = Новый Структура;
	СтруктураОтчета.Вставить("ВерсияФормата", "");
	СтруктураОтчета.Вставить("УИ", "");
	СтруктураОтчета.Вставить("ТипОшибки", "");
	СтруктураОтчета.Вставить("ИсходнаяИнформация", "");
	СтруктураОтчета.Вставить("ПорядокВоспроизведения", "");
	СтруктураОтчета.Вставить("ОжидаемоеПоведение", "");
	СтруктураОтчета.Вставить("ВерсияПлатформы", "");
	СтруктураОтчета.Вставить("КлиентОперативнаяПамять", 0);
	СтруктураОтчета.Вставить("КлиентВерсияОС", "");
	СтруктураОтчета.Вставить("КлиентПроцессор", "");
	СтруктураОтчета.Вставить("КлиентТипПлатформы", "");
	СтруктураОтчета.Вставить("КлиентИнформацияПрограммыПросмотра", "");
	СтруктураОтчета.Вставить("КлиентТекущаяДата", Дата(1, 1, 1));
	СтруктураОтчета.Вставить("ОбъектыМетаданных", Новый Массив);
	СтруктураОтчета.Вставить("ИменаФайлов", Новый Массив);
	СтруктураОтчета.Вставить("СерверОперативнаяПамять", 0);
	СтруктураОтчета.Вставить("СерверВерсияОС", "");
	СтруктураОтчета.Вставить("СерверПроцессор", "");
	СтруктураОтчета.Вставить("СерверТипПлатформы", "");
	СтруктураОтчета.Вставить("СерверИнформацияПрограммыПросмотра", "");
	СтруктураОтчета.Вставить("ВерсияКонфигурации", "");
	СтруктураОтчета.Вставить("ИмяКонфигурации", "");
	СтруктураОтчета.Вставить("ДатаОбнаружения", Дата(1, 1, 1));
	СтруктураОтчета.Вставить("Ответственный", "");
	СтруктураОтчета.Вставить("КодСценария", "");
	СтруктураОтчета.Вставить("ИмяСценария", "");
	СтруктураОтчета.Вставить("ДостоверностьОбнаружения", "");
	СтруктураОтчета.Вставить("Срочность", "");
	СтруктураОтчета.Вставить("АдресРепозитория", "");
	
	Возврат СтруктураОтчета;

КонецФункции

Процедура ОбойтиДеревоДляОтчетаСППР(Дерево, ДопПараметры)
	
	Для каждого СтрокаДерева Из Дерево.Строки Цикл
		
		Если СтрокаДерева.Тип = "Фича" Тогда
			
			ДопПараметры.Вставить("ТекущаяФичаИмя", СтрокаДерева.Имя);
			
			МассивСценариев = Новый Массив;
			
			ДанныеФичи = Новый Структура;
			ДанныеФичи.Вставить("МассивСценариев", МассивСценариев);
			ДанныеФичи.Вставить("errors", 0);
			ДанныеФичи.Вставить("skipped", 0);
			ДанныеФичи.Вставить("tests", 0);
			ДанныеФичи.Вставить("failures", 0);
			ДанныеФичи.Вставить("time", 0);
			
			ОбойтиДеревоДляОтчетаСППР(СтрокаДерева, ДопПараметры);
			
			ПрефиксИмениСценария = "";
			Если ДобавлятьКИмениСценарияУсловияВыгрузки Тогда
				ПрефиксИмениСценария = ПолучитьПрефиксИмениСценария();
			КонецЕсли;	 
			
			Для Каждого Сценарий Из МассивСценариев Цикл
				Если Сценарий.Статус = "Failed" Тогда
					ТекстОшибкиКратко = "";
					Если ТипЗнч(Сценарий.СтрокаСценария.ПроизвольныеЗначения) = Тип("Структура") Тогда
						Если Сценарий.СтрокаСценария.ПроизвольныеЗначения.Свойство("ТекстОшибкиКратко") Тогда
							ТекстОшибкиКратко = Сценарий.СтрокаСценария.ПроизвольныеЗначения.ТекстОшибкиКратко;
						КонецЕсли;	 
						
						ОшибкаAssert = Ложь;
						Если Сценарий.СтрокаСценария.ПроизвольныеЗначения.Свойство("ОшибкаAssert") Тогда
							ОшибкаAssert = Сценарий.СтрокаСценария.ПроизвольныеЗначения.ОшибкаAssert;
						КонецЕсли;
						
					КонецЕсли;	 
					
					ПолныйТекстОшибкиjUnut = ПолныйТекстОшибкиjUnut(Сценарий.message, ДопПараметры);
					
				ИначеЕсли Сценарий.Статус = "Pending" Тогда
					
				КонецЕсли;	 
			КонецЦикла;	
			
		ИначеЕсли СтрокаДерева.Тип = "Сценарий" Или СтрокаДерева.Тип = "Пример" Тогда
			Если СтрокаДерева.ДопТип = "Контекст" Тогда
				// его не нужно добавлять в отчет, т.к. этот сценарий включается в каждый сценарий
				
			ИначеЕсли СтрокаДерева.ДопТип = "СтруктураСценария" Или СтрокаДерева.Строки.Количество() = 0 Тогда
				// его не нужно добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаСППР(СтрокаДерева, ДопПараметры);
			Иначе				
				РезультатПрохожденияТестовСценария = ПолучитьРезультатПрохожденияТестовСценария(СтрокаДерева);
				
				Если РезультатПрохожденияТестовСценария = Неопределено Тогда
					Продолжить;
				КонецЕсли; 
							
				МассивТегов = Новый Массив;
			
				Если СтрокаДерева.ДопТип = "СтруктураСценария" Тогда
					ОбойтиДеревоДляОтчетаСППР(СтрокаДерева, ДопПараметры);
				КонецЕсли;	 
					
				Если СтрокаДерева.Статус = "Failed" Или СтрокаДерева.Статус = "Pending" Тогда
					// Записываем xml с ошибкой
					СтруктураОшибки = СтруктураФайлаОшибкиСППР();
					
					СтруктураОшибки.ВерсияФормата = "1.4";
					СтруктураОшибки.УИ = Строка(Новый УникальныйИдентификатор);
					СтруктураОшибки.ТипОшибки = "Ошибка сценария";
					
					ПодробноеОписаниеОшибки = "";
					ОписаниеОшибки = "";
					Если РезультатПрохожденияТестовСценария.Свойство("ОписаниеОшибки") Тогда
						ПодробноеОписаниеОшибкиAllure2(РезультатПрохожденияТестовСценария.ОписаниеОшибки, ОписаниеОшибки, ПодробноеОписаниеОшибки);
					КонецЕсли;	 
					
					СтруктураОшибки.Вставить("ИсходнаяИнформация", ОписаниеОшибки);
					СтруктураОшибки.Вставить("ПорядокВоспроизведения", ПодробноеОписаниеОшибки);
					
					СистемнаяИнформация = Новый СистемнаяИнформация;
					
					СтруктураОшибки.Вставить("ВерсияПлатформы", СистемнаяИнформация.ВерсияПриложения);
					СтруктураОшибки.Вставить("КлиентОперативнаяПамять", СистемнаяИнформация.ОперативнаяПамять);
					СтруктураОшибки.Вставить("КлиентВерсияОС", СистемнаяИнформация.ВерсияОС);
					СтруктураОшибки.Вставить("КлиентПроцессор", СистемнаяИнформация.Процессор);
					СтруктураОшибки.Вставить("КлиентТипПлатформы", Строка(СистемнаяИнформация.ТипПлатформы));
					СтруктураОшибки.Вставить("КлиентИнформацияПрограммыПросмотра", СистемнаяИнформация.ИнформацияПрограммыПросмотра);
					СтруктураОшибки.Вставить("КлиентТекущаяДата", ТекущаяДатаСеанса());
															
					ИменаФайлов = Новый Массив;
					Если РезультатПрохожденияТестовСценария.Свойство("МассивСкриншотов") Тогда
						Для Каждого ДанныеФайла Из РезультатПрохожденияТестовСценария.МассивСкриншотов Цикл
							ИменаФайлов.Добавить(КаталогВыгрузкиСППР + "\" + ДанныеФайла.ИмяФайла);
						КонецЦикла;	 
					КонецЕсли;	 
					Если РезультатПрохожденияТестовСценария.Свойство("МассивФайлов") Тогда
						Для Каждого ИмяФайла Из РезультатПрохожденияТестовСценария.МассивФайлов Цикл
							Файл = Новый Файл(ИмяФайла);
							ИменаФайлов.Добавить(Файл.Имя);
						КонецЦикла;	 
					КонецЕсли;	 
					СтруктураОшибки.Вставить("ИменаФайлов", ИменаФайлов);
					СтруктураОшибки.Вставить("ВерсияПлатформы", СистемнаяИнформация.ВерсияПриложения);
					СтруктураОшибки.Вставить("СерверОперативнаяПамять", СистемнаяИнформация.ОперативнаяПамять);
					СтруктураОшибки.Вставить("СерверВерсияОС", СистемнаяИнформация.ВерсияОС);
					СтруктураОшибки.Вставить("СерверПроцессор", СистемнаяИнформация.Процессор);
					СтруктураОшибки.Вставить("СерверТипПлатформы", Строка(СистемнаяИнформация.ТипПлатформы));
					СтруктураОшибки.Вставить("СерверИнформацияПрограммыПросмотра", СистемнаяИнформация.ИнформацияПрограммыПросмотра);					
					СтруктураОшибки.Вставить("ВерсияКонфигурации", Метаданные.Версия);
					СтруктураОшибки.Вставить("ИмяКонфигурации", Метаданные.Имя);
					СтруктураОшибки.Вставить("ДатаОбнаружения", ТекущаяДатаСеанса());
					СтруктураОшибки.Вставить("ДостоверностьОбнаружения", "Высокая");
					
					ЗначениеТегаКодСценария = ЗначениеИзТегаСценария(СтрокаДерева, "КодСценария=");
					Если ЗначениеТегаКодСценария <> Неопределено Тогда
						СтруктураОшибки.Вставить("КодСценария", ЗначениеТегаКодСценария);
					КонецЕсли;	 
					СтруктураОшибки.Вставить("ИмяСценария", СтрокаДерева.Имя);
					
					ЗаписьXML = Новый ЗаписьXML;
					ЗаписьXML.УстановитьСтроку();
					
					СериализаторXDTO.ЗаписатьXML(ЗаписьXML, СтруктураОшибки);
					
					ТекстОшибкиXML = ЗаписьXML.Закрыть();
					
					ДанныеОшибки = Новый Структура;
					ДанныеОшибки.Вставить("ТекстОшибкиXML", ТекстОшибкиXML);
					ДопПараметры.МассивДанныхОшибок.Добавить(ДанныеОшибки);
					
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли СтрокаДерева.Тип = "Шаг" Тогда
			Если СтрокаДерева.Родитель.ДопТип = "СтруктураСценария" Тогда
				// его не неадо добавлять в отчет, т.к. этот сценарий явно не выполняется
				ОбойтиДеревоДляОтчетаСППР(СтрокаДерева, ДопПараметры);
			КонецЕсли; 
		ИначеЕсли СтрокаДерева.Тип = "Каталог" Тогда
			
			ДопПараметры.ТекУровеньКаталога = ДопПараметры.ТекУровеньКаталога + 1;
			// Запоминаем уровни каталогов. Нас интересует только уровень 2 и 3. Т.е. если каталоги лежат как
			// features\Core\FeatureLoad, то мы запомним только Core\FeatureLoad
			Если ДопПараметры.ТекУровеньКаталога = 2 Тогда
				ДопПараметры.УровниКаталогов[0] = СтрокаДерева.Имя;
			ИначеЕсли ДопПараметры.ТекУровеньКаталога = 3 Тогда
				ДопПараметры.УровниКаталогов[1] = СтрокаДерева.Имя;
			КонецЕсли;	 
			
			ОбойтиДеревоДляОтчетаСППР(СтрокаДерева, ДопПараметры);
			
			ДопПараметры.ТекУровеньКаталога = ДопПараметры.ТекУровеньКаталога - 1;
		Иначе	
			ОбойтиДеревоДляОтчетаСППР(СтрокаДерева, ДопПараметры);
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры 

Процедура СформироватьОтчетСППР(СтруктураДанных) Экспорт
	
	СтруктураДанных.Вставить("ТекУровеньКаталога", 0);
	СтруктураДанных.Вставить("УровниКаталогов", Новый Массив);
	СтруктураДанных.УровниКаталогов.Добавить("");
	СтруктураДанных.УровниКаталогов.Добавить("");
	
	ОтчетВРежимеУФ = Истина;
	ПараметрыОтчетаУФ = СтруктураДанных;
	
	ОбойтиДеревоДляОтчетаСППР(ДеревоТестов, СтруктураДанных);
	
КонецПроцедуры

#КонецОбласти

#Область Ассерты

#Область Ассерты_EN

// Проверяет, что переданное значение является Истиной.
//
// Параметры:
//   Condition - Булево - Проверяемое значение
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура Assert(Condition, Message = "") Экспорт
	Проверить(Condition, Message);
КонецПроцедуры

// Проверяет, что переданное значение является Истиной.
//
// Параметры:
//   Condition - Булево - Проверяемое значение
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertTrue(Condition, Message = "") Экспорт
	ПроверитьИстину(Condition, Message);
КонецПроцедуры

// Проверяет, что переданное значение является Ложью.
//
// Параметры:
//   Condition - Булево - Проверяемое значение
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertFalse(Condition, Message = "") Экспорт
	ПроверитьЛожь(Condition, Message);
КонецПроцедуры

// Проверяет, что переданная дата входит в переданный период дат.
//
// Параметры:
//   Period - СтандартныйПериод - Период дат, который будет использован для проверки.
//   Date   - Дата - Проверяемая дата.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertDate(Period, Date, Message = "") Экспорт
	ПроверитьДату(Period, Date, Message);
КонецПроцедуры

// Проверяет равенство дат с точностью до двух секунд.
//
// Параметры:
//   ExpectedDate - Дата - Первая проверяемая дата.
//   ActualDate - Дата - Вторая проверяемая дата.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertDateWithin2Seconds(ExpectedDate, ActualDate, Message = "") Экспорт
	ПроверитьРавенствоДатСТочностью2Секунды(ExpectedDate, ActualDate, Message);
КонецПроцедуры

// Проверяет равенство двух значений.
//
// Параметры:
//   Expected - Произвольный - Первое проверяемое значение.
//   Actual - Произвольный - Второе проверяемое значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertEqual(Expected, Actual, Message = "") Экспорт
	ПроверитьРавенство(Expected, Actual, Message);
КонецПроцедуры

// Проверяет неравенство двух значений.
//
// Параметры:
//   NotExpected - Произвольный - Первое проверяемое значение.
//   Actual - Произвольный - Второе проверяемое значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertNotEqual(NotExpected, Actual, Message = "") Экспорт
	ПроверитьНеРавенство(NotExpected, Actual, Message);
КонецПроцедуры

// Проверяет, что второе значение больше первого.
//
// Параметры:
//   ExpectedNumber - Число, Строка, Дата - Первое проверяемое значение.
//   ActualNumber - Число, Строка, Дата - Второе проверяемое значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertGreater(ExpectedNumber, ActualNumber, Message = "") Экспорт
	ПроверитьБольше(ExpectedNumber, ActualNumber, Message);
КонецПроцедуры

// Проверяет, что второе значение больше или равено первому.
//
// Параметры:
//   ExpectedNumber - Число, Строка, Дата - Первое проверяемое значение.
//   ActualNumber - Число, Строка, Дата - Второе проверяемое значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertGreaterOrEqual(ExpectedNumber, ActualNumber, Message = "") Экспорт
	ПроверитьБольшеИлиРавно(ExpectedNumber, ActualNumber, Message);
КонецПроцедуры

// Проверяет, что второе значение меньше первого.
//
// Параметры:
//   ExpectedNumber - Число, Строка, Дата - Первое проверяемое значение.
//   ActualNumber - Число, Строка, Дата - Второе проверяемое значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertLess(ExpectedNumber, ActualNumber, Message = "") Экспорт
	ПроверитьМеньше(ExpectedNumber, ActualNumber, Message);
КонецПроцедуры

// Проверяет, что второе значение меньше или равное первому.
//
// Параметры:
//   ExpectedNumber - Число, Строка, Дата - Первое проверяемое значение.
//   ActualNumber - Число, Строка, Дата - Второе проверяемое значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertLessOrEqual(ExpectedNumber, ActualNumber, Message = "") Экспорт
	ПроверитьМеньшеИлиРавно(ExpectedNumber, ActualNumber, Message);
КонецПроцедуры

// Проверяет, что переданное выражение корректно выполнилось без ошибок.
//
// Параметры:
//   Algorithm - Строка - Строковое выражение, которое будет выполнено.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertExecuted(Знач Algorithm, Знач Message = "") Экспорт
	ПроверитьВыполнилось(Algorithm,  Message);
КонецПроцедуры

// Проверяет, что данный метод у объекта корректно выполнилось без ошибок.
//
// Параметры:
//   Object - Произвольный - Объект, методо которого будет проверяться.
//   MethodName - Строка - Имя метода.
//   ArgsOrMessage - Строка, Массив
//       Если передн массив, то из массива будут получены параметры метода для выполнения.
//       Если передана строка, тогда параметр используется вместо параметра ДопСообщениеОшибки.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertMethodExecuted(Object, Знач MethodName, ArgsOrMessage = Неопределено, Знач Message = "") Экспорт
	ПроверитьМетодВыполнился(Object, MethodName, ArgsOrMessage, Message);
КонецПроцедуры

// Проверяет, что переданное выражение не выполнилось без ошибок.
//
// Параметры:
//   Algorithm - Строка - Строковое выражение, которое будет выполнено.
//   ThrowsExceptionOrMessage - Строка - По этой строке будет выполнен поиск в тексте исключения. Если строка не найдена, тогда будет вызвано исключение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertNotExecuted(Знач Algorithm,  Знач ThrowsExceptionOrMessage = "", Знач Message = "") Экспорт
	ПроверитьНеВыполнилось(Algorithm, ThrowsExceptionOrMessage, Message);
КонецПроцедуры

// Проверяет, что данный метод у объекта вызвал исключение при выполнении.
//
// Параметры:
//   Object - Произвольный - Объект, методо которого будет проверяться.
//   MethodName - Строка - Имя метода.
//   ArgsOrThrowsException - Строка, Массив
//       Если передн массив, то из массива будут получены параметры метода для выполнения.
//       Если передана строка, тогда параметр используется вместо параметра ДопСообщениеОшибки.
//   ThrowsExceptionOrMessage - Строка - Строка, должна быть в строке исключения метода.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertMethodNotExecuted(Object, MethodName, ArgsOrThrowsException, Знач ThrowsExceptionOrMessage = "", Знач Message = "") Экспорт
	ПроверитьМетодНеВыполнился(Object, MethodName, ArgsOrThrowsException, ThrowsExceptionOrMessage, Message);
КонецПроцедуры

// Проверяет, что переданное значение не является пустым.
//
// Параметры:
//   Value - Произвольный - Проверяемое на пустоту значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertFilled(Value, Message = "") Экспорт
	ПроверитьЗаполненность(Value, Message);
КонецПроцедуры

// Проверяет, что переданное значение является пустым.
//
// Параметры:
//   Value - Произвольное - Проверяемое на пустоту значение.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertNotFilled(Value, Message = "") Экспорт
	ПроверитьНеЗаполненность(Value, Message);
КонецПроцедуры

// Проверяет, что переданное значение нужного типа.
//
// Параметры:
//   Value - Произвольный - Проверяемое значение.
//   TypeOrTypeName       - Строка, Тип  - Тип значения.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertType(Value, TypeOrTypeName, Message = "") Экспорт
	ПроверитьТип(Value, TypeOrTypeName, Message);
КонецПроцедуры

// Проверяет, что искомая подстрока входит в строку.
//
// Параметры:
//   String             - Строка - Строка, в которой происходит поиск.
//   Substring    - Строка - Строка, которая ищется.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertStringContains(String, Substring, Message = "") Экспорт
	ПроверитьВхождение(String, Substring, Message);
КонецПроцедуры

// Проверяет, что значение входит в коллекцию.
//
// Параметры:
//   Item            - Произвольный - Значение, которое будет искаться в коллекции.
//   Collection          - Массив, Структура, Соответствие, ФиксированныйМассив, ФиксированнаяСтруктура, ФиксированноеСоответствие, СписокЗначений - Коллекция значений.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура AssertCollectionContains(Item, Collection, Message = "") Экспорт
	ПроверитьВхождениеВКоллекцию(Item, Collection, Message);
КонецПроцедуры

// Проверяет, что запрос СКД не вызовет ошибок компиляции.
//
// Параметры:
//   ТекстЗапроса       - Строка - Текст запроса.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//

Процедура AssertПроверитьВалидностьЗапросаСКД(ТекстЗапроса, ДопСообщениеОшибки = "") Экспорт
	ПроверитьВалидностьЗапросаСКД(ТекстЗапроса, ДопСообщениеОшибки);
КонецПроцедуры

// Проверяет, что табличные документы равны, игнорируя оформление.
//
// Параметры:
//   ТабДок1       - ТабличныйДокумент - Табличный документ.
//   ТабДок2       - ТабличныйДокумент - Табличный документ.
//   УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки - Булево, Строка - Флаг, указывающий, что нужно проверять только видимые колонки.
//   УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки  - Булево, Строка - Флаг, указывающий, что нужно проверять только видимые строки.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//

Процедура AssertПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям(ТабДок1, ТабДок2, УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки = Ложь, 
		УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки = Ложь, 
		Знач ДопСообщениеОшибки = "", 
		ДопПараметры = Неопределено) Экспорт
	ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям(ТабДок1, ТабДок2, УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки, 
		УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки, 
		ДопСообщениеОшибки,
		ДопПараметры);
КонецПроцедуры

// Проверяет, что таблицы равны.
//
// Параметры:
//   ExpectedValueTable       - ТабличныйДокумент - Коллекция значений.
//   ActualValueTable       - ТабличныйДокумент - Коллекция значений.
//   Message - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//   Params - Структура - Дополнительные параметры.
//
Процедура AssertEqualValueTable(ExpectedValueTable, ActualValueTable, Message = "", Params = Undefined) Экспорт
	ПроверитьРавенствоТаблиц(ExpectedValueTable, ActualValueTable, Message, Params);
КонецПроцедуры

// Проверяет равенство файлов
//
// Параметры:
//   ПутьФайла1, ПутьФайла2 - Строка - полные пути к файлам
//   ДопСообщениеОшибки     - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//   ПарамСравнениеФайлов   - Структура - структура с ключами:
//    * ИгнорироватьПустоеПространство - Булево
//    * СпособСравнения                - СпособСравненияФайлов
//    * УчитыватьРазделителиСтрок      - Булево
//    * УчитыватьРегистр               - Булево
//   ПоказатьРазличия       - Строка - в случае ошибки появляется окно сравнения (для отладки)
//
Процедура AssertПроверитьРавенствоФайлов(ПутьФайла1, ПутьФайла2, ДопСообщениеОшибки = "", 
		ПарамСравнениеФайлов = Неопределено, ПоказатьРазличия = Ложь) Экспорт
	ПроверитьРавенствоФайлов(ПутьФайла1, ПутьФайла2, ДопСообщениеОшибки,
		ПарамСравнениеФайлов, ПоказатьРазличия)
КонецПроцедуры

// Позволяет вызывающей системе указать, что нужно прервать выполнени сценария
// Только на клиенте возможно накопление ошибок. На сервере будет вызвано исключение.
Процедура AddError(ErrorDescription) Экспорт
	ДобавитьОшибкуСценария(ErrorDescription);
КонецПроцедуры

#КонецОбласти

#Область Ассерты_RU

// Позволяет вызывающей системе указать, что нужно прервать выполнени сценария
// Только на клиенте возможно накопление ошибок. На сервере будет вызвано исключение.
Процедура ДобавитьОшибкуСценария(ТекстОшибки) Экспорт
	ВызватьИсключение ТекстОшибки;
КонецПроцедуры

// Проверяет, что переданное значение является Истиной.
//
// Параметры:
//   ПроверяемоеЗначение - Булево - Проверяемое значение
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура Проверить(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	Если Не ПроверяемоеЗначение Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Переданный параметр (%1) не является Истиной, а хотели, чтобы являлся. %2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Формат(ПроверяемоеЗначение, "БЛ=ложь; БИ=истина")); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки)); 
		ОбработатьAssertОжидаемоеРеальноеЗначение(ПроверяемоеЗначение, Ложь);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что переданное значение является Истиной.
//
// Параметры:
//   ПроверяемоеЗначение - Булево - Проверяемое значение
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьИстину(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	Проверить(ПроверяемоеЗначение, ДопСообщениеОшибки);
КонецПроцедуры

// Проверяет, что переданное значение является Ложью.
//
// Параметры:
//   ПроверяемоеЗначение - Булево - Проверяемое значение
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьЛожь(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	Если ПроверяемоеЗначение Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Переданный параметр (%1) не является Ложью, а хотели, чтобы являлся. %2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Формат(ПроверяемоеЗначение, "БЛ=ложь; БИ=истина")); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки)); 
		ОбработатьAssertОжидаемоеРеальноеЗначение(Ложь, Истина);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что переданная дата входит в переданный период дат.
//
// Параметры:
//   ПроверямыйПериод - СтандартныйПериод - Период дат, который будет использован для проверки.
//   ПроверяемаяДата   - Дата - Проверяемая дата.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьДату(ПроверямыйПериод, ПроверяемаяДата, ДопСообщениеОшибки = "") Экспорт
	Если ПроверяемаяДата < ПроверямыйПериод.ДатаНачала ИЛИ ПроверяемаяДата > ПроверямыйПериод.ДатаОкончания Тогда
		представление = ПредставлениеПериода(ПроверямыйПериод.ДатаНачала, ПроверямыйПериод.ДатаОкончания, "ФП = Истина");
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Переданный параметр (%1) не входит в период %2, а хотели, чтобы являлся. %3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Формат(ПроверяемаяДата, "ДФ='dd.MM.yyyy HH:mm:ss'"));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", представление);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(ПроверямыйПериод, ПроверяемаяДата);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет равенство дат с точностью до двух секунд.
//
// Параметры:
//   ПерваяДата - Дата - Первая проверяемая дата.
//   ВтораяДата - Дата - Вторая проверяемая дата.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьРавенствоДатСТочностью2Секунды(ПерваяДата, ВтораяДата, ДопСообщениеОшибки = "") Экспорт
	Если ВтораяДата < ПерваяДата - 2 ИЛИ ВтораяДата > ПерваяДата + 2 Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Переданная дата (%1) не равна дате (%2) с точностью до 2-х секунд, а хотели, чтобы они равнялись. %3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Формат(ПерваяДата, "ДФ='dd.MM.yyyy HH:mm:ss'"));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", Формат(ВтораяДата, "ДФ='dd.MM.yyyy HH:mm:ss'"));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(ПерваяДата, ВтораяДата);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет равенство двух значений.
//
// Параметры:
//   ПервоеЗначение - Произвольный - Первое проверяемое значение.
//   ВтороеЗначение - Произвольный - Второе проверяемое значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьРавенство(ПервоеЗначение, ВтороеЗначение, ДопСообщениеОшибки = "") Экспорт
	Если ПервоеЗначение <> ВтороеЗначение Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Сравниваемые значения (%1; %2) не равны, а хотели, чтобы были равны.%3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПервоеЗначение);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ВтороеЗначение);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(ПервоеЗначение, ВтороеЗначение);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры                                                                    

// Проверяет неравенство двух значений.
//
// Параметры:
//   ПервоеЗначение - Произвольный - Первое проверяемое значение.
//   ВтороеЗначение - Произвольный - Второе проверяемое значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьНеРавенство(ПервоеЗначение, ВтороеЗначение, ДопСообщениеОшибки = "") Экспорт
	Если ПервоеЗначение = ВтороеЗначение Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Сравниваемые значения (%1; %2) равны, а хотели, чтобы были не равны.%3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПервоеЗначение);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ВтороеЗначение);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(ПервоеЗначение, ВтороеЗначение);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что второе значение больше первого.
//
// Параметры:
//   ПервоеЗначение - Число, Строка, Дата - Первое проверяемое значение.
//   ВтороеЗначение - Число, Строка, Дата - Второе проверяемое значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьБольше(ЭталонноеЧисло, ПроверяемоеЧисло, ДопСообщениеОшибки = "") Экспорт
	Если ПроверяемоеЧисло <= ЭталонноеЧисло Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Первый параметр (%1) меньше или равен второму (%2) а хотели, чтобы был больше.%3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПроверяемоеЧисло);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ЭталонноеЧисло);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(ЭталонноеЧисло, ПроверяемоеЧисло);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что второе значение больше или равено первому.
//
// Параметры:
//   ПервоеЗначение - Число, Строка, Дата - Первое проверяемое значение.
//   ВтороеЗначение - Число, Строка, Дата - Второе проверяемое значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьБольшеИлиРавно(ЭталонноеЧисло, ПроверяемоеЧисло, ДопСообщениеОшибки = "") Экспорт
	Если ПроверяемоеЧисло < ЭталонноеЧисло Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Первый параметр (%1) меньше второго (%2) а хотели, чтобы был больше или равен.%3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПроверяемоеЧисло);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ЭталонноеЧисло);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(ЭталонноеЧисло, ПроверяемоеЧисло);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что второе значение меньше первого.
//
// Параметры:
//   ПервоеЗначение - Число, Строка, Дата - Первое проверяемое значение.
//   ВтороеЗначение - Число, Строка, Дата - Второе проверяемое значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьМеньше(ЭталонноеЧисло, ПроверяемоеЧисло, СообщениеОбОшибке = "") Экспорт
	Если ПроверяемоеЧисло >= ЭталонноеЧисло Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Значение <%1> больше или равно, чем <%2>, а ожидалось меньше. %3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПроверяемоеЧисло); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ЭталонноеЧисло); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(СообщениеОбОшибке)); 
		ОбработатьAssertОжидаемоеРеальноеЗначение(ЭталонноеЧисло, ПроверяемоеЧисло);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что второе значение меньше или равное первому.
//
// Параметры:
//   ПервоеЗначение - Число, Строка, Дата - Первое проверяемое значение.
//   ВтороеЗначение - Число, Строка, Дата - Второе проверяемое значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьМеньшеИлиРавно(ЭталонноеЧисло, ПроверяемоеЧисло, СообщениеОбОшибке = "") Экспорт
	Если ПроверяемоеЧисло > ЭталонноеЧисло Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Значение <%1> больше, чем <%2>, а ожидалось меньше или равно. %3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПроверяемоеЧисло); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ЭталонноеЧисло); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(СообщениеОбОшибке)); 
		ОбработатьAssertОжидаемоеРеальноеЗначение(ПроверяемоеЧисло, ЭталонноеЧисло);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли; 
КонецПроцедуры

// Проверяет, что переданное выражение корректно выполнилось без ошибок.
//
// Параметры:
//   СтрокаАлгоритм - Строка - Строковое выражение, которое будет выполнено.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьВыполнилось(Знач СтрокаАлгоритм, Знач ДопСообщениеОшибки = "") Экспорт

	Попытка
		Выполнить(СтрокаАлгоритм);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Хотели, чтобы алгоритм <%1> выполнился, а он упал с ошибкой <%2>. %3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", СтрокаАлгоритм);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ПолученноеОписаниеОшибки);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		
		ОбработатьAssertОжидаемоеРеальноеЗначение(Истина, Ложь);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецПопытки;

КонецПроцедуры

// Проверяет, что данный метод у объекта корректно выполнилось без ошибок.
//
// Параметры:
//   Объект - Произвольный - Объект, методо которого будет проверяться.
//   ИмяМетода - Строка - Имя метода.
//   ПараметрыИлиДопСообщениеОшибки - Строка, Массив
//       Если передн массив, то из массива будут получены параметры метода для выполнения.
//       Если передана строка, тогда параметр используется вместо параметра ДопСообщениеОшибки.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьМетодВыполнился(Объект, Знач ИмяМетода, ПараметрыИлиДопСообщениеОшибки = Неопределено, Знач ДопСообщениеОшибки = "") Экспорт
	Перем ПараметрыМетода;
	
	Если ТипЗнч(ПараметрыИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = ПараметрыИлиДопСообщениеОшибки;
	Иначе
		ПараметрыМетода = ПараметрыИлиДопСообщениеОшибки;
		Если ПараметрыМетода <> Неопределено Тогда
			ТипПараметра = ТипЗнч(ПараметрыМетода);
			Если ТипПараметра <> Тип("Массив") Тогда
				ТекстСообщения = ПолучитьТекстСообщенияПользователю("Ожидали, что вторым параметром будет передан массив параметров для метода <%1>, а получили другой объект с типом <%2>");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ИмяМетода);
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ТипПараметра);
				ВызватьИсключение ТекстСообщения;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ПараметрыСтрока = ПараметрыСтрокой(ПараметрыМетода, "ПараметрыМетода");
	
	СтрокаВыполнения = "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
	Попытка
		Выполнить(СтрокаВыполнения);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Хотели, чтобы код <%1> выполнился, а он упал с ошибкой <%2>. %3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", СтрокаВыполнения + "");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ПолученноеОписаниеОшибки + "");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецПопытки;
	
КонецПроцедуры

// Проверяет, что переданное выражение не выполнилось без ошибок.
//
// Параметры:
//   СтрокаАлгоритм - Строка - Строковое выражение, которое будет выполнено.
//   ОжидаемоеОписаниеОшибки - Строка - По этой строке будет выполнен поиск в тексте исключения. Если строка не найдена, тогда будет вызвано исключение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьНеВыполнилось(Знач СтрокаАлгоритм, Знач ОжидаемоеОписаниеОшибки = "", Знач ДопСообщениеОшибки = "") Экспорт
	НужноВызватьОшибку = Истина;
	
	Попытка
		Выполнить(СтрокаАлгоритм);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если Найти(ПолученноеОписаниеОшибки, ОжидаемоеОписаниеОшибки) = 0 Тогда
			ТекстСообщения = ПолучитьТекстСообщенияПользователю("Хотели, чтобы алгоритм <%1> упал с сообщением об ошибке <%2>, а он упал с сообщением <%3>.%4");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", СтрокаАлгоритм);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ОжидаемоеОписаниеОшибки);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ПолученноеОписаниеОшибки);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%4", ФорматДСО(ДопСообщениеОшибки));
			ОбработатьAssertОжидаемоеРеальноеЗначение(Истина, Ложь);
			
			ВызватьОшибкуПроверки(ТекстСообщения);
		КонецЕсли;
		НужноВызватьОшибку = Ложь;
	КонецПопытки;
	
	Если НужноВызватьОшибку Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Хотели, чтобы алгоритм <%1> упал, а он выполнился%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", СтрокаАлгоритм);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(Истина, Ложь);
		
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;	 
	
КонецПроцедуры

// Проверяет, что данный метод у объекта вызвал исключение при выполнении.
//
// Параметры:
//   Объект - Произвольный - Объект, методо которого будет проверяться.
//   ИмяМетода - Строка - Имя метода.
//   ПараметрыИлиОжидаемоеОписаниеОшибки - Строка, Массив
//       Если передн массив, то из массива будут получены параметры метода для выполнения.
//       Если передана строка, тогда параметр используется вместо параметра ДопСообщениеОшибки.
//   ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки - Строка - Строка, должна быть в строке исключения метода.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьМетодНеВыполнился(Объект, ИмяМетода, ПараметрыИлиОжидаемоеОписаниеОшибки, 
			Знач ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки = "", 
			Знач ДопСообщениеОшибки = "") Экспорт

	Перем ПараметрыМетода, ОжидаемоеОписаниеОшибки; 
	
	Если ТипЗнч(ПараметрыИлиОжидаемоеОписаниеОшибки) = Тип("Строка") Тогда
		ОжидаемоеОписаниеОшибки = ПараметрыИлиОжидаемоеОписаниеОшибки;
		ДопСообщениеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	Иначе
		ПараметрыМетода = ПараметрыИлиОжидаемоеОписаниеОшибки;
		Если ПараметрыМетода <> Неопределено Тогда
			ТипПараметра = ТипЗнч(ПараметрыМетода);
			Если ТипПараметра <> Тип("Массив") Тогда
				ТекстСообщения = ПолучитьТекстСообщенияПользователю("Ожидали, что третьим параметром будет передан массив параметров для метода <%1>, а получили другой объект с типом <%2>");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ИмяМетода);
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ТипПараметра);
				ВызватьИсключение ТекстСообщения;
			КонецЕсли;
		КонецЕсли;
		ОжидаемоеОписаниеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	КонецЕсли;
	
	ПараметрыСтрока = ПараметрыСтрокой(ПараметрыМетода, "ПараметрыМетода");
	
	СтрокаВыполнения = "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
	Попытка
		Выполнить(СтрокаВыполнения);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если Найти(ПолученноеОписаниеОшибки, ОжидаемоеОписаниеОшибки) = 0 Тогда
			ТекстСообщения = ПолучитьТекстСообщенияПользователю("Хотели, чтобы код <%1> упал с сообщением об ошибке <%2>, а он упал с сообщением <%3>.%4");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", СтрокаВыполнения);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ОжидаемоеОписаниеОшибки);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ПолученноеОписаниеОшибки);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%4", ФорматДСО(ДопСообщениеОшибки));
			ВызватьОшибкуПроверки(ТекстСообщения);
		КонецЕсли;
		Возврат;
	КонецПопытки;
	
	ТекстСообщения = ПолучитьТекстСообщенияПользователю("Хотели, чтобы код <%1> упал, а он выполнился%2");
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", СтрокаВыполнения);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
	ВызватьОшибкуПроверки(ТекстСообщения);
	
КонецПроцедуры

// Проверяет, что переданное значение не является пустым.
//
// Параметры:
//   ПроверяемоеЗначение - Произвольный - Проверяемое на пустоту значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьЗаполненность(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	// Проверка идет через ЗначениеЗаполнено, но мутабельные значение всегда считаем заполненными
	Попытка
		фЗаполнено = ЗначениеЗаполнено(ПроверяемоеЗначение);
	Исключение
		Возврат;
	КонецПопытки;
	Если НЕ фЗаполнено Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Значение (%1) не заполнено, а ожидалась заполненность%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПроверяемоеЗначение);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(Истина, Ложь);
		
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли; 
КонецПроцедуры

// Проверяет, что переданное значение является пустым.
//
// Параметры:
//   ПроверяемоеЗначение - Произвольный - Проверяемое на пустоту значение.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьНеЗаполненность(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	ТекстСообщения = ПолучитьТекстСообщенияПользователю("Значение (%1) заполнено, а ожидалась незаполненность %2");
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПроверяемоеЗначение);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
	Попытка
		фЗаполнено = ЗначениеЗаполнено(ПроверяемоеЗначение);
	Исключение
		ОбработатьAssertОжидаемоеРеальноеЗначение(Истина, Ложь);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецПопытки;
	Если фЗаполнено Тогда
		ОбработатьAssertОжидаемоеРеальноеЗначение(Истина, Ложь);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли; 
КонецПроцедуры

// Проверяет, что переданное значение нужного типа.
//
// Параметры:
//   ПроверяемоеЗначение - Произвольный - Проверяемое значение.
//   ТипИлиИмяТипа       - Строка, Тип  - Тип значения.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьТип(значение, ТипИлиИмяТипа, ДопСообщениеОшибки = "") Экспорт
	Если ТипЗнч(ТипИлиИмяТипа) = Тип("Строка") Тогда
		искомыйТип = Тип(ТипИлиИмяТипа);
	ИначеЕсли ТипЗнч(ТипИлиИмяТипа) = Тип("Тип") Тогда
		искомыйТип = ТипИлиИмяТипа;
	Иначе
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("ПроверитьТип: Тип значения параметра ТипИлиИмяТипа должен быть <Тип> или <Строка>, а получили <%1>%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ТипЗнч(ТипИлиИмяТипа));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
		ВызватьИсключение ТекстСообщения;
	КонецЕсли;
	Если ТипЗнч(значение) <> искомыйТип Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Типом значения <%1> является <%2>, а ожидался тип <%3>.%4");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", значение);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ТипЗнч(значение));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ТипИлиИмяТипа);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%4", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(ТипЗнч(значение), искомыйТип);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что искомая подстрока входит в строку.
//
// Параметры:
//   Строка             - Строка - Строка, в которой происходит поиск.
//   ПодстрокаПоиска    - Строка - Строка, которая ищется.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьВхождение(строка, подстрокаПоиска, ДопСообщениеОшибки = "") Экспорт
	Если Найти(строка, подстрокаПоиска) = 0 Тогда
		ПредставлениеСтроки = "<" + строка + ">";
		Если СтрДлина(строка) > 20 Тогда
			ПредставлениеСтроки = ПредставлениеСтроки + Символы.ПС;
		КонецЕсли;
		ПредставлениеПодСтроки = "<" + подстрокаПоиска + ">";
		Если СтрДлина(подстрокаПоиска) > 20 Тогда
			ПредставлениеПодСтроки = ПредставлениеПодСтроки + Символы.ПС;
		КонецЕсли;
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Искали в %1 подстроку %2, но не нашли.%3");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПредставлениеСтроки);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ПредставлениеПодСтроки);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(строка, подстрокаПоиска);
		
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что значение входит в коллекцию.
//
// Параметры:
//   Элемент            - Произвольный - Значение, которое будет искаться в коллекции.
//   Коллекция          - Массив, Структура, Соответствие, ФиксированныйМассив, ФиксированнаяСтруктура, ФиксированноеСоответствие, СписокЗначений - Коллекция значений.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьВхождениеВКоллекцию(Элемент, Коллекция, ДопСообщениеОшибки = "") Экспорт
	// Коллекция - Массив, Структура, Соответствие, ФиксированныйМассив, ФиксированнаяСтруктура, ФиксированноеСоответствие, СписокЗначений
	Нашли = Неопределено;
	ТипКоллекции = ТипЗнч(Коллекция);
	Если ТипКоллекции = Тип("Массив") ИЛИ ТипКоллекции = Тип("ФиксированныйМассив") Тогда
		Нашли = Коллекция.Найти(Элемент) <> Неопределено;
	ИначеЕсли ТипКоллекции = Тип("Структура") ИЛИ ТипКоллекции = Тип("Соответствие") 
			ИЛИ ТипКоллекции = Тип("ФиксированнаяСтруктура") ИЛИ ТипКоллекции = Тип("ФиксированноеСоответствие") Тогда
		Для каждого КлючЗначение Из Коллекция Цикл
			Нашли = КлючЗначение.Значение = Элемент;
			Если Нашли Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипКоллекции = Тип("СписокЗначений") Тогда
		Нашли = Коллекция.НайтиПоЗначению(Элемент) <> Неопределено;
	КонецЕсли;
	Если Нашли = Неопределено Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Утверждение <ПроверитьВхождениеВКоллекцию> не умеет работать с типом коллекции <%1>.%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ТипКоллекции);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
		ВызватьИсключение ТекстСообщения;
	КонецЕсли;
	Если Не Нашли Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Не нашли элемент <%1> в коллекции, а хотели, чтобы он был в коллекции.%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Элемент);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
		ОбработатьAssertОжидаемоеРеальноеЗначение(Элемент, Коллекция);
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что запрос СКД не вызовет ошибок компиляции.
//
// Параметры:
//   ТекстЗапроса       - Строка - Текст запроса.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьВалидностьЗапросаСКД(ТекстЗапроса, ДопСообщениеОшибки = "") Экспорт
	
	СхемаКомпоновкиДанных = Новый СхемаКомпоновкиДанных;
	
	ИсточникДанных 					  = СхемаКомпоновкиДанных.ИсточникиДанных.Добавить(); 
	ИсточникДанных.Имя                = "ИсточникДанных";
	ИсточникДанных.СтрокаСоединения   = "";
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	НаборДанных 							 = СхемаКомпоновкиДанных.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя            				 = "НаборДанных";
	НаборДанных.ИсточникДанных 				 = "ИсточникДанных";
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;
	НаборДанных.Запрос 						 = ТекстЗапроса;
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	Попытка
		КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	Исключение
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("%1.%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ОписаниеОшибки());
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецПопытки;
	
КонецПроцедуры // ПроверитьВалидностьЗапросаСКД()

// Проверяет, что в ИБ существует ссылка
//
// Параметры:
//   Ссылка             - СсылочныйТип - Проверяемая ссылка.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//
Процедура ПроверитьНаличиеОбъектаИБ(Ссылка, ДопСообщениеОшибки = "") Экспорт
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Ожидали заполненность ссылки, а получили пустую ссылку.%1");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ФорматДСО(ДопСообщениеОшибки));
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
	лОбъект = Ссылка.ПолучитьОбъект();
	Если лОбъект = Неопределено Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Ожидали существование объекта в ИБ, а получили объект не найден <%1> .%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Ссылка);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ФорматДСО(ДопСообщениеОшибки));
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры

// Проверяет, что табличные документы равны, игнорируя оформление.
//
// Параметры:
//   ТабДок1       - ТабличныйДокумент - Табличный документ.
//   ТабДок2       - ТабличныйДокумент - Табличный документ.
//   УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки - Булево, Строка - Флаг, указывающий, что нужно проверять только видимые колонки.
//   УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки  - Булево, Строка - Флаг, указывающий, что нужно проверять только видимые строки.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//   ДопПараметры - Структура - Дополнительные параметры.
//
Процедура ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям(ТабДок1, ТабДок2, 
		УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки = Ложь, 
		УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки = Ложь, 
		Знач ДопСообщениеОшибки = "", 
		ДопПараметры = Неопределено) Экспорт
	
	Если ТипЗнч(ТабДок1) <> Тип("ТабличныйДокумент") Тогда
		ВызватьИсключение ПолучитьТекстСообщенияПользователю("ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям: Первый параметр-таблица не является табличным документом");
	КонецЕсли;
	Если ТипЗнч(ТабДок2) <> Тип("ТабличныйДокумент") Тогда
		ВызватьИсключение ПолучитьТекстСообщенияПользователю("ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям: Второй параметр-таблица не является табличным документом");
	КонецЕсли;
	
	УчитыватьТолькоВидимыеКолонки = Ложь;
	Если ТипЗнч(УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки) = Тип("Булево") Тогда
		УчитыватьТолькоВидимыеКолонки = УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки;
	ИначеЕсли ТипЗнч(УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки;
	КонецЕсли;
	УчитыватьТолькоВидимыеСтроки = Ложь;
	Если ТипЗнч(УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки) = Тип("Булево") Тогда
		УчитыватьТолькоВидимыеСтроки = УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки;
	ИначеЕсли ТипЗнч(УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки;
	КонецЕсли;
	
	Таб1 = ПолучитьТаблицуЗначенийИзТабличногоДокумента(ТабДок1, УчитыватьТолькоВидимыеКолонки, УчитыватьТолькоВидимыеСтроки);
	Таб2 = ПолучитьТаблицуЗначенийИзТабличногоДокумента(ТабДок2, УчитыватьТолькоВидимыеКолонки, УчитыватьТолькоВидимыеСтроки);
	
	ПроверитьРавенствоТаблиц(Таб1, Таб2, ДопСообщениеОшибки, ДопПараметры);
	
КонецПроцедуры

// Проверяет, что таблицы равны.
//
// Параметры:
//   Таб1       - ТабличныйДокумент - Коллекция значений.
//   Таб2       - ТабличныйДокумент - Коллекция значений.
//   ДопСообщениеОшибки - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//   ДопПараметры - Структура - Дополнительные параметры.
//
Процедура ПроверитьРавенствоТаблиц(Таб1, Таб2, ДопСообщениеОшибки = "", ДопПараметры = Неопределено) Экспорт
	
	Если ТипЗнч(Таб1) <> Тип("ТаблицаЗначений") Тогда
		ВызватьИсключение ПолучитьТекстСообщенияПользователю("ПроверитьРавенствоТаблиц: Первый параметр-таблица таблицей не является");
	КонецЕсли;
	Если ТипЗнч(Таб2) <> Тип("ТаблицаЗначений") Тогда
		ВызватьИсключение ПолучитьТекстСообщенияПользователю("ПроверитьРавенствоТаблиц: Второй параметр-таблица таблицей не является");
	КонецЕсли;
	
	Различия = Новый ТаблицаЗначений;
	РезультатСравнения = СравнитьТаблицыVA(Таб1, Таб2, Различия, ДопСообщениеОшибки, ДопПараметры);
	
	Если РезультатыСравненияТаблиц.ТаблицыСовпадают <> РезультатСравнения Тогда
		
		ИменаРезультатов = Новый Соответствие;
		Для Каждого КлючЗначение Из РезультатыСравненияТаблиц Цикл
			ИменаРезультатов.Вставить(КлючЗначение.Значение, КлючЗначение.Ключ);
		КонецЦикла; 
		
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Различия в таблицах:");
		СтрокаОшибок   = ТекстСообщения + Символы.ПС;
		
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Ожидали статус <%1>, а получили <%2>");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ПолучитьТекстСообщенияПользователю(ИменаРезультатов[РезультатыСравненияТаблиц.ТаблицыСовпадают])); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ПолучитьТекстСообщенияПользователю(ИменаРезультатов[РезультатСравнения])); 
		
		СтрокаОшибок = СтрокаОшибок + ТекстСообщения + Символы.ПС;
		Для Каждого Строка Из Различия Цикл
			ТекстСообщения = ПолучитьТекстСообщенияПользователю("Значение [%1:%2]. Ожидали <%3>, а получили <%4>");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Строка.Колонка); 
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", Строка.Строка); 
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%3", Строка.Ожидание); 
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%4", Строка.Результат); 
			
			СтрокаОшибок = СтрокаОшибок + ТекстСообщения + Символы.ПС;
		КонецЦикла;
		
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Таблицы должны совпадать, а они различны.%1");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Символы.ПС + СтрокаОшибок + Символы.ПС + ДопСообщениеОшибки);
		ОбработатьAssertОжидаемоеРеальноеЗначение(
		    ЗначениеВСтрокуТаблицаЗначенийjUnit(Таб1), ЗначениеВСтрокуТаблицаЗначенийjUnit(Таб2));
		ВызватьОшибкуПроверки(ТекстСообщения);
		
	КонецЕсли;
	
КонецПроцедуры

// Проверяет равенство файлов
//
// Параметры:
//   ПутьФайла1, ПутьФайла2 - Строка - полные пути к файлам
//   ДопСообщениеОшибки     - Строка - Описание ошибки, которое будет использовано в тексте исключения ассерта.
//   ПарамСравнениеФайлов   - Структура - структура с ключами:
//    * ИгнорироватьПустоеПространство - Булево
//    * СпособСравнения                - СпособСравненияФайлов
//    * УчитыватьРазделителиСтрок      - Булево
//    * УчитыватьРегистр               - Булево
//   ПоказатьРазличия       - Строка - в случае ошибки появляется окно сравнения (для отладки)
//
Процедура ПроверитьРавенствоФайлов(ПутьФайла1, ПутьФайла2, ДопСообщениеОшибки = "", 
		ПарамСравнениеФайлов = Неопределено, ПоказатьРазличия = Ложь) Экспорт
#Если ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда
	Если ПарамСравнениеФайлов = Неопределено Тогда
		ПарамСравнениеФайлов = Новый Структура;
	КонецЕсли;
	СравнениеФайлов = Новый СравнениеФайлов;
	СравнениеФайлов.ПервыйФайл = ПутьФайла1;
	СравнениеФайлов.ВторойФайл = ПутьФайла2;
	Если Не ПарамСравнениеФайлов.Свойство("СпособСравнения") Тогда
		Файл = Новый Файл(ПутьФайла1);
		ТипФайла = НРег(Файл.Расширение);
		ТекстовыеТипы = ".txt,.xml";
		Если ТипФайла = ".mxl" Тогда
			ПарамСравнениеФайлов.Вставить("СпособСравнения", СпособСравненияФайлов.ТабличныйДокумент);
		ИначеЕсли Найти(ТекстовыеТипы, ТипФайла) > 0 Тогда
			ПарамСравнениеФайлов.Вставить("СпособСравнения", СпособСравненияФайлов.ТекстовыйДокумент);
		КонецЕсли;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(СравнениеФайлов, ПарамСравнениеФайлов);
	ФайлыИдентичны = СравнениеФайлов.Сравнить();
	Если Не ФайлыИдентичны Тогда
		Если ПоказатьРазличия Тогда // для удобства отладки и расследования ошибок
			СравнениеФайлов.ПоказатьРазличия();
		КонецЕсли;
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("Ожидали идентичность файлов, а получили, что они различны.%1");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ФорматДСО(ДопСообщениеОшибки));
		ВызватьОшибкуПроверки(ТекстСообщения);
	КонецЕсли;
#Иначе 
	ВызватьИсключение ПолучитьТекстСообщенияПользователю("Утверждение ПроверитьРавенствоФайлов можно использовать только в толстом клиенте.");
#КонецЕсли
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область АссертыСлужебное

// портирован из Functest
Функция СравнитьЗначенияТаблиц(ТаблицаОжиданий, ТаблицаРезультатов, Различия, ДопПараметры)
	СравнениеПоШаблону = Ложь;
	Если ДопПараметры <> Неопределено И ДопПараметры.Свойство("СравнениеПоШаблону") Тогда
		СравнениеПоШаблону = ДопПараметры.СравнениеПоШаблону;
	КонецЕсли;	 

	Различия = Новый ТаблицаЗначений;
	Различия.Колонки.Очистить();
	Различия.Колонки.Добавить("Строка", Новый ОписаниеТипов("Число"));
	Различия.Колонки.Добавить("Колонка", Новый ОписаниеТипов("Строка"));
	Различия.Колонки.Добавить("Ожидание");
	Различия.Колонки.Добавить("Результат");
	
	РезультатСравнения = РезультатыСравненияТаблиц.ТаблицыСовпадают;
	
	Колонки = ТаблицаОжиданий.Колонки;
	ГраницаСтрок = ТаблицаОжиданий.Количество() - 1;
	Для Индекс = 0 По ГраницаСтрок Цикл
		
		ОжидаемаяСтрока = ТаблицаОжиданий[Индекс];
		СтрокаРезультата = ТаблицаРезультатов[Индекс];
		
		Для Каждого Колонка Из Колонки Цикл
			ИмяКолонки = Колонка.Имя;
			
			ОжидаемоеЗначение = ОжидаемаяСтрока[ИмяКолонки];
			ЗначениеРезультата = СтрокаРезультата[ИмяКолонки];
			
			Если ОжидаемоеЗначение = "*" Тогда
				Продолжить;
			КонецЕсли;	 
			
			ОжидаемоеЗначение  = СтрЗаменить(ОжидаемоеЗначение, Символы.НПП," ");
			ЗначениеРезультата = СтрЗаменить(ЗначениеРезультата, Символы.НПП," ");
			
			ОжидаемоеЗначение = СтрЗаменить(ОжидаемоеЗначение, Символы.ПС + Символы.ВК, "\n");
			ОжидаемоеЗначение = СтрЗаменить(ОжидаемоеЗначение, Символы.ВК + Символы.ПС, "\n");
			ОжидаемоеЗначение = СтрЗаменить(ОжидаемоеЗначение, Символы.ПС, "\n");
			
			ЗначениеРезультата = СтрЗаменить(ЗначениеРезультата, Символы.ПС + Символы.ВК, "\n");
			ЗначениеРезультата = СтрЗаменить(ЗначениеРезультата, Символы.ВК + Символы.ПС, "\n");
			ЗначениеРезультата = СтрЗаменить(ЗначениеРезультата, Символы.ПС, "\n");
			
			Если НЕ СравнениеПоШаблону Тогда
				Если ОжидаемоеЗначение = ЗначениеРезультата
					Или (Не ЗначениеЗаполнено(ОжидаемоеЗначение) И Не ЗначениеЗаполнено(ЗначениеРезультата)) Тогда //Пустые значения разных типов 1С-м не считаются равными :(
					Продолжить;
				КонецЕсли;
			Иначе	
				Если СтрокаСоответствуетШаблону(ЗначениеРезультата, ОжидаемоеЗначение) Тогда
					Продолжить;
				КонецЕсли;	 
			КонецЕсли;	 

			Различие = Различия.Добавить();
			Различие.Строка = Индекс + 1;
			Различие.Колонка = ИмяКолонки;
			Различие.Ожидание = ОжидаемоеЗначение;
			Различие.Результат = ЗначениеРезультата;
			РезультатСравнения = РезультатыСравненияТаблиц.НеСовпадаютЗначенияВЯчейкеТаблицы;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат РезультатСравнения;
	
КонецФункции

Функция ПодготовитьШаблонКИспользованиюВРегулярке(Шаблон, ДляЛинукс)

	// Экранируем все, кроме звездочки. Ее будем трактовать по-своему.
	СпецСимволы = Новый Массив;
	СпецСимволы.Добавить("\");
	СпецСимволы.Добавить("^");
	СпецСимволы.Добавить("$");
	СпецСимволы.Добавить("(");
	СпецСимволы.Добавить(")");
	СпецСимволы.Добавить("[");
	СпецСимволы.Добавить("]");
	СпецСимволы.Добавить("{");
	СпецСимволы.Добавить("}");
	СпецСимволы.Добавить("|");
	СпецСимволы.Добавить(".");
	СпецСимволы.Добавить("+");
	СпецСимволы.Добавить("?");
	
	Если ДляЛинукс Тогда
		Шаблон = СтрЗаменить(Шаблон, "<", "&lt;"); 
		Шаблон = СтрЗаменить(Шаблон, ">", "&gt;"); 
	Иначе	
		СпецСимволы.Добавить("<");
		СпецСимволы.Добавить(">");
	КонецЕсли;	 
	
	Для Каждого СпецСимвол Из СпецСимволы Цикл
		Шаблон = СтрЗаменить(Шаблон, СпецСимвол, "\" + СпецСимвол); 
	КонецЦикла;
	
	// Трактуем * по-нашему.
	Шаблон = СтрЗаменить(Шаблон, "*", ".*");
	
	Возврат Шаблон;
КонецФункции

Функция СравнитьТаблицыVA(ТаблицаОжиданий, ТаблицаРезультатов, ТаблицаРазличий, ДопСообщениеОшибки, ДопПараметры)
	
	Если ТаблицаОжиданий.Количество() <> ТаблицаРезультатов.Количество() Тогда
		ТекстСообщения = ПолучитьТекстСообщенияПользователю("ТаблицаОжиданий.КоличествоСтрок()=%1, ТаблицаРезультатов.Количество()=%2");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", ТаблицаОжиданий.Количество()); 
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", ТаблицаРезультатов.Количество()); 
		
		ДопСообщениеОшибки = ТекстСообщения;
		Возврат РезультатыСравненияТаблиц.РазноеКоличествоСтрок;
	КонецЕсли;
	
	Если ТаблицаОжиданий.Количество() = 0 Тогда
		Возврат РезультатыСравненияТаблиц.ТаблицыСовпадают; //Пустые таблицы всегда одинаковы
	КонецЕсли;
	
	// Проверим структуру колонок
	
	// TODO При этом сравнении в структуре ТаблицаРезультатов может оказаться больше колонок, чем в ТаблицаОжиданий,
	// так что для абсолютного точного сравнения нужно добавить проверку совпадения количества колонок.
	ОжидаемыеКолонки = ТаблицаОжиданий.Колонки;
	КолонкиРезультата = ТаблицаРезультатов.Колонки;
	Для Каждого Колонка Из ОжидаемыеКолонки Цикл
		Если КолонкиРезультата.Найти(Колонка.Имя) = Неопределено Тогда
			ДопСообщениеОшибки = "КолонкиЭталона.Количество()=" + ОжидаемыеКолонки.Количество() 
				+ ", КолонкиРезультата.Количество()=" + КолонкиРезультата.Количество();
			Возврат РезультатыСравненияТаблиц.РазличаютсяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СравнитьЗначенияТаблиц(ТаблицаОжиданий, ТаблицаРезультатов, ТаблицаРазличий, ДопПараметры);
	
КонецФункции

Функция ПараметрыСтрокой(Параметры, ИмяПеременной = "Параметры")
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено Тогда
		Если ТипЗнч(Параметры) = Тип("Массив") Тогда
			Для Индекс = 0 По Параметры.ВГраница() Цикл 
				ПараметрыСтрока = ПараметрыСтрока + ", " + ИмяПеременной + "[" + Формат(Индекс, "ЧН=0; ЧГ=0") + "]";
			КонецЦикла;
			ПараметрыСтрока = Сред(ПараметрыСтрока, 3);
		Иначе
			ПараметрыСтрока = ИмяПеременной;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПараметрыСтрока;
	
КонецФункции

// Портирован блок ассертов из проекта xUnitFor1C (https://github.com/xDrivenDevelopment/xUnitFor1C)
// был взят релиз 3.0.0.3
// { МЕТОДЫ ДЛЯ ПРОВЕРКИ ЗНАЧЕНИЙ (assertions). 
Функция ФорматДСО(ДопСообщениеОшибки)
	Если ДопСообщениеОшибки = "" Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Символы.ПС + " <" + ДопСообщениеОшибки + ">";
КонецФункции

Процедура ВызватьОшибкуПроверки(СообщениеОшибки)
	
	Префикс = "[" + ПолучитьТекстСообщенияПользователю(СтатусыРезультатаТестирования.ОшибкаПроверки) + "]";
	ТекстСообщения = ПолучитьТекстСообщенияПользователю("%1 %2");
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1", Префикс);
	ТекстСообщения = СтрЗаменить(ТекстСообщения, "%2", СообщениеОшибки);
	ВызватьИсключение ТекстСообщения;
	
КонецПроцедуры

Функция ПолучитьТаблицуЗначенийИзТабличногоДокумента(ТабличныйДокумент, УчитыватьТолькоВидимыеКолонки = Ложь, УчитыватьТолькоВидимыеСтроки = Ложь)
	
	ТипТабличногоДокумента = ТипЗнч(ТабличныйДокумент);
	Если ТипТабличногоДокумента <> Тип("ТабличныйДокумент") И ТипТабличногоДокумента <> Тип("ПолеТабличногоДокумента") Тогда
		ВызватьИсключение ПолучитьТекстСообщенияПользователю("ПолучитьТаблицуЗначенийИзТабличногоДокумента: Требуется тип ТабличныйДокумент или ПолеТабличногоДокумента");
	КонецЕсли;
	
	НомерПоследнейКолонки = ТабличныйДокумент.ШиринаТаблицы;
	НомерПоследнейСтроки = ТабличныйДокумент.ВысотаТаблицы;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений;
	Колонки = НоваяТаблицаЗначений.Колонки;
	ТипСтрока = Новый ОписаниеТипов("Строка");
	
	// TODO При определении видимости не учитывается наличие нескольких форматов строк, сейчас видимоcть колонки
	// определяется по формату первой строки
	УчитываемыеКолонки = Новый Массив;
	Для НомерКолонки = 1 По НомерПоследнейКолонки Цикл
		ОбластьКолонки = ТабличныйДокумент.Область(0, НомерКолонки, 1, НомерКолонки);
		
		УчитыватьКолонку = Не УчитыватьТолькоВидимыеКолонки Или ОбластьКолонки.Видимость;
		Если УчитыватьКолонку Тогда
			УчитываемыеКолонки.Добавить(НомерКолонки);
			ШиринаКолонки = ОбластьКолонки.ШиринаКолонки;
			Если ШиринаКолонки <= 1 Тогда
				ШиринаКолонки = 1;
			КонецЕсли;
			ИмяКолонки = "К" + Формат(Колонки.Количество() + 1, "ЧН=; ЧГ=0");
			Колонки.Добавить(ИмяКолонки, ТипСтрока, ИмяКолонки, ШиринаКолонки);
		КонецЕсли;
	КонецЦикла;
	
	ГраницаКолонок = УчитываемыеКолонки.ВГраница();
	Для НомерСтроки = 1 По НомерПоследнейСтроки Цикл
		
		Если УчитыватьТолькоВидимыеСтроки И Не ТабличныйДокумент.Область(НомерСтроки,, НомерСтроки).Видимость Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = НоваяТаблицаЗначений.Добавить();
		
		Для Индекс = 0 По ГраницаКолонок Цикл
			НомерКолонки = УчитываемыеКолонки[Индекс];
			Область = ТабличныйДокумент.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			НоваяСтрока[Индекс] = Область.Текст;
		КонецЦикла;
	КонецЦикла;
	
	Возврат НоваяТаблицаЗначений;
	
КонецФункции

// взято из https://infostart.ru/public/464971/
Функция ПроверитьСтрокуRegExpLinux(Строка, Фасет)
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + Фасет + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Тест = МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));

    Попытка
        Тест.TestItem = Строка;
        Возврат Истина;
    Исключение
        Возврат Ложь;
    КонецПопытки;
КонецФункции

#КонецОбласти

#Область НастройкиПользователя

// Возвращает глобальные пользовательские настройки.
// 
// Возвращаемое значение:
//  Структура, Неопределено - "Ключ" - имя настройки, - Значение - ее значение;
//								возвращается Неопределено, если настройки не найдены;
//
Функция НастройкиПользователя() Экспорт
	
	Перем НастройкиПользователя;

	ДополнительныеПараметры.Свойство("НастройкиПользователя", НастройкиПользователя);
	Возврат НастройкиПользователя; 
	
КонецФункции

// Возвращает глобальную пользовательскую настройку.
//
// Параметры:
//  Ключ - Строка - имя настройки;
// 
// Возвращаемое значение:
//  Строка, Неопределено - значение пользовательской настройки;
//							возвращается Неопределено, если настройка не найдена;
//
Функция НастройкаПользователя(Знач Ключ) Экспорт

	Перем НастройкаПользователя;

	НастройкиПользователя = НастройкиПользователя();
	
	НастройкаПользователя = Неопределено;
	Если НастройкиПользователя <> Неопределено Тогда
		НастройкиПользователя.Свойство(Ключ, НастройкаПользователя);
	КонецЕсли;
	
	Возврат НастройкаПользователя; 
	
КонецФункции

#КонецОбласти

Процедура ЗапретитьВыполнениеШагов() Экспорт
	ХостФорма = ПолучитьФорму("Форма");
	ХостФорма.ЗапретитьВыполнениеШаговФорма();
КонецПроцедуры

Процедура ПродолжитьВыполнениеШагов(ШагУпал = Ложь) Экспорт
	ХостФорма = ПолучитьФорму("Форма");
	ХостФорма.ПродолжитьВыполнениеШаговФорма(ШагУпал);
КонецПроцедуры

Процедура ОбойтиДеревоДляВнутреннегоФормата(Дерево, ТабличныйДокумент, Макет, Интервал, ПараметрыОтчетаУФ) 
	
	Для каждого СтрСтроки Из Дерево.Строки Цикл
		Секция = Неопределено;
		Сценарий = Новый Структура("имя, name, start, stop, message, status");
		Если СтрСтроки.Тип = "Шаг" Тогда 
			Секция = Макет.ПолучитьОбласть("Шаг");
		Иначе 
			Секция = Макет.ПолучитьОбласть("Заголовок");
		КонецЕсли; 
		Если СтрСтроки.Тип = "Пример" Тогда
			Сценарий.name     = СтрСтроки.Родитель.Родитель.Имя + " №" + (СтрСтроки.Родитель.Строки.Индекс(СтрСтроки));
		Иначе	
			Сценарий.name     = СтрСтроки.Имя;
		КонецЕсли; 
		Сценарий.Имя = Интервал + СтрСтроки.Имя;
		
		Если СтрСтроки.Статус = "Failed" И СтрСтроки.Тип <> "Сценарий" Тогда
			ИДВМассиве = ПараметрыОтчетаУФ.МассивИДСтрокиДерева[СтрСтроки.Родитель.ИДСтроки];
			Если ИДВМассиве <> Неопределено Тогда 
				РезультатПрохожденияТестовСценария = ПараметрыОтчетаУФ.МассивРезультатПрохожденияТестовСценария[ИДВМассиве];
			КонецЕсли;
		КонецЕсли;
		
		Если РезультатПрохожденияТестовСценария <> Неопределено Тогда 
			Сценарий.start = РезультатПрохожденияТестовСценария.ВремяНачала;
			Сценарий.stop  = РезультатПрохожденияТестовСценария.ВремяОкончания;
			Сценарий.message = РезультатПрохожденияТестовСценария.ОписаниеОшибки;
		КонецЕсли;
		
		Секция.Параметры.Заполнить(Сценарий);
		ТабличныйДокумент.Вывести(Секция);
		Если СтрСтроки.Статус = "Failed" И СтрСтроки.Тип <> "Сценарий" Тогда
			Секция = Макет.ПолучитьОбласть("Ошибка");
			Секция.Параметры.Заполнить(Сценарий);
			ТабличныйДокумент.Вывести(Секция);		
		КонецЕсли; 

		Если СтрСтроки.Строки.Количество() > 0 Тогда 
			ТабличныйДокумент.НачатьАвтогруппировкуСтрок();
			ОбойтиДеревоДляВнутреннегоФормата(СтрСтроки, ТабличныйДокумент, Макет, Интервал + "   ", ПараметрыОтчетаУФ);
			ТабличныйДокумент.ЗакончитьАвтогруппировкуСтрок();
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Функция ВывестиОтчетТестированияВоВнутреннемФормате(Дерево, ПараметрыОтчетаУФ) Экспорт

	ТабДок = Новый ТабличныйДокумент;
	Макет = ПолучитьМакет("ОтчетТестирования");
	
	Секция = Макет.ПолучитьОбласть("Заголовок");
	
	Интервал = "";
	ОбойтиДеревоДляВнутреннегоФормата(Дерево, ТабДок, Макет, Интервал + "   ", ПараметрыОтчетаУФ);
		
	ТабДок.ОтображатьСетку = Ложь;
	ТабДок.Защита = Ложь;
	ТабДок.ТолькоПросмотр = Ложь;
	ТабДок.ОтображатьЗаголовки = Ложь;
	
	Возврат ТабДок;
	
КонецФункции

Функция Шаг(Стр) Экспорт
	ХостФорма = ПолучитьФорму("Форма");
	ХостФорма.ШагФорма(Стр);
	// todo надо разобраться, может это все-таки процедура
	Возврат Неопределено;
КонецФункции	

Процедура СоздатьКолонкиДерева(Дерево) Экспорт
	Дерево.Колонки.Добавить("Имя");
	Дерево.Колонки.Добавить("Статус");
	Дерево.Колонки.Добавить("ПолныйПуть");
	
	Дерево.Колонки.Добавить("ИменованныеПараметры");
	
	Дерево.Колонки.Добавить("ЗначенияПараметров");
	Дерево.Колонки.Добавить("Снипет");
	Дерево.Колонки.Добавить("АдресСнипета");
	Дерево.Колонки.Добавить("ЭтоЧужойСнипет");
	Дерево.Колонки.Добавить("СтрокаРеальнойПроцедуры");
	
	Дерево.Колонки.Добавить("РезультатПрохожденияТестовСценария");
	
	Дерево.Колонки.Добавить("ШагСПараметрамиВТаблице");
	Дерево.Колонки.Добавить("СтрокаПараметровШагаВВидеТаблицы");
	Дерево.Колонки.Добавить("ПараметрыТаблицы");
	Дерево.Колонки.Добавить("ИмяШагаБезКлючевогоСлова");
	Дерево.Колонки.Добавить("ШагСценарий");
	Дерево.Колонки.Добавить("МассивСценариевЗащитаОтЗацикливания");
	Дерево.Колонки.Добавить("ФичаИмеетСвоюEPF");
	
	Дерево.Колонки.Добавить("НомерСтрокиВФиче");
	
	Если Дерево.Колонки.Найти("ТипКартинки") = Неопределено Тогда
		Дерево.Колонки.Добавить("ТипКартинки");
	КонецЕсли;	 
	
	Дерево.Колонки.Добавить("ЗначениеОтступа", Новый ОписаниеТипов("Число"));
	Дерево.Колонки.Добавить("Тип", Новый ОписаниеТипов("Строка"));
	Дерево.Колонки.Добавить("ДопТип", Новый ОписаниеТипов("Строка"));
	
	Дерево.Колонки.Добавить("ПроизвольныеЗначения");

КонецПроцедуры

Функция ДобавитьШагВМассивТестов(МассивТестов, Снипет, ИмяПроцедуры, ПредставлениеТеста = Неопределено, 
		ОписаниеШага = Неопределено, ТипШагаДляОписания = Неопределено, ТипШагаВДереве = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	Структура.Вставить("Снипет", Снипет);
	Структура.Вставить("ИмяПроцедуры", ИмяПроцедуры);
	Структура.Вставить("ПредставлениеТеста", ПредставлениеТеста);
	Структура.Вставить("ОписаниеШага", ОписаниеШага);
	Структура.Вставить("ТипШага", ТипШагаДляОписания);
	Структура.Вставить("ТипШагаВДереве", ТипШагаВДереве);
	Структура.Вставить("Транзакция", Неопределено);
	МассивТестов.Добавить(Структура);
	
	// todo надо разобраться, может это все-таки процедура
	Возврат Неопределено;

КонецФункции

Процедура УстановитьРезультатУсловия(Результат) Экспорт
	РезультатУсловия = Результат;
КонецПроцедуры

Функция ПолныйТекстОшибкиjUnut(Знач Стр, ДопПараметры)
	Стр = СтрЗаменить(Стр,")}: ", ")}:");
	Стр = СтрЗаменить(Стр, ")}:", ")}:" + Символы.ПС);
	
	МассивСтрок = РазложитьСтрокуВМассивПодстрок(Стр, Символы.ПС);
	
	ИдСтрокиСтекВызоваНачало = 0;
	ИдСтрокиСтекВызоваКонец  = -1;
	ИдСтрокиДанныеОшибкиНачало  = -1;
	ИдСтрокиДанныеОшибкиКонец  = -1;
	ИдСтрокиТехническиеДанные = -1;
	Для Ккк = 0 По МассивСтрок.Количество() - 1 Цикл
		ТекСтр = МассивСтрок[Ккк];
		Если Прав(ТекСтр, 3) = ")}:" Тогда
			ИдСтрокиСтекВызоваКонец = Ккк;
		Иначе
			Прервать;
		КонецЕсли;	 
	КонецЦикла;	
	
	Если ИдСтрокиСтекВызоваКонец >= 0 И ДопПараметры.СтрокаТехническиеДанные <> Неопределено Тогда
		ИдСтрокиДанныеОшибкиНачало = ИдСтрокиСтекВызоваКонец + 1;
		Для Ккк = ИдСтрокиДанныеОшибкиНачало По МассивСтрок.Количество() - 1 Цикл
			ТекСтр = МассивСтрок[Ккк];
			Если ТекСтр = ДопПараметры.СтрокаТехническиеДанные Тогда
				ИдСтрокиДанныеОшибкиКонец = Ккк - 1;
				ИдСтрокиТехническиеДанные = Ккк;
				Прервать;
			КонецЕсли;	 
		КонецЦикла;
	КонецЕсли;	
	
	Если ИдСтрокиДанныеОшибкиКонец >= 0 И ИдСтрокиДанныеОшибкиКонец >= 0 И ИдСтрокиТехническиеДанные >= 0 Тогда
		Стр = "";
		Для Ккк = ИдСтрокиДанныеОшибкиНачало По ИдСтрокиДанныеОшибкиКонец Цикл
			Стр = Стр + МассивСтрок[Ккк] + Символы.ПС;
		КонецЦикла;	
		 
		Если Прав(Стр, 1) <> Символы.ПС Тогда
			Стр = Стр + Символы.ПС;
		КонецЕсли;	 
		
		Для Ккк = ИдСтрокиСтекВызоваНачало По ИдСтрокиСтекВызоваКонец Цикл
			Стр = Стр + МассивСтрок[Ккк] + Символы.ПС;
		КонецЦикла;	
		
		Стр = СокрП(Стр);
		Стр = Стр + Символы.ПС + Символы.ПС;
		
		Для Ккк = ИдСтрокиТехническиеДанные По МассивСтрок.Количество() - 1 Цикл
			Стр = Стр + МассивСтрок[Ккк] + Символы.ПС;
		КонецЦикла;	
	КонецЕсли;	 
	
	Возврат Стр;
КонецФункции	 

Функция ЗначениеВСтрокуjUnit(Знач Значение)
	ТипЗначения = ТипЗнч(Значение);
	
	Если ТипЗначения = Тип("Строка") Тогда
		Возврат Формат(Значение, "ЧГ=; ЧН=0");
	ИначеЕсли ТипЗначения = Тип("Массив") Тогда
		Возврат ЗначениеВСтрокуМассивjUnit(Значение); 
	ИначеЕсли ТипЗначения = Тип("Структура") 
			ИЛИ ТипЗначения = Тип("Соответствие") 
			ИЛИ ТипЗначения = Тип("СписокЗначений") Тогда
		Возврат ЗначениеВСтрокуПростаяКоллекцияjUnit(Значение); 
	ИначеЕсли ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Возврат ЗначениеВСтрокуТаблицаЗначенийjUnit(Значение); 
	ИначеЕсли ТипЗначения = Тип("Тип") ИЛИ ТипЗначения = Тип("СтандартныйПериод") Тогда
		Возврат Строка(Значение); 
	Иначе
		Попытка
			Возврат Формат(Значение, "ЧГ=; ЧН=0");
		Исключение
			Возврат Строка(Значение); 
		КонецПопытки;
	КонецЕсли;	 
КонецФункции	 

Функция ЗначениеВСтрокуМассивjUnit(Коллекция)
	Стр = "";
	Для Ккк = 0 По Коллекция.Количество() - 1 Цикл
		Стр = Стр + ЗначениеВСтрокуjUnit(Коллекция[Ккк]);
		Если Ккк < Коллекция.Количество() - 1 Тогда
			Стр = Стр + Символы.ПС;
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат Стр; 
КонецФункции	

Функция ЗначениеВСтрокуПростаяКоллекцияjUnit(Коллекция)
	Стр = "|";
	Для Каждого Элем Из Коллекция Цикл
		Стр = " " + Стр + Элем.Значение + " |";
	КонецЦикла;	 
	
	Возврат Стр; 
КонецФункции	 

Функция ЗначениеВСтрокуТаблицаЗначенийjUnit(Тзн)
	МассивСтрокТаблицы = Новый Массив;
	
	СтрокаТаблица = "";
	КолСтрок = Тзн.Количество();
	Ном = 0;
	Для Каждого СтрокаТзн Из Тзн Цикл
		Ном = Ном + 1;
		Стр = "|";
		Для Каждого Колонка Из Тзн.Колонки Цикл
			Стр = Стр + " " + ЗначениеВСтрокуjUnit(СтрокаТзн[Колонка.Имя]) + " |";
		КонецЦикла;	 
		
		МассивСтрокТаблицы.Добавить(Стр);
	КонецЦикла;	 
	
	ФорматироватьТаблицуGherkin(МассивСтрокТаблицы);
	
	СтрокаТаблицы = "";
	Для Каждого Стр Из МассивСтрокТаблицы Цикл
		СтрокаТаблицы = СтрокаТаблицы + Стр + Символы.ПС;
	КонецЦикла;	 
	
	Возврат СтрокаТаблицы;
КонецФункции	 

Процедура ФорматироватьТаблицуGherkin(МассивТаблицы)
	Если МассивТаблицы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;	 
	
	МассивПараметров = ОпределитьПараметрыВСтрокеПримера(МассивТаблицы[0]);
	КолПараметров = МассивПараметров.Количество();
	МассивДлин = Новый Массив;
	Для каждого Элем Из МассивПараметров Цикл
		МассивДлин.Добавить(0);
	КонецЦикла;
	
	Для каждого СтрТзн Из МассивТаблицы Цикл
		МассивПараметров = ОпределитьПараметрыВСтрокеПримера(СтрТзн);
		
		Для Ккк = 0 По МассивДлин.Количество() - 1 Цикл
			ДлинаСтроки = СтрДлина(СокрЛП(МассивПараметров.Получить(Ккк)));
			Если ДлинаСтроки > МассивДлин[Ккк] Тогда
				МассивДлин[Ккк] = ДлинаСтроки;
			КонецЕсли;	 
		КонецЦикла;
	КонецЦикла;
	
	Для Ррр = 0 По (МассивТаблицы.Количество() - 1) Цикл
		СтрТзн = МассивТаблицы[Ррр];
		МассивПараметров = ОпределитьПараметрыВСтрокеПримера(СтрТзн);
		СтрПараметров = "| ";
		Для Ккк = 0 По МассивДлин.Количество() - 1 Цикл
			Зн = СокрЛП(МассивПараметров[Ккк]);
			Зн = Зн + НужноеЧислоПробелов(МассивДлин[Ккк] - СтрДлина(Зн));
			СтрПараметров = СтрПараметров + Зн + " | ";
		КонецЦикла;
		
		СтрПараметров = СокрЛП(СтрПараметров);
		
		МассивТаблицы[Ррр] = СтрПараметров;
	КонецЦикла;
КонецПроцедуры

Функция ОпределитьПараметрыВСтрокеПримера(Знач Стр)
	Массив = Новый Массив;

	Стр = СтрЗаменить(Стр, "\|", "~ЭкранированиеВертикальнойЧерты~");
	
	Стр = СокрЛП(Стр);
	Если Лев(Стр, 1) <> "|" ИЛИ Прав(Стр, 1) <> "|" Тогда
		Возврат Массив;
	КонецЕсли;	 
	
	Стр = Сред(Стр, 2);
	Стр = Сред(Стр, 1, СтрДлина(Стр) - 1);
	// убрали символы |
	
	Массив = РазложитьСтрокуВМассивПодстрок(Стр, "|");
	
	Для Ккк = 0 По Массив.Количество() - 1 Цикл
		Массив[Ккк] = СокрЛП(Массив[Ккк]);
		Массив[Ккк] = СтрЗаменить(Массив[Ккк], "~ЭкранированиеВертикальнойЧерты~", "\|");
	КонецЦикла;
	
	Спс = Новый СписокЗначений;
	Для каждого Элем Из Массив Цикл
		Спс.Добавить(Элем);
	КонецЦикла;
	
	Возврат  Спс;
КонецФункции

Процедура ОбработатьAssertОжидаемоеРеальноеЗначение(ОжидаемоеЗначение, РеальноеЗначение) Экспорт
	
	Если ПустаяСтрока(АдресДанныеОбОшибке) Тогда
		Возврат;
	КонецЕсли;	 
	
	СтруктураОшибки = ПолучитьИзВременногоХранилища(АдресДанныеОбОшибке);
	
	Если ТипЗнч(СтруктураОшибки) = Тип("Структура") Тогда
		СтруктураОшибки.ОшибкаAssert     = Истина;
		СтруктураОшибки.ЗначениеActual   = РеальноеЗначение;
		СтруктураОшибки.ЗначениеExpected = ОжидаемоеЗначение;
		
		ПоместитьВоВременноеХранилище(СтруктураОшибки, АдресДанныеОбОшибке);
	КонецЕсли;	 
	
КонецПроцедуры 

Функция НужноеЧислоПробелов(КолПробелов)
	Результат = КешСтрокаПробелов[КолПробелов];
	Если Результат <> Неопределено Тогда
		Возврат Результат; 
	КонецЕсли;	 
	
	Стр = "";
	Для Сч = 1 По КолПробелов Цикл
		Стр = Стр + " ";
	КонецЦикла;	
	
	КешСтрокаПробелов.Вставить(КолПробелов, Стр);
	Возврат Стр; 
		
КонецФункции	 

#КонецОбласти

// Служебная строка. Не удалять. #КонецОбласти ПроцедурыИФункции

#Область ИнициализацияПеременных

СтатусыРезультатаТестирования = Новый Структура;
СтатусыРезультатаТестирования.Вставить("ОшибкаПроверки", "Failed");
СтатусыРезультатаТестирования.Вставить("НеизвестнаяОшибка", "Broken");
СтатусыРезультатаТестирования.Вставить("ТестПропущен", "Pending");
СтатусыРезультатаТестирования = Новый ФиксированнаяСтруктура(СтатусыРезультатаТестирования);

РезультатыСравненияТаблиц = Новый Структура;
РезультатыСравненияТаблиц.Вставить("ТаблицыСовпадают", 0);
РезультатыСравненияТаблиц.Вставить("НеСовпадаютЗначенияВЯчейкеТаблицы", 1);
РезультатыСравненияТаблиц.Вставить("РазноеКоличествоСтрок", 2);
РезультатыСравненияТаблиц.Вставить("РазличаютсяКолонки", 3);
РезультатыСравненияТаблиц = Новый ФиксированнаяСтруктура(РезультатыСравненияТаблиц);

ЭтоLinux = Ложь;
СисИнфо = Новый СистемнаяИнформация;
Если СисИнфо.ТипПлатформы = ТипПлатформы.Linux_x86 
	ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Linux_x86_64
	ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.MacOS_x86
	ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.MacOS_x86_64 Тогда 
	ЭтоLinux = Истина;
КонецЕсли;

ТипыПлагинов = ТипыПлагинов();

РазницаВМилисекундахМеждуЮниксИНачалЭпохи = 62135596800000;

КешСтрокаПробелов = Новый Соответствие;

#КонецОбласти

// Служебная строка. Не удалять. #КонецОбласти ИнициализацияПеременных
